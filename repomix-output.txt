This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-26T08:08:42.909Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.cargo/
  config.toml
background/
  src/
    lib.rs
  Cargo.toml
bincode/
  src/
    lib.rs
  Cargo.toml
cipher/
  src/
    aes.rs
    argon2.rs
    keychain.rs
    lib.rs
    ntrup.rs
    options.rs
  Cargo.toml
config/
  src/
    abi.rs
    address.rs
    argon.rs
    cipher.rs
    contracts.rs
    key.rs
    lib.rs
    sha.rs
    storage.rs
    wallet.rs
  Cargo.toml
crypto/
  src/
    bip49.rs
    lib.rs
    schnorr.rs
  Cargo.toml
network/
  src/
    lib.rs
    provider.rs
    token.rs
  Cargo.toml
proto/
  src/
    address.rs
    btc_addr.rs
    keypair.rs
    lib.rs
    pubkey.rs
    secret_key.rs
    signature.rs
    tx.rs
    zil_address.rs
    zil_tx.rs
    zilliqa_message.rs
    ZilliqaMessage.proto
    zq1_proto.rs
  build.rs
  Cargo.toml
session/
  src/
    lib.rs
  Cargo.toml
settings/
  src/
    common_settings.rs
    crypto.rs
    currency.rs
    language.rs
    lib.rs
    network.rs
    notificcations.rs
    security.rs
    storage.rs
    theme.rs
    wallet_settings.rs
  Cargo.toml
storage/
  src/
    data_warp.rs
    lib.rs
  Cargo.toml
wallet/
  src/
    account_type.rs
    account.rs
    ft.rs
    lib.rs
    wallet_data.rs
    wallet_types.rs
  Cargo.toml
zil_errors/
  src/
    account.rs
    address.rs
    background.rs
    cipher.rs
    crypto.rs
    keychain.rs
    keypair.rs
    lib.rs
    network.rs
    ntru.rs
    session.rs
    storage.rs
    token.rs
    wallet.rs
    zilliqa.rs
  Cargo.toml
zilliqa/
  src/
    json_rpc/
      mod.rs
      zil_interfaces.rs
      zil_methods.rs
      zil.rs
    lib.rs
  Cargo.toml
zilpay/
  src/
    lib.rs
  Cargo.toml
.gitignore
Cargo.lock
Cargo.toml

================================================================
Repository Files
================================================================

================
File: .cargo/config.toml
================


================
File: background/src/lib.rs
================
use bip39::{Language, Mnemonic};
use cipher::{argon2, keychain::KeyChain};
use config::{
    cipher::{PROOF_SALT, PROOF_SIZE},
    sha::SHA256_SIZE,
    storage::{INDICATORS_DB_KEY, NETWORK_DB_KEY},
};
use crypto::bip49::Bip49DerivationPath;
use network::provider::NetworkProvider;
use proto::{address::Address, keypair::KeyPair, secret_key::SecretKey};
use session::{decrypt_session, encrypt_session};
use settings::common_settings::CommonSettings;
use std::sync::Arc;
use storage::LocalStorage;
use wallet::{
    wallet_data::AuthMethod, wallet_types::WalletTypes, Bip39Params, LedgerParams, Wallet,
    WalletConfig,
};
use zil_errors::background::BackgroundError;

use rand::{RngCore, SeedableRng};
use rand_chacha::ChaCha20Rng;

pub struct BackgroundBip39Params<'a> {
    pub password: &'a str,
    pub mnemonic_str: &'a str,
    pub indexes: &'a [usize],
    pub passphrase: &'a str,
    pub wallet_name: String,
    pub biometric_type: AuthMethod,
    pub device_indicators: &'a [String],
    pub network: Vec<usize>,
}

pub struct BackgroundSKParams<'a> {
    pub password: &'a str,
    pub secret_key: &'a SecretKey,
    pub account_name: String,
    pub wallet_name: String,
    pub biometric_type: AuthMethod,
    pub device_indicators: &'a [String],
    pub network: Vec<usize>,
}

pub struct Background {
    storage: Arc<LocalStorage>,
    pub wallets: Vec<Wallet>,
    pub indicators: Vec<[u8; SHA256_SIZE]>,
    pub is_old_storage: bool,
    pub settings: CommonSettings,
    pub netowrk: Vec<NetworkProvider>,
}

fn load_network(storage: Arc<LocalStorage>) -> Vec<NetworkProvider> {
    let bytes = storage.get(NETWORK_DB_KEY).unwrap_or_default();

    if bytes.is_empty() {
        return NetworkProvider::new_vec();
    }

    serde_json::from_slice(&bytes).unwrap_or(NetworkProvider::new_vec())
}

impl Background {
    pub fn gen_bip39(count: u8) -> Result<String, BackgroundError> {
        if ![12, 15, 18, 21, 24].contains(&count) {
            return Err(BackgroundError::InvalidWordCount(count));
        }

        let entropy_bits = (count as usize * 11) - (count as usize / 3);
        let entropy_bytes = (entropy_bits + 7) / 8;
        let mut rng = ChaCha20Rng::from_entropy();
        let mut entropy = vec![0u8; entropy_bytes];

        rng.fill_bytes(&mut entropy);

        let m = Mnemonic::from_entropy_in(Language::English, &entropy)
            .map_err(|e| BackgroundError::FailToGenBip39FromEntropy(e.to_string()))?;

        Ok(m.to_string())
    }

    pub fn gen_keypair() -> Result<(String, String), BackgroundError> {
        let (pub_key, secret_key) =
            KeyPair::gen_keys_bytes().map_err(BackgroundError::FailToGenKeyPair)?;

        Ok((hex::encode(secret_key), hex::encode(pub_key)))
    }
}

impl Background {
    pub fn from_storage_path(path: &str) -> Result<Self, BackgroundError> {
        let storage =
            LocalStorage::from(path).map_err(BackgroundError::TryInitLocalStorageError)?;
        let storage = Arc::new(storage);
        let is_old_storage = false; // TODO: check old storage from first ZilPay version
        let indicators = storage
            .get(INDICATORS_DB_KEY)
            .unwrap_or_default()
            .chunks(SHA256_SIZE)
            .map(|chunk| {
                let mut array = [0u8; SHA256_SIZE];
                array.copy_from_slice(chunk);
                array
            })
            .collect::<Vec<[u8; SHA256_SIZE]>>();
        let mut wallets = Vec::new();
        let netowrk = load_network(Arc::clone(&storage));

        for addr in &indicators {
            let w = Wallet::load_from_storage(addr, Arc::clone(&storage))
                .map_err(BackgroundError::TryLoadWalletError)?;

            wallets.push(w);
        }

        Ok(Self {
            netowrk,
            storage,
            wallets,
            indicators,
            is_old_storage,
            settings: Default::default(),
        })
    }

    pub fn unlock_wallet_with_password(
        &mut self,
        password: &str,
        device_indicators: &[String],
        wallet_index: usize,
    ) -> Result<(), BackgroundError> {
        let device_indicator = device_indicators.join(":");
        let argon_seed = argon2::derive_key(password.as_bytes(), &device_indicator)
            .map_err(BackgroundError::ArgonPasswordHashError)?;
        let wallet = self
            .wallets
            .get_mut(wallet_index)
            .ok_or(BackgroundError::WalletNotExists(wallet_index))?;

        wallet
            .unlock(&argon_seed)
            .map_err(BackgroundError::FailUnlockWallet)?;

        Ok(())
    }

    pub fn unlock_wallet_with_session(
        &mut self,
        session_cipher: Vec<u8>,
        device_indicators: &[String],
        wallet_index: usize,
    ) -> Result<(), BackgroundError> {
        let wallet = self
            .wallets
            .get_mut(wallet_index)
            .ok_or(BackgroundError::WalletNotExists(wallet_index))?;
        let wallet_device_indicators = std::iter::once(wallet.data.wallet_address.clone())
            .chain(device_indicators.iter().cloned())
            .collect::<Vec<_>>()
            .join(":");

        let seed_bytes = decrypt_session(
            &wallet_device_indicators,
            session_cipher,
            &wallet.data.settings.crypto.cipher_orders,
        )
        .map_err(BackgroundError::DecryptSessionError)?;

        wallet
            .unlock(&seed_bytes)
            .map_err(BackgroundError::FailUnlockWallet)?;

        Ok(())
    }

    pub fn add_bip39_wallet<F>(
        &mut self,
        params: BackgroundBip39Params,
        derive_fn: F,
    ) -> Result<Vec<u8>, BackgroundError>
    where
        F: Fn(usize) -> Bip49DerivationPath,
    {
        let device_indicator = params.device_indicators.join(":");
        let argon_seed = argon2::derive_key(params.password.as_bytes(), &device_indicator)
            .map_err(BackgroundError::ArgonPasswordHashError)?;
        let keychain =
            KeyChain::from_seed(&argon_seed).map_err(BackgroundError::FailCreateKeychain)?;
        let mnemonic = Mnemonic::parse_in_normalized(bip39::Language::English, params.mnemonic_str)
            .map_err(|e| BackgroundError::FailParseMnemonicWords(e.to_string()))?;
        let indexes: Vec<(Bip49DerivationPath, String)> = params
            .indexes
            .iter()
            .map(|i| (derive_fn(*i), format!("account {i}")))
            .collect();
        let proof = argon2::derive_key(&argon_seed[..PROOF_SIZE], PROOF_SALT)
            .map_err(BackgroundError::ArgonCreateProofError)?;
        let wallet_config = WalletConfig {
            keychain,
            storage: Arc::clone(&self.storage),
            settings: Default::default(), // TODO: setup settings
        };
        let options = &wallet_config.settings.crypto.cipher_orders.clone();
        let wallet = Wallet::from_bip39_words(Bip39Params {
            proof: &proof,
            mnemonic: &mnemonic,
            passphrase: params.passphrase,
            indexes: &indexes,
            config: wallet_config,
            wallet_name: params.wallet_name,
            biometric_type: params.biometric_type,
            network: params.network,
        })
        .map_err(BackgroundError::FailToInitWallet)?;
        let indicator = wallet.key().map_err(BackgroundError::FailToInitWallet)?;
        let device_indicator = std::iter::once(hex::encode(indicator))
            .chain(params.device_indicators.iter().cloned())
            .collect::<Vec<_>>()
            .join(":");

        let session = if params.biometric_type == AuthMethod::None {
            Vec::new()
        } else {
            encrypt_session(&device_indicator, &argon_seed, options)
                .map_err(BackgroundError::CreateSessionError)?
        };

        wallet
            .save_to_storage()
            .map_err(BackgroundError::FailToSaveWallet)?;

        self.indicators.push(indicator);
        self.wallets.push(wallet);
        self.save_indicators()?;
        self.storage
            .flush()
            .map_err(BackgroundError::LocalStorageFlushError)?;

        Ok(session)
    }

    pub fn add_ledger_wallet(
        &mut self,
        params: LedgerParams,
        device_indicators: &[String],
    ) -> Result<Vec<u8>, BackgroundError> {
        if self
            .wallets
            .iter()
            .any(|w| w.data.wallet_type == WalletTypes::Ledger(params.ledger_id.clone()))
        {
            return Err(BackgroundError::LedgerIdExists(
                String::from_utf8(params.ledger_id.clone()).unwrap_or_default(),
            ));
        }

        let device_indicator = device_indicators.join(":");
        let argon_seed = argon2::derive_key(device_indicator.as_bytes(), "ledger")
            .map_err(BackgroundError::ArgonPasswordHashError)?;
        let keychain =
            KeyChain::from_seed(&argon_seed).map_err(BackgroundError::FailCreateKeychain)?;
        let proof = argon2::derive_key(&argon_seed[..PROOF_SIZE], PROOF_SALT)
            .map_err(BackgroundError::ArgonCreateProofError)?;
        let wallet_config = WalletConfig {
            keychain,
            storage: Arc::clone(&self.storage),
            settings: Default::default(), // TODO: setup settings
        };
        let biometric_type = params.biometric_type;
        let options = &wallet_config.settings.crypto.cipher_orders.clone();
        let wallet = Wallet::from_ledger(params, &proof, wallet_config)
            .map_err(BackgroundError::FailToInitWallet)?;
        let indicator = wallet.key().map_err(BackgroundError::FailToInitWallet)?;
        let device_indicator = std::iter::once(hex::encode(indicator))
            .chain(device_indicators.iter().cloned())
            .collect::<Vec<_>>()
            .join(":");
        let session = if biometric_type == AuthMethod::None {
            Vec::new()
        } else {
            encrypt_session(&device_indicator, &argon_seed, options)
                .map_err(BackgroundError::CreateSessionError)?
        };

        wallet
            .save_to_storage()
            .map_err(BackgroundError::FailToSaveWallet)?;
        self.indicators.push(indicator);
        self.wallets.push(wallet);
        self.save_indicators()?;
        self.storage
            .flush()
            .map_err(BackgroundError::LocalStorageFlushError)?;

        Ok(session)
    }

    pub fn add_sk_wallet(
        &mut self,
        params: BackgroundSKParams,
    ) -> Result<Vec<u8>, BackgroundError> {
        let device_indicator = params.device_indicators.join(":");
        let argon_seed = argon2::derive_key(params.password.as_bytes(), &device_indicator)
            .map_err(BackgroundError::ArgonPasswordHashError)?;
        let keychain =
            KeyChain::from_seed(&argon_seed).map_err(BackgroundError::FailCreateKeychain)?;
        let proof = argon2::derive_key(&argon_seed[..PROOF_SIZE], PROOF_SALT)
            .map_err(BackgroundError::ArgonCreateProofError)?;
        let wallet_config = WalletConfig {
            keychain,
            storage: Arc::clone(&self.storage),
            settings: Default::default(), // TODO: setup settings
        };
        let options = &wallet_config.settings.crypto.cipher_orders.clone();
        let wallet = Wallet::from_sk(
            params.secret_key,
            params.account_name,
            &proof,
            wallet_config,
            params.wallet_name,
            params.biometric_type,
            params.network,
        )
        .map_err(BackgroundError::FailToInitWallet)?;

        let indicator = wallet.key().map_err(BackgroundError::FailToInitWallet)?;
        let device_indicator = std::iter::once(hex::encode(indicator))
            .chain(params.device_indicators.iter().cloned())
            .collect::<Vec<_>>()
            .join(":");

        let session = if params.biometric_type == AuthMethod::None {
            Vec::new()
        } else {
            encrypt_session(&device_indicator, &argon_seed, options)
                .map_err(BackgroundError::CreateSessionError)?
        };

        wallet
            .save_to_storage()
            .map_err(BackgroundError::FailToSaveWallet)?;
        self.indicators.push(indicator);
        self.wallets.push(wallet);
        self.save_indicators()?;
        self.storage
            .flush()
            .map_err(BackgroundError::LocalStorageFlushError)?;

        Ok(session)
    }

    pub async fn update_nodes(&mut self, id: usize) -> Result<(), BackgroundError> {
        let net_pointer = self
            .netowrk
            .get_mut(id)
            .ok_or(BackgroundError::NetworkProviderNotExists(id))?;

        net_pointer
            .update_nodes()
            .await
            .map_err(BackgroundError::NetworkErrors)?;

        self.save_network()?;
        self.storage
            .flush()
            .map_err(BackgroundError::LocalStorageFlushError)?;

        Ok(())
    }

    pub async fn get_ftoken_meta(
        &self,
        wallet_index: usize,
        contract: Address,
    ) -> Result<(), BackgroundError> {
        let w = self
            .wallets
            .get(wallet_index)
            .ok_or(BackgroundError::WalletNotExists(wallet_index))?;
        let accounts = w
            .data
            .accounts
            .iter()
            .map(|a| a.addr.clone())
            .collect::<Vec<Address>>();

        for net_id in &w.data.network {
            self.netowrk
                .get(*net_id)
                .ok_or(BackgroundError::NetworkProviderNotExists(*net_id))?
                .get_ftoken_meta(&contract, &accounts)
                .await
                .map_err(BackgroundError::NetworkErrors)?;
        }

        Ok(())
    }

    pub async fn sync_ftokens_balances(
        &mut self,
        wallet_index: usize,
    ) -> Result<(), BackgroundError> {
        let w = self
            .wallets
            .get_mut(wallet_index)
            .ok_or(BackgroundError::WalletNotExists(wallet_index))?;

        if w.ftokens.is_empty() {
            return Err(BackgroundError::FailUnlockWallet(
                zil_errors::wallet::WalletErrors::KeyChainFailToGetProof,
            ));
        }

        let addresses = w
            .data
            .accounts
            .iter()
            .map(|a| a.addr.clone())
            .collect::<Vec<Address>>();

        for net_id in &w.data.network {
            self.netowrk
                .get_mut(*net_id)
                .ok_or(BackgroundError::NetworkProviderNotExists(*net_id))?
                .get_tokens_balances(&mut w.ftokens, &addresses)
                .await
                .map_err(BackgroundError::NetworkErrors)?;
        }

        w.save_to_storage()
            .map_err(BackgroundError::FailToSaveWallet)?;
        self.storage
            .flush()
            .map_err(BackgroundError::LocalStorageFlushError)?;

        Ok(())
    }

    fn save_network(&self) -> Result<(), BackgroundError> {
        let bytes =
            serde_json::to_vec(&self.netowrk).or(Err(BackgroundError::FailToSerializeNetworks))?;

        self.storage
            .set(NETWORK_DB_KEY, &bytes)
            .map_err(BackgroundError::FailToWriteIndicatorsWallet)?;

        Ok(())
    }

    fn save_indicators(&self) -> Result<(), BackgroundError> {
        let bytes: Vec<u8> = self
            .indicators
            .iter()
            .flat_map(|array| array.iter().cloned())
            .collect();

        self.storage
            .set(INDICATORS_DB_KEY, &bytes)
            .map_err(BackgroundError::FailToWriteIndicatorsWallet)?;

        Ok(())
    }
}

#[cfg(test)]
mod tests_background {
    use super::*;
    use config::{
        argon::KEY_SIZE,
        key::{PUB_KEY_SIZE, SECRET_KEY_SIZE},
    };
    use proto::keypair::KeyPair;
    use rand::Rng;
    use session::decrypt_session;

    #[test]
    fn test_add_more_wallets_bip39() {
        let mut rng = rand::thread_rng();
        let dir = format!("/tmp/{}", rng.gen::<usize>());
        let mut bg = Background::from_storage_path(&dir).unwrap();

        assert_eq!(bg.wallets.len(), 0);

        let password = "test_password";
        let words: &str =
            "area scale vital sell radio pattern poverty mean similar picnic grain gain";
        let indexes = [0usize];
        let derive = Bip49DerivationPath::Zilliqa;
        let network = vec![0];

        let _key = bg
            .add_bip39_wallet(
                BackgroundBip39Params {
                    password,
                    network: network.clone(),
                    mnemonic_str: words,
                    indexes: &indexes,
                    passphrase: "",
                    wallet_name: String::new(),
                    biometric_type: Default::default(),
                    device_indicators: &[String::from("apple"), String::from("0000")],
                },
                derive,
            )
            .unwrap();

        assert_eq!(bg.wallets.len(), 1);

        drop(bg);

        let mut bg = Background::from_storage_path(&dir).unwrap();

        let _key = bg
            .add_bip39_wallet(
                BackgroundBip39Params {
                    password,
                    network: network.clone(),
                    mnemonic_str: words,
                    indexes: &indexes,
                    passphrase: "",
                    wallet_name: String::new(),
                    biometric_type: Default::default(),
                    device_indicators: &[String::from("apple"), String::from("1102")],
                },
                derive,
            )
            .unwrap();

        let password = "test_password";
        let words: &str =
            "clap chair edit noise sugar box raccoon play another hobby soccer fringe";
        let indexes = [0, 1];
        let derive = Bip49DerivationPath::Zilliqa;

        let _key = bg
            .add_bip39_wallet(
                BackgroundBip39Params {
                    password,
                    network,
                    mnemonic_str: words,
                    indexes: &indexes,
                    passphrase: "",
                    wallet_name: String::new(),
                    device_indicators: &[String::from("apple"), String::from("43498")],
                    biometric_type: Default::default(),
                },
                derive,
            )
            .unwrap();

        drop(bg);

        let bg = Background::from_storage_path(&dir).unwrap();

        assert_eq!(bg.wallets.len(), 3);
    }

    #[test]
    fn test_from_bip39() {
        let mut rng = rand::thread_rng();
        let dir = format!("/tmp/{}", rng.gen::<usize>());
        let mut bg = Background::from_storage_path(&dir).unwrap();

        assert_eq!(bg.wallets.len(), 0);

        let password = "test_password";
        let words: &str =
            "green process gate doctor slide whip priority shrug diamond crumble average help";
        let indexes = [0, 1, 2, 3, 4, 5, 6, 7];
        let derive = Bip49DerivationPath::Zilliqa;
        let device_indicators = [String::from("apple"), String::from("4354")];
        let network = vec![0];

        let session = bg
            .add_bip39_wallet(
                BackgroundBip39Params {
                    device_indicators: &device_indicators,
                    password,
                    mnemonic_str: words,
                    indexes: &indexes,
                    passphrase: "",
                    wallet_name: String::new(),
                    biometric_type: AuthMethod::FaceId,
                    network,
                },
                derive,
            )
            .unwrap();

        assert_eq!(bg.wallets.len(), 1);

        drop(bg);

        let mut bg = Background::from_storage_path(&dir).unwrap();
        let wallet = bg.wallets.first_mut().unwrap();

        let wallet_device_indicators = std::iter::once(wallet.data.wallet_address.clone())
            .chain(device_indicators)
            .collect::<Vec<_>>()
            .join(":");

        let seed_bytes = decrypt_session(
            &wallet_device_indicators,
            session,
            &wallet.data.settings.crypto.cipher_orders,
        )
        .unwrap();

        assert_eq!(
            wallet.unlock(&[42u8; KEY_SIZE]),
            Err(zil_errors::wallet::WalletErrors::KeyChainFailToGetProof)
        );

        wallet.unlock(&seed_bytes).unwrap();

        let res_words = wallet.reveal_mnemonic(&seed_bytes).unwrap().to_string();

        assert_eq!(res_words, words);

        let keypair = wallet.reveal_keypair(1, &seed_bytes, None).unwrap();
        let sk = keypair.get_secretkey().unwrap();

        assert_eq!(
            sk.to_string(),
            "00fe8b8ee252f3d1348ca68c8537cb4d26a44826abe12a227df3b5db47bf6e0fe3"
        );
    }

    #[test]
    fn test_from_ledger() {
        let mut rng = rand::thread_rng();
        let dir = format!("/tmp/{}", rng.gen::<usize>());
        let mut bg = Background::from_storage_path(&dir).unwrap();
        let mut ledger_id = vec![0u8; 32];

        rng.fill_bytes(&mut ledger_id);

        assert_eq!(bg.wallets.len(), 0);

        let device_indicators = [String::from("android"), String::from("4354")];
        let keypair = KeyPair::gen_sha256().unwrap();
        let pub_key = keypair.get_pubkey().unwrap();
        let networks = vec![0];

        let session = bg
            .add_ledger_wallet(
                LedgerParams {
                    networks,
                    pub_key: &pub_key,
                    name: String::from("account 0"),
                    ledger_id,
                    wallet_index: 0,
                    wallet_name: String::from("Ledger nano x"),
                    biometric_type: AuthMethod::FaceId,
                },
                &device_indicators,
            )
            .unwrap();

        assert_eq!(bg.wallets.len(), 1);

        drop(bg);

        let mut bg = Background::from_storage_path(&dir).unwrap();
        let wallet = bg.wallets.first_mut().unwrap();

        let wallet_device_indicators = std::iter::once(wallet.data.wallet_address.clone())
            .chain(device_indicators)
            .collect::<Vec<_>>()
            .join(":");

        let seed_bytes = decrypt_session(
            &wallet_device_indicators,
            session,
            &wallet.data.settings.crypto.cipher_orders,
        )
        .unwrap();

        assert_eq!(
            wallet.unlock(&[42u8; KEY_SIZE]),
            Err(zil_errors::wallet::WalletErrors::KeyChainFailToGetProof)
        );

        wallet.unlock(&seed_bytes).unwrap();
    }

    #[test]
    fn test_2_same_ledger() {
        let mut rng = rand::thread_rng();
        let dir = format!("/tmp/{}", rng.gen::<usize>());
        let mut bg = Background::from_storage_path(&dir).unwrap();
        let ledger_id = "ledger_id".as_bytes().to_vec();

        assert_eq!(bg.wallets.len(), 0);

        let device_indicators = [String::from("android"), String::from("4354")];
        let keypair = KeyPair::gen_sha256().unwrap();
        let pub_key = keypair.get_pubkey().unwrap();
        let networks = vec![0];

        bg.add_ledger_wallet(
            LedgerParams {
                networks: networks.clone(),
                pub_key: &pub_key,
                name: String::from("account 0"),
                ledger_id: ledger_id.clone(),
                wallet_index: 0,
                wallet_name: String::from("Ledger nano x"),
                biometric_type: AuthMethod::FaceId,
            },
            &device_indicators,
        )
        .unwrap();

        assert_eq!(
            bg.add_ledger_wallet(
                LedgerParams {
                    networks,
                    pub_key: &pub_key,
                    name: String::from("account 0"),
                    ledger_id: ledger_id.clone(),
                    wallet_index: 0,
                    wallet_name: String::from("Ledger nano x"),
                    biometric_type: AuthMethod::FaceId,
                },
                &device_indicators,
            ),
            Err(BackgroundError::LedgerIdExists(
                String::from_utf8(ledger_id).unwrap()
            ))
        )
    }

    #[test]
    fn test_from_sk() {
        let mut rng = rand::thread_rng();
        let dir = format!("/tmp/{}", rng.gen::<usize>());
        let mut bg = Background::from_storage_path(&dir).unwrap();

        assert_eq!(bg.wallets.len(), 0);

        let password = "pass";
        let keypair = KeyPair::gen_sha256().unwrap();
        let sk = keypair.get_secretkey().unwrap();
        let name = "SK Account 0".to_string();
        let device_indicators = vec![String::from("test"), String::from("0543543")];
        let network = vec![0];
        let session = bg
            .add_sk_wallet(BackgroundSKParams {
                network,
                password,
                secret_key: &sk,
                account_name: name,
                wallet_name: "test_wallet name".to_string(),
                biometric_type: AuthMethod::Fingerprint,
                device_indicators: &device_indicators,
            })
            .unwrap();

        assert_eq!(bg.wallets.len(), 1);

        drop(bg);
        let mut bg = Background::from_storage_path(&dir).unwrap();
        let wallet = bg.wallets.first_mut().unwrap();
        let wallet_device_indicators = std::iter::once(wallet.data.wallet_address.clone())
            .chain(device_indicators)
            .collect::<Vec<_>>()
            .join(":");

        let seed_bytes = decrypt_session(
            &wallet_device_indicators,
            session,
            &wallet.data.settings.crypto.cipher_orders,
        )
        .unwrap();

        assert_eq!(
            wallet.reveal_mnemonic(&seed_bytes),
            Err(zil_errors::wallet::WalletErrors::InvalidAccountType)
        );
        assert_eq!(
            wallet.unlock(&[42u8; KEY_SIZE]),
            Err(zil_errors::wallet::WalletErrors::KeyChainFailToGetProof)
        );

        wallet.unlock(&seed_bytes).unwrap();

        let res_keypair = wallet.reveal_keypair(0, &seed_bytes, None).unwrap();

        assert_eq!(res_keypair, keypair);
    }

    #[test]
    fn test_bip39_gen() {
        let words = Background::gen_bip39(12).unwrap();
        assert_eq!(words.split(" ").collect::<Vec<&str>>().len(), 12);

        let words = Background::gen_bip39(15).unwrap();
        assert_eq!(words.split(" ").collect::<Vec<&str>>().len(), 15);

        let words = Background::gen_bip39(18).unwrap();
        assert_eq!(words.split(" ").collect::<Vec<&str>>().len(), 18);

        let words = Background::gen_bip39(21).unwrap();
        assert_eq!(words.split(" ").collect::<Vec<&str>>().len(), 21);

        let words = Background::gen_bip39(24).unwrap();
        assert_eq!(words.split(" ").collect::<Vec<&str>>().len(), 24);

        assert_eq!(
            Background::gen_bip39(33 /* wrong number */),
            Err(BackgroundError::InvalidWordCount(33))
        );
    }

    #[test]
    fn test_keypair_gen() {
        let (sk, pk) = Background::gen_keypair().unwrap();

        assert_eq!(hex::decode(sk).unwrap().len(), SECRET_KEY_SIZE);
        assert_eq!(hex::decode(pk).unwrap().len(), PUB_KEY_SIZE);
    }
}

================
File: background/Cargo.toml
================
[package]
name = "background"
version = "0.1.0"
edition = "2021"

[dependencies]
zil_errors = { path = "../zil_errors" }
session = { path = "../session" }
wallet = { path = "../wallet" }
storage = { path = "../storage" }
config = { path = "../config" }
settings = { path = "../settings" }
crypto = { path = "../crypto" }
proto = { path = "../proto" }
cipher = { path = "../cipher" }
network = { path = "../network" }
bip39 = "2.0.0"
rand_chacha = "0.3.1"
rand = "0.8.5"
hex = "0.4.3"
serde = { version = "1.0.204", features = ["derive"] }
serde_json = "1.0.124"

================
File: bincode/src/lib.rs
================
use std::borrow::Cow;

pub trait ToBytes<const N: usize> {
    type Error;
    fn to_bytes(&self) -> Result<[u8; N], Self::Error>;
}

pub trait ToVecBytes {
    fn to_bytes(&self) -> Vec<u8>;
}

pub trait ToOptionVecBytes {
    type Error;
    fn to_bytes(&self) -> Result<Vec<u8>, Self::Error>;
}

pub trait FromBytes: Sized {
    type Error;
    fn from_bytes(bytes: Cow<[u8]>) -> Result<Self, Self::Error>;
}

================
File: bincode/Cargo.toml
================
[package]
name = "bincode"
version = "0.1.0"
edition = "2021"

[dependencies]

================
File: cipher/src/aes.rs
================
use aes_gcm::{
    aead::{Aead, AeadCore, KeyInit, OsRng},
    Aes256Gcm, Key, Nonce,
};
use zil_errors::cipher::AesGCMErrors;

pub const AES_GCM_KEY_SIZE: usize = 32;
pub const AES_GCM_NONCE_SIZE: usize = 12;

pub fn aes_gcm_encrypt(
    key: &[u8; AES_GCM_KEY_SIZE],
    plaintext: &[u8],
) -> Result<Vec<u8>, AesGCMErrors> {
    let key: &Key<Aes256Gcm> = key.into();
    let cipher = Aes256Gcm::new(key);
    let nonce = Aes256Gcm::generate_nonce(&mut OsRng);
    let mut bytes = cipher
        .encrypt(&nonce, plaintext)
        .map_err(|e| AesGCMErrors::EncryptError(e.to_string()))?;

    bytes.extend(nonce);

    Ok(bytes)
}

pub fn aes_gcm_decrypt(
    key: &[u8; AES_GCM_KEY_SIZE],
    cipher_nonce: &[u8],
) -> Result<Vec<u8>, AesGCMErrors> {
    let key: &Key<Aes256Gcm> = key.into();
    let cipher = Aes256Gcm::new(key);
    let ciphertext = &cipher_nonce[..cipher_nonce.len() - AES_GCM_NONCE_SIZE];
    let nonce = &cipher_nonce[cipher_nonce.len() - AES_GCM_NONCE_SIZE..];
    let nonce = Nonce::from_slice(nonce);

    cipher
        .decrypt(nonce, ciphertext)
        .map_err(|e| AesGCMErrors::DecryptError(e.to_string()))
}

#[cfg(test)]
mod tests {
    use super::{aes_gcm_decrypt, aes_gcm_encrypt, AES_GCM_KEY_SIZE};
    use rand::{RngCore, SeedableRng};
    use rand_chacha::ChaCha20Rng;

    #[test]
    fn encrypt_and_decrypt() {
        let mut rng = ChaCha20Rng::from_entropy();
        let mut plaintext = [0u8; 100];
        let mut key = [0u8; AES_GCM_KEY_SIZE];

        rng.fill_bytes(&mut plaintext);
        rng.fill_bytes(&mut key);

        let ciphertext = aes_gcm_encrypt(&key, &plaintext).unwrap();
        let plaintext_restore = aes_gcm_decrypt(&key, &ciphertext).unwrap();

        assert_eq!(plaintext_restore, plaintext);
    }
}

================
File: cipher/src/argon2.rs
================
use argon2::Argon2;
use config::argon::{KEY_SIZE, WALLET_SALT};
use zil_errors::cipher::CipherErrors;

pub fn derive_key(password: &[u8], salt: &str) -> Result<[u8; KEY_SIZE], CipherErrors> {
    let mut output_key_material = [0u8; KEY_SIZE];
    let argon2 = Argon2::default();
    let mut salt = salt.as_bytes().to_vec();

    salt.extend_from_slice(WALLET_SALT);

    argon2
        .hash_password_into(password, &salt, &mut output_key_material)
        .map_err(|e| CipherErrors::ArgonKeyDerivingError(e.to_string()))?;

    Ok(output_key_material)
}

#[cfg(test)]
mod tests {
    use super::derive_key;

    #[test]
    fn test_derive_key() {
        let password = b"test_password";
        let key = derive_key(password, "").unwrap();

        assert_eq!(
            key,
            [
                105, 163, 39, 110, 187, 108, 209, 71, 192, 27, 68, 241, 118, 214, 246, 178, 29,
                104, 200, 155, 198, 86, 120, 219, 16, 9, 228, 81, 190, 208, 236, 153, 9, 88, 58,
                136, 123, 69, 67, 37, 202, 217, 182, 51, 253, 254, 173, 77, 100, 61, 52, 130, 148,
                76, 1, 67, 38, 172, 203, 49, 163, 201, 103, 178,
            ]
        )
    }
}

================
File: cipher/src/keychain.rs
================
use crate::{
    aes::{aes_gcm_decrypt, aes_gcm_encrypt, AES_GCM_KEY_SIZE},
    argon2::derive_key,
    ntrup::{ntru_decrypt, ntru_encrypt, ntru_keys_from_seed},
    options::CipherOrders,
};
use config::argon::KEY_SIZE;
use config::sha::SHA256_SIZE;
use ntrulp::{
    key::{priv_key::PrivKey, pub_key::PubKey},
    params::params::{PUBLICKEYS_BYTES, SECRETKEYS_BYTES},
};
use zil_errors::keychain::KeyChainErrors;

pub const KEYCHAIN_BYTES_SIZE: usize = PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE;

pub struct KeyChain {
    pub ntrup_keys: (PubKey, PrivKey),
    pub aes_key: [u8; AES_GCM_KEY_SIZE],
}

impl KeyChain {
    pub fn from_bytes(bytes: &[u8; KEYCHAIN_BYTES_SIZE]) -> Result<Self, KeyChainErrors> {
        let pq_pk_bytes: [u8; PUBLICKEYS_BYTES] = bytes[..PUBLICKEYS_BYTES]
            .try_into()
            .or(Err(KeyChainErrors::AESKeySliceError))?;
        let pq_sk_bytes: [u8; SECRETKEYS_BYTES] = bytes
            [PUBLICKEYS_BYTES..PUBLICKEYS_BYTES + SECRETKEYS_BYTES]
            .try_into()
            .or(Err(KeyChainErrors::AESKeySliceError))?;
        let pq_pk = PubKey::import(&pq_pk_bytes);
        let pq_sk =
            PrivKey::import(&pq_sk_bytes).map_err(KeyChainErrors::NTRUPrimePubKeyImportError)?;

        let mut aes_key = [0u8; AES_GCM_KEY_SIZE];

        aes_key.copy_from_slice(&bytes[PUBLICKEYS_BYTES + SECRETKEYS_BYTES..]);

        Ok(Self {
            ntrup_keys: (pq_pk, pq_sk),
            aes_key,
        })
    }

    pub fn from_seed(seed_bytes: &[u8; KEY_SIZE]) -> Result<Self, KeyChainErrors> {
        let (pk, sk) =
            ntru_keys_from_seed(seed_bytes).map_err(KeyChainErrors::NTRUPrimeCipherError)?;
        let aes_key: [u8; AES_GCM_KEY_SIZE] = seed_bytes[SHA256_SIZE..]
            .try_into()
            .or(Err(KeyChainErrors::AESKeySliceError))?;

        Ok(Self {
            ntrup_keys: (pk, sk),
            aes_key,
        })
    }

    pub fn from_pass(password: &[u8], fingerprint: &str) -> Result<Self, KeyChainErrors> {
        let seed_bytes =
            derive_key(password, fingerprint).map_err(KeyChainErrors::Argon2CipherErrors)?;

        Self::from_seed(&seed_bytes)
    }

    pub fn to_bytes(&self) -> [u8; KEYCHAIN_BYTES_SIZE] {
        let mut res = [0u8; PUBLICKEYS_BYTES + SECRETKEYS_BYTES + AES_GCM_KEY_SIZE];
        let pq_pk = self.ntrup_keys.0.to_bytes();
        let pq_sk = self.ntrup_keys.1.to_bytes();

        res[..PUBLICKEYS_BYTES].copy_from_slice(&pq_pk);
        res[PUBLICKEYS_BYTES..PUBLICKEYS_BYTES + SECRETKEYS_BYTES].copy_from_slice(&pq_sk);
        res[PUBLICKEYS_BYTES + SECRETKEYS_BYTES..].copy_from_slice(&self.aes_key);

        res
    }

    pub fn decrypt(
        &self,
        mut ciphertext: Vec<u8>,
        options: &[CipherOrders],
    ) -> Result<Vec<u8>, KeyChainErrors> {
        for o in options.iter().rev() {
            match o {
                CipherOrders::AESGCM256 => {
                    ciphertext = aes_gcm_decrypt(&self.aes_key, &ciphertext)
                        .map_err(KeyChainErrors::AESDecryptError)?
                }
                CipherOrders::NTRUP1277 => {
                    ciphertext = ntru_decrypt(self.ntrup_keys.1.clone(), ciphertext)
                        .map_err(KeyChainErrors::NTRUPrimeDecryptError)?
                }
            };
        }

        Ok(ciphertext)
    }

    pub fn encrypt(
        &self,
        mut plaintext: Vec<u8>,
        options: &[CipherOrders],
    ) -> Result<Vec<u8>, KeyChainErrors> {
        let pk = &self.ntrup_keys.0;

        for o in options {
            match o {
                CipherOrders::AESGCM256 => {
                    plaintext = aes_gcm_encrypt(&self.aes_key, &plaintext)
                        .map_err(KeyChainErrors::AESEncryptError)?
                }
                CipherOrders::NTRUP1277 => {
                    plaintext = ntru_encrypt(pk.clone(), &plaintext)
                        .map_err(KeyChainErrors::NTRUPrimeEncryptError)?
                }
            };
        }

        Ok(plaintext)
    }

    pub fn make_proof(
        &self,
        seed: &[u8; KEY_SIZE],
        options: &[CipherOrders],
    ) -> Result<Vec<u8>, KeyChainErrors> {
        let cipher = self.encrypt(seed.to_vec(), options)?;

        Ok(cipher)
    }

    pub fn get_proof(
        &self,
        cipher_proof: &[u8],
        options: &[CipherOrders],
    ) -> Result<[u8; KEY_SIZE], KeyChainErrors> {
        let origin_seed: [u8; KEY_SIZE] = self
            .decrypt(cipher_proof.to_vec(), options)?
            .try_into()
            .or(Err(KeyChainErrors::FailSlicedProofCipher))?;

        Ok(origin_seed)
    }
}

#[cfg(test)]
mod tests {
    use core::panic;

    use crate::argon2::derive_key;

    use super::{CipherOrders, KeyChain};
    use config::cipher::PROOF_SIZE;
    use rand::{RngCore, SeedableRng};
    use rand_chacha::ChaCha20Rng;
    use zil_errors::{cipher::AesGCMErrors, keychain::KeyChainErrors};

    #[test]
    fn test_init_keychain() {
        let mut rng = ChaCha20Rng::from_entropy();
        let mut password = [0u8; 32];

        rng.fill_bytes(&mut password);

        let keychain = KeyChain::from_pass(&password, "");

        assert!(keychain.is_ok());
    }

    #[test]
    fn test_bytes() {
        let mut rng = ChaCha20Rng::from_entropy();
        let mut password = [0u8; 32];
        let mut plaintext = [0u8; 1024];

        rng.fill_bytes(&mut password);
        rng.fill_bytes(&mut plaintext);

        let keychain = KeyChain::from_pass(&password, "").unwrap();
        let bytes = keychain.to_bytes();
        let restore_keychain = KeyChain::from_bytes(&bytes).unwrap();

        assert_eq!(restore_keychain.aes_key, keychain.aes_key);
        assert_eq!(
            restore_keychain.ntrup_keys.0.to_bytes(),
            keychain.ntrup_keys.0.to_bytes()
        );
        assert_eq!(
            restore_keychain.ntrup_keys.1.to_bytes(),
            keychain.ntrup_keys.1.to_bytes()
        );
    }

    #[test]
    fn test_encrypt_and_decrypt() {
        let mut rng = ChaCha20Rng::from_entropy();
        let mut password = [0u8; 32];
        let mut plaintext = [0u8; 1024];

        rng.fill_bytes(&mut password);
        rng.fill_bytes(&mut plaintext);

        let keychain = KeyChain::from_pass(&password, "").unwrap();
        let options = [CipherOrders::AESGCM256, CipherOrders::NTRUP1277];
        let ciphertext = keychain.encrypt(plaintext.to_vec(), &options).unwrap();
        let res_plaintext = keychain.decrypt(ciphertext.clone(), &options).unwrap();

        assert_eq!(res_plaintext, plaintext);

        let invalid_options = [CipherOrders::NTRUP1277, CipherOrders::AESGCM256];

        match keychain.decrypt(ciphertext, &invalid_options) {
            Ok(_) => panic!("invalid options should be fail decrypt"),
            Err(e) => match e {
                KeyChainErrors::AESDecryptError(AesGCMErrors::DecryptError(err)) => {
                    assert_eq!("aead::Error", err);
                }
                _ => panic!("should be fall with AESDecryptError"),
            },
        };
    }

    #[test]
    fn test_make_verify_proof() {
        let mut rng = ChaCha20Rng::from_entropy();
        let mut password = [0u8; 32];

        rng.fill_bytes(&mut password);

        let options = [CipherOrders::NTRUP1277, CipherOrders::AESGCM256];
        let seed_bytes = derive_key(&password, "").unwrap();
        let keychain = KeyChain::from_seed(&seed_bytes).unwrap();
        let origin_proof = derive_key(&seed_bytes[..PROOF_SIZE], "").unwrap();
        let proof_cipher = keychain.make_proof(&origin_proof, &options).unwrap();
        let proof = keychain.get_proof(&proof_cipher, &options).unwrap();

        assert_eq!(origin_proof, proof);
    }
}

================
File: cipher/src/lib.rs
================
pub mod aes;
pub mod argon2;
pub mod keychain;
pub mod ntrup;
pub mod options;

================
File: cipher/src/ntrup.rs
================
use config::sha::{SHA256_SIZE, SHA512_SIZE};
use ntrulp::{
    key::{priv_key::PrivKey, pub_key::PubKey},
    ntru,
    poly::{r3::R3, rq::Rq},
    rng::{random_small, short_random},
};
use rand::SeedableRng;
use rand_chacha::ChaChaRng;
use std::sync::Arc;
use zil_errors::ntru::NTRULPCipherErrors;

pub fn ntru_keys_from_seed(
    seed_bytes: &[u8; SHA512_SIZE],
) -> Result<(PubKey, PrivKey), NTRULPCipherErrors> {
    let seed_pq: [u8; SHA256_SIZE] = seed_bytes[..SHA256_SIZE]
        .try_into()
        .or(Err(NTRULPCipherErrors::InvalidSeedPQBytesSize))?;
    let mut pq_rng = ChaChaRng::from_seed(seed_pq);
    let f: Rq = Rq::from(short_random(&mut pq_rng).map_err(NTRULPCipherErrors::FailToInitF)?);

    let mut g: R3;
    let sk = loop {
        let r = random_small(&mut pq_rng);
        g = R3::from(r);

        match PrivKey::compute(&f, &g) {
            Ok(s) => break s,
            Err(_) => continue,
        };
    };
    let pk = PubKey::compute(&f, &g).map_err(NTRULPCipherErrors::ComputePubKeyError)?;

    Ok((pk, sk))
}

pub fn ntru_encrypt(pk: PubKey, plaintext: &[u8]) -> Result<Vec<u8>, NTRULPCipherErrors> {
    let mut pq_rng = ChaChaRng::from_entropy();

    ntru::std_cipher::bytes_encrypt(&mut pq_rng, plaintext, pk)
        .map_err(NTRULPCipherErrors::EncryptError)
}

pub fn ntru_decrypt(sk: PrivKey, ciphertext: Vec<u8>) -> Result<Vec<u8>, NTRULPCipherErrors> {
    let ciphertext = Arc::new(ciphertext);

    ntru::std_cipher::bytes_decrypt(&ciphertext, sk).map_err(NTRULPCipherErrors::DecryptError)
}

#[cfg(test)]
mod tests {
    use super::{ntru_keys_from_seed, SHA512_SIZE};
    use crate::ntrup::{ntru_decrypt, ntru_encrypt};
    use rand::RngCore;

    #[test]
    fn test_encrypt_and_decrypt() {
        let mut rng = rand::thread_rng();
        let mut password = [0u8; 2000];
        let mut plaintext = vec![0u8; 255];
        let mut seed = [0u8; SHA512_SIZE];

        rng.fill_bytes(&mut password);
        rng.fill_bytes(&mut seed);
        rng.fill_bytes(&mut plaintext);

        let (pk, sk) = ntru_keys_from_seed(&seed).unwrap();
        let ciphertext = ntru_encrypt(pk, &plaintext).unwrap();
        let res = ntru_decrypt(sk, ciphertext).unwrap();

        assert_eq!(res, plaintext);
    }
}

================
File: cipher/src/options.rs
================
use bincode::{FromBytes, ToVecBytes};
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::str::FromStr;
use zil_errors::cipher::CipherErrors;

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum CipherOrders {
    AESGCM256,
    NTRUP1277,
}

impl CipherOrders {
    pub fn from_code(code: u8) -> Result<Self, CipherErrors> {
        match code {
            0 => Ok(CipherOrders::AESGCM256),
            1 => Ok(CipherOrders::NTRUP1277),
            _ => Err(CipherErrors::InvalidTypeCode),
        }
    }

    pub fn code(&self) -> u8 {
        match self {
            CipherOrders::AESGCM256 => 0,
            CipherOrders::NTRUP1277 => 1,
        }
    }
}

impl ToVecBytes for CipherOrders {
    fn to_bytes(&self) -> Vec<u8> {
        vec![self.code()]
    }
}

impl FromBytes for CipherOrders {
    type Error = CipherErrors;
    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Result<Self, Self::Error> {
        Self::from_code(bytes[0])
    }
}

impl std::fmt::Display for CipherOrders {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let hex_str = hex::encode(self.to_bytes());
        write!(f, "{}", hex_str)
    }
}

impl FromStr for CipherOrders {
    type Err = CipherErrors;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let bytes = hex::decode(s).or(Err(CipherErrors::InvalidTypeCode))?;

        Self::from_code(bytes[0])
    }
}

impl Serialize for CipherOrders {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'de> Deserialize<'de> for CipherOrders {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        CipherOrders::from_str(&s).map_err(serde::de::Error::custom)
    }
}

#[cfg(test)]
mod tests_cipher_orders {
    use super::*;

    #[test]
    fn test_ser() {
        let origin_order_ntru = CipherOrders::NTRUP1277;
        let origin_order_aes = CipherOrders::AESGCM256;

        let bytes_ntru = origin_order_ntru.to_bytes();
        let bytes_aes = origin_order_aes.to_bytes();

        let res_ntru = CipherOrders::from_bytes(bytes_ntru.into()).unwrap();
        let res_aes = CipherOrders::from_bytes(bytes_aes.into()).unwrap();

        assert_eq!(res_ntru, origin_order_ntru);
        assert_eq!(res_aes, origin_order_aes);

        let hex_ntru = origin_order_ntru.to_string();
        let hex_aes = origin_order_aes.to_string();

        let res_ntru = CipherOrders::from_str(&hex_ntru).unwrap();
        let res_aes = CipherOrders::from_str(&hex_aes).unwrap();

        assert_eq!(res_ntru, origin_order_ntru);
        assert_eq!(res_aes, origin_order_aes);
    }

    #[test]
    fn test_convert_invalid() {
        let invalid_bytes = vec![3];
        let res_ntru = CipherOrders::from_bytes(invalid_bytes.into());

        assert_eq!(res_ntru, Err(CipherErrors::InvalidTypeCode));

        let invalid_hex = "FF";

        let res_aes = CipherOrders::from_str(invalid_hex);

        assert_eq!(res_aes, Err(CipherErrors::InvalidTypeCode));
    }
}

================
File: cipher/Cargo.toml
================
[package]
name = "cipher"
version = "0.1.0"
edition = "2021"

[dependencies]
zil_errors = { path = "../zil_errors" }
bincode = { path = "../bincode" }
config = { path = "../config" }
ntrulp = { version = "0.2.3", features = ["ntrup761", "std"] }
tokio = { version = "1.39.2", features = ["full", "test-util"] }
aes-gcm = "0.10.3"
argon2 = "0.5.3"
rand_chacha = "0.3.1"
rand = "0.8.5"
hex = "0.4.3"
serde = { version = "1.0.204", features = ["derive"] }

================
File: config/src/abi.rs
================
pub const ERC20_ABI: &str = r#"[
    {
        "constant": true,
        "inputs": [],
        "name": "name",
        "outputs": [
            {
                "name": "",
                "type": "string"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "symbol",
        "outputs": [
            {
                "name": "",
                "type": "string"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {
                "name": "_owner",
                "type": "address"
            }
        ],
        "name": "balanceOf",
        "outputs": [
            {
                "name": "balance",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "decimals",
        "outputs": [
            {
                "name": "",
                "type": "uint8"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
]"#;

================
File: config/src/address.rs
================
pub const HRP: &str = "zil";
pub const ADDR_LEN: usize = 20;
pub const BTC_ADDR_SIZE: usize = 25;

================
File: config/src/argon.rs
================
pub const KEY_SIZE: usize = 64;
pub const WALLET_SALT: &[u8] = b"ZILPAY:54040c2f-1ec1-4eb1-9595-6e4294d14fd6";
pub const SESSION_SALT: &str = "ZILPAY:SESSION:e6804105-619e-4971-a8c7-5bf2a3dddd20";
pub const LEDGER_SALT: &str = "LEDGER:344d16ed-3d31-460e-85da-20e14ef1cb5a";

================
File: config/src/cipher.rs
================
pub const PROOF_SIZE: usize = 8;
pub const PROOF_SALT: &str = "ZILPAY:PROOF:SALT:1e3283a9-a3be-4416-aada-67cbc9831f7e";

================
File: config/src/contracts.rs
================
pub const STAKEING: &str = "a7C67D49C82c7dc1B73D231640B2e4d0661D37c1";

================
File: config/src/key.rs
================
pub const PUB_KEY_SIZE: usize = 33;
pub const SECRET_KEY_SIZE: usize = 32;
pub const BIP39_SEED_SIZE: usize = 64;

================
File: config/src/lib.rs
================
pub const ZIL_MAIN_SCILLA_URL: &str = "https://api.zilliqa.com";
pub const PROTO_TESTNET: &str = "https://api.zq2-prototestnet.zilliqa.com/";
pub const SYS_SIZE: usize = std::mem::size_of::<usize>();

pub mod abi;
pub mod address;
pub mod argon;
pub mod cipher;
pub mod contracts;
pub mod key;
pub mod sha;
pub mod storage;
pub mod wallet;

================
File: config/src/sha.rs
================
pub const SHA512_SIZE: usize = 64;
pub const SHA256_SIZE: usize = SHA512_SIZE / 2;
pub const ECDSAS_ECP256K1_KECCAK256_SIZE: usize = 65;

================
File: config/src/storage.rs
================
pub const STORAGE_VERSION: u16 = 0;
pub const INDICATORS_DB_KEY: &[u8] = b"address_indicators";
pub const FTOKENS_DB_KEY: &[u8] = b"f_tokens";
pub const NETWORK_DB_KEY: &[u8] = b"network_db_key";

================
File: config/src/wallet.rs
================
pub const N_BYTES_HASH: usize = 6;
pub const N_SALT: [u8; 26] = [
    167, 36, 156, 3, 14, 212, 191, 102, 69, 11, 214, 43, 181, 138, 7, 21, 241, 122, 104, 60, 132,
    106, 5, 135, 186, 182,
];

================
File: config/Cargo.toml
================
[package]
name = "config"
version = "0.1.0"
edition = "2021"

[dependencies]

================
File: crypto/src/bip49.rs
================
#[derive(Debug)]
pub enum Bip49DerivationPath {
    Zilliqa(usize),
    Ethereum(usize),
}

impl<'a> Bip49DerivationPath {
    pub const ZIL_PATH: &'a str = "m/44'/313'/0'/0/";
    pub const ETH_PATH: &'a str = "m/44'/60'/0'/0/";

    pub fn get_path(&self) -> String {
        match self {
            Bip49DerivationPath::Zilliqa(index) => format!("{}{}", Self::ZIL_PATH, index),
            Bip49DerivationPath::Ethereum(index) => format!("{}{}", Self::ETH_PATH, index),
        }
    }

    pub fn get_index(&self) -> usize {
        match self {
            Bip49DerivationPath::Zilliqa(i) => *i,
            Bip49DerivationPath::Ethereum(i) => *i,
        }
    }
}

================
File: crypto/src/lib.rs
================
pub mod bip49;
pub mod schnorr;

================
File: crypto/src/schnorr.rs
================
pub use k256::{ecdsa::Signature, PublicKey, SecretKey};
use k256::{
    elliptic_curve::{ops::Reduce, sec1::ToEncodedPoint, Group, PrimeField},
    AffinePoint, FieldBytes, Scalar, U256,
};
use rand::{RngCore, SeedableRng};
use rand_chacha::ChaCha20Rng;
use sha2::{Digest, Sha256};
use zil_errors::crypto::SchorrError;

pub const MAX_TRY_SIGN: usize = 100_000_000;

pub fn sign(message: &[u8], secret_key: &SecretKey) -> Result<Signature, SchorrError> {
    let mut rng = ChaCha20Rng::from_entropy();
    let safe_counter: usize = 0;

    loop {
        if safe_counter >= MAX_TRY_SIGN {
            return Err(SchorrError::InvalidSignTry);
        }

        let mut k_bytes = FieldBytes::default();
        rng.fill_bytes(&mut k_bytes);

        if let Some(scalar) = Scalar::from_repr(k_bytes).into() {
            if let Some(signature) = sign_inner(scalar, message, secret_key) {
                return Ok(signature);
            }
        }
    }
}

pub fn sign_inner(k: Scalar, message: &[u8], secret_key: &SecretKey) -> Option<Signature> {
    let public_key = secret_key.public_key();

    // 2. Compute the commitment Q = kG, where G is the base point.
    let q = AffinePoint::GENERATOR * k;

    // 3. Compute the challenge r = H(Q, kpub, m)
    let mut hasher = Sha256::new();
    hasher.update(q.to_encoded_point(true).to_bytes());
    hasher.update(public_key.to_encoded_point(true).to_bytes());
    hasher.update(message);
    let r = <Scalar as Reduce<U256>>::reduce_bytes(&hasher.finalize());

    // 4. If r = 0 mod(order), goto 1
    if r.is_zero().into() {
        return None;
    }

    // 5. Compute s = k - r*kpriv mod(order)
    let s: Scalar = k - r.mul(&secret_key.as_scalar_primitive().into());

    // 6. If s = 0 goto 1.
    if s.is_zero().into() {
        return None;
    }

    // 7. Signature on m is (r, s)
    Signature::from_scalars(r.to_bytes(), s.to_bytes()).ok()
}

pub fn verify(message: &[u8], public_key: PublicKey, signature: Signature) -> Option<()> {
    let (r, s) = signature.split_scalars();

    // 2. Compute Q = sG + r*kpub
    let q = (AffinePoint::GENERATOR * *s) + (*public_key.as_affine() * *r);

    // 3. If Q = 0 (the neutral point), return 0;
    if q.is_identity().into() {
        return None;
    }

    // 4. r' = H(Q, kpub, m)
    let mut hasher = Sha256::new();
    hasher.update(q.to_encoded_point(true).to_bytes());
    hasher.update(public_key.to_encoded_point(true).to_bytes());
    hasher.update(message);
    let r_dash = <Scalar as Reduce<U256>>::reduce_bytes(&hasher.finalize());

    // 5. Return r' == r
    if r_dash != *r {
        return None;
    }

    Some(())
}

#[cfg(test)]
mod tests {
    use k256::{elliptic_curve::PrimeField, FieldBytes, PublicKey, Scalar, SecretKey};

    use super::{sign_inner, verify};

    #[test]
    fn signing() {
        let cases = [
            (
                "A7F1D92A82C8D8FE434D98558CE2B347171198542F112D0558F56BD68807999248336241F30D23E55F30D1C8ED610C4B0235398184B814A29CB45A672ACAE548E9C5F1B0C4158AE59B4D39F6F7E8A105D3FEEDA5D5F3D9E45BFA6CC351E220AE0CE106986D61FF34A11E19FD3650E9B7818FC33A1E0FC02C44557AC8AB50C9B2DEB2F6B5E24C4FDD9F8867BDCE1FF261008E7897970E346207D75E47A158298E5BA2F56246869CC42E362A02731264E60687EF5309D108534F51F8658FB4F080B7CB19EE9AEBD718CC4FA27C8C37DFC1ADA5D133D13ABE03F021E9B1B78CCBD82F7FF2B38C6D48D01E481B2D4FAF7171805FD7F2D39EF4C4F19B9496E81DAB8193B3737E1B27D9C43957166441B93515E8F03C95D8E8CE1E1864FAAD68DDFC5932130109390B0F1FE5CA716805F8362E98DCCAADC86ADBED25801A9A9DCFA6264319DDAFE83A89C51F3C6D199D38DE10E660C37BE872C3F2B31660DE8BC95902B9103262CDB941F77376F5D3DBB7A3D5A387797FC4819A035ECA704CEDB37110EE7F206B0C8805AAEBF4963E7C4708CE8D4E092366E71792A8A3B2BBCDEE321B3E15380C541EF0930888969F7457AFE18588826A419D58311C1784B5484EECDB393F6A0ACA11B91DF0866B500B8DEE501FD7EB9BCE09A17D74124B4605ADFC0777BED9816D8D7E8488544A18D8045CB3283B0A752B881B5F500FADB59010E63D",
                "039E43C9810E6CC09F46AAD38E716DAE3191629534967DC457D3A687D2E2CDDC6A",
                "0F494B8312E8D257E51730C78F8FE3B47B6840C59AAAEC7C2EBE404A2DE8B25A",
                "532B2267C4A3054F380B3357339BDFB379E88366FE61B42ACA05F69BC3F6F54E",
                "3AF3D288E830E96FF8ED0769F45ABDA774CD989E2AE32EF9E985C8505F14FF98",
                "E191EB14A70B5B53ADA45AFFF4A04578F5D8BB2B1C8A22985EA159B53826CDE7",
            ),
            (
                "1B664F8BDA2DBF33CB6BE21C8EB3ECA9D9D5BF144C08E9577ED0D1E5E560875109B340980580473DBC2E689A3BE838E77A0A3348FE960EC9BF81DA36F1868CA5D24788FA4C0C778BF0D12314285495636516CF40861B3D737FD35DBB591C5B5D25916EB1D86176B14E0E67D2D03957F0CF6C87834BF328540588360BA7C7C5F88541634FB7BADE5F94FF671D1FEBDCBDA116D2DA779038ED7679896C29198B2657B58C50EA054F644F4129C8BA8D8D544B727633DD40754398046796E038626FEF9237CE5B615BC08677EE5ABFBD85F73F7F8868CB1B5FBA4C1309F16061AA133821FBE2A758D2BBE6AA040A940D41B7D3B869CEE945150AA4A40E6FF719EEC24B2681CD5CE06B50273436584066046656D5EFED7315759189D68815DDB9E5F8D7FD53B6EC096616A773B9421F6704CED36EF4E484BA0C6C5A4855C71C33A54AC82BE803E5CFD175779FC444B7E6AA9001EEFABEBC0CF99754887C7B0A27AFDDC415F8A02C5AF1EFEA26AD1E5D92B1E29A8FAF5B2186C3094F4A137BCFAA65D7B274214DB64C86F3085B24938E1832FB310A6F064181E298D23062ABC817BA173023C8C04C5C3A1ECBF4AF72372B381FF69865C8F0E3C70B931C45A7419B3C441842EBFACC3D070AC3B433CD120B6E85B72DADCF40B23B173C34F6BE1B1901F6621F1497B085CF8E999D986EF8FF3A889A0238979983A8686F69E10EF9249A87",
                "0245DC2911EDC02F2774E0A40FBEB0112EA60BF513F9EC50889D59FC94C97EC18F",
                "8D566BB87EF69FFDA622E0A59FBAAFE57F486CE65844343A5D9B97DE9C4F619A",
                "948AFFFF6E068CA2F2757BFD6085D6E4C3084B038E5533C5927ECB19EA0D329C",
                "DFEE66E2C4799E73F0F778126A23032608408C27C2E7B3FA45A626BB9BDEB53C",
                "75445CC9DBFE4E7BC64E020FA22CACFA4C40D5AA84DD6AEF661564FCA9746C40",
            ),
            (
                "3444C8501F19A8A78670F748FA401C4020AE086D7157A3837EC721DEF0D6E095928C5B78ED9B95560CE33D5B22778BE66DCEF2D21878D481DFF41A4DEDCAFDCAEAB4BD78629D7EC40FD26F1DD954CA84A3B53B84E9903056E840837A1390F37BB8ADE799DAC1E465D811916547EB4B6A163082E9833634A1224C54F681B8DC70A792C0CB4671D4970CCC80E2168CE920CC8FA07B1F90E9898D16019913ED5B8EE8A8DE7AB6F7895601FD20E49FD73E6F5D24C0D97E67871539F0E4E32CCB6677AFF03356D1F3790945E94039E51A63B3C840B74E3053D95CA71C0D3AC20A9065828D30AB5BFB6188A8F291FB1EB4E1EED03E2F5F558C00D8E3084120DEEB8BFE908429B36A896A45D624E79372CC18DF37DB2D20C9726D4FEF7BECF220138B53BC54C2DA461A9955AFF33F2F93DD96464BF3E883FC5750BDBE79BC2F82427F41DE42659AC4B111D7CEF8085003469DF8C9D3541480C6841707CE4C8F3D003AF982AD35C2733D0FA3B1EE52A6DAB36203D99AEC179A565B5050F480235C3BC560AA28EF5DD5525BFA254E584A86FDBD4BCC5B56551BAD00255CB72F806D7F3C533321B0864007AFBA4E0FF9638517FA8D788F52766F3A28C57C428BFDD4234AA760CE8044DF1E1FBA58E8B1D9C5A79D2AC4592FC31702F7E83351D2160C09C5CEA554F2C93A61C040E225612DF2B550900B097E18638350E3BA15C9AD53CE1861",
                "02237627FE7374061FBD80AEA842DCE76D9206F0DDC7B319F3B30FA75DBD4F009A",
                "009755F442D66585A10B80A49850C77764AD029D1BEA73F4DA45AB331306E6E5",
                "2D78C77B736AD0A00FDF60695C01E96520656C13DC890A5B864672C6CED1C49A",
                "4B73D4D919D7B4DEF330391899EA02023851CABE044E34E18EAE3E10588CECCD",
                "D5DE85C4BDEA5910DC36AEF5660774D65291322C1E87FDA0D00C864E8C5FED29",
            ),
        ];

        for (message, public_key, secret_key, k, r, s) in cases {
            let k =
                Scalar::from_repr(FieldBytes::clone_from_slice(&hex::decode(k).unwrap())).unwrap();
            let message = hex::decode(message).unwrap();
            let secret_key = SecretKey::from_slice(&hex::decode(secret_key).unwrap()).unwrap();
            let public_key = PublicKey::from_sec1_bytes(&hex::decode(public_key).unwrap()).unwrap();

            let signature = sign_inner(k, &message, &secret_key).unwrap();

            assert_eq!(signature.r().to_string(), r);
            assert_eq!(signature.s().to_string(), s);

            assert!(verify(&message, public_key, signature).is_some());
        }
    }
}

================
File: crypto/Cargo.toml
================
[package]
name = "crypto"
version = "0.1.0"
edition = "2021"

[dependencies]
zil_errors = { path = "../zil_errors" }
config = { path = "../config" }
hex = "0.4.3"
k256 = "0.13.3"
sha2 = "0.10.8"
rand_chacha = "0.3.1"
rand = "0.8.5"
bip39 = "2.0.0"

================
File: network/src/lib.rs
================
pub mod provider;
pub mod token;

================
File: network/src/provider.rs
================
use proto::address::Address;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;
use wallet::ft::FToken;
use zil_errors::network::NetworkErrors;
use zilliqa::json_rpc::{zil::ZilliqaJsonRPC, zil_interfaces::ResultRes};

use crate::token::{
    build_token_requests, process_eth_balance_response, process_eth_metadata_response,
    process_zil_balance_response, process_zil_metadata_response, MetadataField, RequestType,
};

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
pub enum NetworkProvider {
    Zilliqa(ZilliqaJsonRPC),
    Ethereum,
}

impl NetworkProvider {
    pub fn new_vec() -> Vec<Self> {
        let zil_rpc = ZilliqaJsonRPC::new();

        vec![NetworkProvider::Zilliqa(zil_rpc), NetworkProvider::Ethereum]
    }

    pub async fn update_nodes(&mut self) -> Result<(), NetworkErrors> {
        match self {
            NetworkProvider::Zilliqa(zil) => {
                zil.update_scilla_nodes()
                    .await
                    .map_err(NetworkErrors::FetchNodes)?;
            }
            NetworkProvider::Ethereum => {
                unreachable!()
            }
        };

        Ok(())
    }

    pub async fn get_ftoken_meta(
        &self,
        contract: &Address,
        accounts: &[Address],
    ) -> Result<FToken, NetworkErrors> {
        match self {
            NetworkProvider::Ethereum => {
                unreachable!()
            }
            NetworkProvider::Zilliqa(zil) => {
                let requests = build_token_requests(contract, accounts, false)?;
                let responses = zil
                    .req::<Vec<ResultRes<Value>>>(
                        &requests
                            .iter()
                            .map(|(req, _)| req.clone())
                            .collect::<Vec<_>>(),
                    )
                    .await
                    .map_err(NetworkErrors::Request)?;

                match contract {
                    Address::Secp256k1Sha256Zilliqa(_) => {
                        let (name, symbol, decimals) = process_zil_metadata_response(
                            responses[0]
                                .result
                                .as_ref()
                                .ok_or(NetworkErrors::InvalidContractInit)?,
                        )?;

                        let mut balances = HashMap::new();
                        for (i, (_, req_type)) in requests.iter().enumerate().skip(1) {
                            if let RequestType::Balance(account) = req_type {
                                let balance =
                                    process_zil_balance_response(&responses[i], account, false)?;
                                balances.insert(account.clone(), balance);
                            }
                        }

                        Ok(FToken {
                            balances,
                            name,
                            symbol,
                            decimals,
                            addr: contract.clone(),
                            logo: None,
                            default: false,
                            native: false,
                        })
                    }
                    Address::Secp256k1Keccak256Ethereum(_) => {
                        let mut metadata_iter = responses.iter();
                        let name = process_eth_metadata_response(
                            metadata_iter
                                .next()
                                .ok_or(NetworkErrors::InvalidContractInit)?,
                            &MetadataField::Name,
                        )?;
                        let symbol = process_eth_metadata_response(
                            metadata_iter
                                .next()
                                .ok_or(NetworkErrors::InvalidContractInit)?,
                            &MetadataField::Symbol,
                        )?;
                        let decimals: u8 = process_eth_metadata_response(
                            metadata_iter
                                .next()
                                .ok_or(NetworkErrors::InvalidContractInit)?,
                            &MetadataField::Decimals,
                        )?
                        .parse()
                        .map_err(|_| NetworkErrors::InvalidContractInit)?;

                        let mut balances = HashMap::new();
                        for ((_, req_type), response) in
                            requests.iter().zip(responses.iter()).skip(3)
                        {
                            if let RequestType::Balance(account) = req_type {
                                let balance = process_eth_balance_response(response)?;
                                balances.insert(account.clone(), balance);
                            }
                        }

                        Ok(FToken {
                            balances,
                            name,
                            symbol,
                            decimals,
                            addr: contract.clone(),
                            logo: None,
                            default: false,
                            native: false,
                        })
                    }
                }
            }
        }
    }

    pub async fn get_tokens_balances(
        &self,
        tokens: &mut [FToken],
        accounts: &[Address],
    ) -> Result<(), NetworkErrors> {
        match self {
            NetworkProvider::Ethereum => {
                unreachable!()
            }
            NetworkProvider::Zilliqa(zil) => {
                let mut all_requests = Vec::new();
                let mut request_mapping = Vec::new();

                for (token_idx, token) in tokens.iter().enumerate() {
                    let requests = build_token_requests(&token.addr, accounts, token.native)?;

                    for (req, req_type) in requests {
                        if let RequestType::Balance(account) = req_type {
                            request_mapping.push((token_idx, account));
                            all_requests.push(req);
                        }
                    }
                }

                if !all_requests.is_empty() {
                    let responses = zil
                        .req::<Vec<ResultRes<Value>>>(&all_requests)
                        .await
                        .map_err(NetworkErrors::Request)?;

                    for ((token_idx, account), response) in
                        request_mapping.iter().zip(responses.iter())
                    {
                        match tokens[*token_idx].addr {
                            Address::Secp256k1Sha256Zilliqa(_) => {
                                let balance = process_zil_balance_response(
                                    response,
                                    account,
                                    tokens[*token_idx].native,
                                )?;
                                tokens[*token_idx].balances.insert(account.clone(), balance);
                            }
                            Address::Secp256k1Keccak256Ethereum(_) => {
                                let balance = process_eth_balance_response(response)?;
                                tokens[*token_idx].balances.insert(account.clone(), balance);
                            }
                        }
                    }
                }

                Ok(())
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use alloy::primitives::U256;
    use config::{address::ADDR_LEN, ZIL_MAIN_SCILLA_URL};
    use tokio;

    #[tokio::test]
    async fn test_get_ftoken_meta() {
        let zil = ZilliqaJsonRPC::from_vec(vec![ZIL_MAIN_SCILLA_URL.to_string()], 0);
        let net = NetworkProvider::Zilliqa(zil);
        let token_addr =
            Address::from_zil_bech32("zil1l0g8u6f9g0fsvjuu74ctyla2hltefrdyt7k5f4").unwrap();
        let account = [
            Address::from_zil_bech32("zil1gmk7xpsyxthczk202a0yavhxk56mqch0ghl02f").unwrap(),
            Address::from_zil_bech32("zil1wl38cwww2u3g8wzgutxlxtxwwc0rf7jf27zace").unwrap(),
            Address::from_zil_bech32("zil12nfykegk3gtatvc50yratrahxt662sr3yhy8c2").unwrap(),
            Address::Secp256k1Sha256Zilliqa([0u8; ADDR_LEN]),
        ];
        let ftoken = net.get_ftoken_meta(&token_addr, &account).await.unwrap();

        assert!(*ftoken.balances.get(&account[0]).unwrap() > U256::from(0));
        assert!(*ftoken.balances.get(&account[1]).unwrap() > U256::from(0));
        assert!(*ftoken.balances.get(&account[2]).unwrap() == U256::from(0));
        assert!(*ftoken.balances.get(&account[3]).unwrap() == U256::from(0));

        assert_eq!(&ftoken.name, "ZilPay wallet");
        assert_eq!(&ftoken.symbol, "ZLP");
        assert_eq!(ftoken.decimals, 18u8);
    }

    #[tokio::test]
    async fn test_fetch_accounts_tokens_balances() {
        let zil = ZilliqaJsonRPC::from_vec(vec![ZIL_MAIN_SCILLA_URL.to_string()], 0);
        let net = NetworkProvider::Zilliqa(zil);
        // Add multiple custom tokens
        let mut tokens = vec![
            FToken::zil(),
            FToken {
                name: "ZilPay token".to_string(),
                symbol: "ZLP".to_string(),
                decimals: 18,
                addr: Address::from_zil_bech32("zil1l0g8u6f9g0fsvjuu74ctyla2hltefrdyt7k5f4")
                    .unwrap(),
                native: false,
                logo: None,
                default: false,
                balances: HashMap::new(),
            },
            FToken {
                name: "DMZ".to_string(),
                symbol: "DMZ".to_string(),
                decimals: 18,
                addr: Address::from_zil_bech32("zil19lr3vlpm4lufu2q94mmjvdkvmx8wdwajuntzx2")
                    .unwrap(),
                native: false,
                logo: None,
                default: false,
                balances: HashMap::new(),
            },
            FToken {
                name: "RedChillies".to_string(),
                symbol: "REDC".to_string(),
                decimals: 9,
                native: false,
                addr: Address::from_zil_bech32("zil14jmjrkvfcz2uvj3y69kl6gas34ecuf2j5ggmye")
                    .unwrap(),
                logo: None,
                default: false,
                balances: HashMap::new(),
            },
        ];
        let accounts = [
            Address::from_zil_bech32("zil1gmk7xpsyxthczk202a0yavhxk56mqch0ghl02f").unwrap(),
            Address::from_zil_bech32("zil1wl38cwww2u3g8wzgutxlxtxwwc0rf7jf27zace").unwrap(),
            Address::from_zil_bech32("zil12nfykegk3gtatvc50yratrahxt662sr3yhy8c2").unwrap(),
        ];

        net.get_tokens_balances(&mut tokens, &accounts)
            .await
            .unwrap();

        assert!(&tokens[0].balances.contains_key(&accounts[0]));
        assert!(&tokens[0].balances.contains_key(&accounts[1]));
        assert!(&tokens[0].balances.contains_key(&accounts[2]));

        assert!(&tokens[1].balances.contains_key(&accounts[0]));
        assert!(&tokens[1].balances.contains_key(&accounts[1]));
        assert!(&tokens[1].balances.contains_key(&accounts[2]));

        assert!(&tokens[2].balances.contains_key(&accounts[0]));
        assert!(&tokens[2].balances.contains_key(&accounts[1]));
        assert!(&tokens[2].balances.contains_key(&accounts[2]));
    }

    #[tokio::test]
    async fn test_fetch_eth_tokens() {
        let mut zil = ZilliqaJsonRPC::new();

        zil.selected = 1; // testnet

        let net = NetworkProvider::Zilliqa(zil);
        // Add multiple custom tokens
        let mut tokens = vec![
            FToken::eth(),
            FToken {
                name: "MyToken".to_string(),
                symbol: "MTK".to_string(),
                decimals: 18,
                native: false,
                addr: Address::from_eth_address("0xf06686B5Eb5cAe38c09f12412B729045647E74e3")
                    .unwrap(),
                logo: None,
                default: false,
                balances: HashMap::new(),
            },
        ];
        let accounts = [
            Address::from_eth_address("0x7aa13D6AE95fb8E843d3bCC2eea365F71c3bACbe").unwrap(),
            Address::from_eth_address("0x4d9DF80AD454fFE924f98321bF7280Fd3705BD85").unwrap(),
        ];

        net.get_tokens_balances(&mut tokens, &accounts)
            .await
            .unwrap();

        assert!(&tokens[0].balances.contains_key(&accounts[0]));
        assert!(&tokens[0].balances.contains_key(&accounts[1]));

        assert!(&tokens[1].balances.contains_key(&accounts[0]));
        assert!(&tokens[1].balances.contains_key(&accounts[1]));
    }

    #[tokio::test]
    async fn test_fetch_eth_meta_data() {
        let mut zil = ZilliqaJsonRPC::new();

        zil.selected = 1; // testnet

        let net = NetworkProvider::Zilliqa(zil);
        let token_addr =
            Address::from_eth_address("0x98767212b8D275905f7F8EB65D6355D0Fc67bf6f").unwrap();
        let account = [
            Address::from_eth_address("0x7aa13D6AE95fb8E843d3bCC2eea365F71c3bACbe").unwrap(),
            Address::from_eth_address("0x4d9DF80AD454fFE924f98321bF7280Fd3705BD85").unwrap(),
        ];

        let ftoken = net.get_ftoken_meta(&token_addr, &account).await.unwrap();

        assert_eq!(&ftoken.name, "MyToken");
        assert_eq!(&ftoken.symbol, "MTK");
        assert_eq!(ftoken.decimals, 18u8);

        assert!(*ftoken.balances.get(&account[0]).unwrap() > U256::from(0));
        assert!(*ftoken.balances.get(&account[1]).unwrap() == U256::from(0));
    }

    #[tokio::test]
    async fn test_fetch_evm_scilla_tokens() {
        let zil = ZilliqaJsonRPC::from_vec(vec![ZIL_MAIN_SCILLA_URL.to_string()], 0);
        let net = NetworkProvider::Zilliqa(zil);
        // Add multiple custom tokens
        let mut tokens = vec![
            FToken::zil(),
            FToken::eth(),
            // FToken {
            //     name: "ZilPay token".to_string(),
            //     symbol: "ZLP".to_string(),
            //     decimals: 18,
            //     addr: Address::from_zil_bech32("zil1l0g8u6f9g0fsvjuu74ctyla2hltefrdyt7k5f4")
            //         .unwrap(),
            //     native: false,
            //     logo: None,
            //     default: false,
            //     balances: HashMap::new(),
            // }, TODO: unlock it when zilliqa 2.0 support deploy contracts.
            FToken {
                name: "MyToken".to_string(),
                symbol: "MTK".to_string(),
                decimals: 18,
                native: false,
                addr: Address::from_eth_address("0xf06686B5Eb5cAe38c09f12412B729045647E74e3")
                    .unwrap(),
                logo: None,
                default: false,
                balances: HashMap::new(),
            },
        ];
        let accounts = [
            Address::from_zil_bech32("zil1gmk7xpsyxthczk202a0yavhxk56mqch0ghl02f").unwrap(),
            Address::from_zil_bech32("zil1wl38cwww2u3g8wzgutxlxtxwwc0rf7jf27zace").unwrap(),
            Address::from_zil_bech32("zil12nfykegk3gtatvc50yratrahxt662sr3yhy8c2").unwrap(),
            Address::from_eth_address("0x7aa13D6AE95fb8E843d3bCC2eea365F71c3bACbe").unwrap(),
            Address::from_eth_address("0x4d9DF80AD454fFE924f98321bF7280Fd3705BD85").unwrap(),
        ];

        net.get_tokens_balances(&mut tokens, &accounts)
            .await
            .unwrap();

        assert!(&tokens[0].balances.contains_key(&accounts[0]));
        assert!(&tokens[0].balances.contains_key(&accounts[1]));
        assert!(&tokens[0].balances.contains_key(&accounts[2]));
        assert!(&tokens[0].balances.contains_key(&accounts[3]));
        assert!(&tokens[0].balances.contains_key(&accounts[4]));

        assert!(&tokens[1].balances.contains_key(&accounts[0]));
        assert!(&tokens[1].balances.contains_key(&accounts[1]));
        assert!(&tokens[1].balances.contains_key(&accounts[2]));
        assert!(&tokens[1].balances.contains_key(&accounts[3]));
        assert!(&tokens[1].balances.contains_key(&accounts[4]));

        assert!(&tokens[2].balances.contains_key(&accounts[0]));
        assert!(&tokens[2].balances.contains_key(&accounts[1]));
        assert!(&tokens[2].balances.contains_key(&accounts[2]));
        assert!(&tokens[2].balances.contains_key(&accounts[3]));
        assert!(&tokens[2].balances.contains_key(&accounts[4]));
    }
}

================
File: network/src/token.rs
================
use alloy::{
    dyn_abi::{DynSolValue, FunctionExt, JsonAbiExt},
    json_abi::{Function, JsonAbi},
    primitives::U256,
};
use config::abi::ERC20_ABI;
use proto::address::Address;
use serde_json::{json, Value};
use zil_errors::network::NetworkErrors;
use zilliqa::json_rpc::{
    zil::ZilliqaJsonRPC,
    zil_interfaces::{GetTokenInitItem, ResultRes},
    zil_methods::ZilMethods,
};

trait ResponseValidator {
    fn validate(&self) -> Result<&Self, NetworkErrors>;
}

impl<T> ResponseValidator for ResultRes<T> {
    fn validate(&self) -> Result<&Self, NetworkErrors> {
        if let Some(error) = &self.error {
            let error_msg = format!(
                "JSON-RPC error (code: {}): {}{}",
                error.code,
                error.message,
                error
                    .data
                    .as_ref()
                    .map(|d| format!(", data: {}", d))
                    .unwrap_or_default()
            );
            Err(NetworkErrors::RPCError(error_msg))
        } else {
            Ok(self)
        }
    }
}

// Type alias for clarity
type RequestResult = Result<Vec<(Value, RequestType)>, NetworkErrors>;

#[derive(Debug)]
pub enum RequestType {
    Metadata(MetadataField),
    Balance(Address),
}

#[derive(Debug, Clone)]
pub enum MetadataField {
    Name,
    Symbol,
    Decimals,
}

impl std::fmt::Display for MetadataField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MetadataField::Name => write!(f, "name"),
            MetadataField::Symbol => write!(f, "symbol"),
            MetadataField::Decimals => write!(f, "decimals"),
        }
    }
}

// Helper struct to encapsulate ERC20 functionality
struct ERC20Helper {
    abi: JsonAbi,
}

impl ERC20Helper {
    fn new() -> Result<Self, NetworkErrors> {
        Ok(Self {
            abi: serde_json::from_str(ERC20_ABI).map_err(|e| {
                NetworkErrors::ABIError(format!("Failed to parse ERC20 ABI: {}", e))
            })?,
        })
    }

    fn get_function(&self, name: &str) -> Result<&Function, NetworkErrors> {
        self.abi
            .function(name)
            .and_then(|f| f.first())
            .ok_or_else(|| {
                NetworkErrors::ABIError(format!("Function {} not found or no overloads", name))
            })
    }

    fn encode_function_call(
        &self,
        name: &str,
        inputs: &[DynSolValue],
    ) -> Result<String, NetworkErrors> {
        let func = self.get_function(name)?;
        Ok(format!(
            "0x{}",
            hex::encode(
                &func
                    .abi_encode_input(inputs)
                    .map_err(|e| NetworkErrors::ABIError(e.to_string()))?
            )
        ))
    }
}

pub fn build_token_requests(
    contract: &Address,
    accounts: &[Address],
    native: bool,
) -> RequestResult {
    let mut requests = Vec::new();

    match contract {
        Address::Secp256k1Sha256Zilliqa(_) => {
            build_zil_requests(contract, accounts, native, &mut requests)?;
        }
        Address::Secp256k1Keccak256Ethereum(_) => {
            build_eth_requests(contract, accounts, native, &mut requests)?;
        }
    }

    Ok(requests)
}

fn build_zil_requests(
    contract: &Address,
    accounts: &[Address],
    native: bool,
    requests: &mut Vec<(Value, RequestType)>,
) -> Result<(), NetworkErrors> {
    let base16_contract = contract
        .get_zil_base16()
        .map_err(NetworkErrors::InvalidZilAddress)?;

    // Add metadata request
    requests.push((
        ZilliqaJsonRPC::build_payload(json!([base16_contract]), ZilMethods::GetSmartContractInit),
        RequestType::Metadata(MetadataField::Name),
    ));

    // Build balance requests
    for account in accounts {
        let base16_account = match &account {
            Address::Secp256k1Sha256Zilliqa(_) => &account
                .get_zil_check_sum_addr()
                .map_err(NetworkErrors::InvalidZilAddress)?
                .to_lowercase(),
            Address::Secp256k1Keccak256Ethereum(_) => &account
                .to_eth_checksummed()
                .map_err(NetworkErrors::InvalidETHAddress)?,
        };

        let request = if native {
            ZilliqaJsonRPC::build_payload(json!([base16_account]), ZilMethods::GetBalance)
        } else {
            ZilliqaJsonRPC::build_payload(
                json!([base16_contract, "balances", [base16_account]]),
                ZilMethods::GetSmartContractSubState,
            )
        };

        requests.push((request, RequestType::Balance(account.clone())));
    }

    Ok(())
}

fn build_eth_requests(
    contract: &Address,
    accounts: &[Address],
    native: bool,
    requests: &mut Vec<(Value, RequestType)>,
) -> Result<(), NetworkErrors> {
    let token_addr = contract
        .to_eth_checksummed()
        .map_err(NetworkErrors::InvalidETHAddress)?;
    let erc20 = ERC20Helper::new()?;

    // Create a closure for building ETH call payloads
    let build_eth_call = |data: String| -> Value {
        ZilliqaJsonRPC::build_payload(
            json!([{
                "to": &token_addr,
                "data": data
            }, "latest"]),
            ZilMethods::ETHCall,
        )
    };

    // Add metadata requests
    for field in [
        MetadataField::Name,
        MetadataField::Symbol,
        MetadataField::Decimals,
    ] {
        let data = erc20.encode_function_call(&field.to_string(), &[])?;
        requests.push((build_eth_call(data), RequestType::Metadata(field)));
    }

    // Build balance requests
    for account in accounts {
        let request = if native {
            let owner = account
                .to_eth_checksummed()
                .map_err(NetworkErrors::InvalidETHAddress)?;
            ZilliqaJsonRPC::build_payload(json!([owner, "latest"]), ZilMethods::ETHgetBalance)
        } else {
            let call_data = erc20.encode_function_call(
                "balanceOf",
                &[DynSolValue::Address(account.clone().to_alloy_addr())],
            )?;
            build_eth_call(call_data)
        };

        requests.push((request, RequestType::Balance(account.clone())));
    }

    Ok(())
}

pub fn process_eth_metadata_response(
    response: &ResultRes<Value>,
    field_type: &MetadataField,
) -> Result<String, NetworkErrors> {
    if let Some(error) = &response.error {
        return Err(NetworkErrors::RPCError(format!(
            "JSON-RPC error (code: {}): {}{}",
            error.code,
            error.message,
            error
                .data
                .as_ref()
                .map(|d| format!(", data: {}", d))
                .unwrap_or_default()
        )));
    }

    let erc20 = ERC20Helper::new()?;
    let func = erc20.get_function(&field_type.to_string())?;
    let hex_str = response
        .result
        .as_ref()
        .and_then(|r| r.as_str())
        .ok_or_else(|| NetworkErrors::ABIError("Invalid response format".to_string()))?;

    let bytes = hex::decode(hex_str.trim_start_matches("0x"))
        .map_err(|e| NetworkErrors::ABIError(format!("Failed to decode hex: {}", e)))?;

    let values = func
        .abi_decode_output(&bytes, false)
        .map_err(|e| NetworkErrors::ABIError(e.to_string()))?;

    let value = values
        .first()
        .ok_or_else(|| NetworkErrors::ABIError("No values decoded".to_string()))?;

    match field_type {
        MetadataField::Decimals => value
            .as_uint()
            .ok_or_else(|| NetworkErrors::ABIError("Invalid decimals format".to_string()))
            .map(|u| u.0.to_string()),
        _ => value
            .as_str()
            .ok_or_else(|| NetworkErrors::ABIError("Invalid string format".to_string()))
            .map(|s| s.to_string()),
    }
}

pub fn process_zil_metadata_response(
    init_res: &Value,
) -> Result<(String, String, u8), NetworkErrors> {
    let res_init: Vec<GetTokenInitItem> = init_res
        .as_array()
        .ok_or(NetworkErrors::InvalidContractInit)?
        .iter()
        .map(|v| v.try_into())
        .collect::<Result<_, _>>()
        .map_err(NetworkErrors::TokenParseError)?;

    let get_field = |field: &str| -> Result<String, NetworkErrors> {
        res_init
            .iter()
            .find(|v| v.vname == field)
            .map(|v| v.value.clone())
            .ok_or(NetworkErrors::InvalidContractInit)
    };

    let name = get_field(&MetadataField::Name.to_string())?;
    let symbol = get_field(&MetadataField::Symbol.to_string())?;
    let decimals = get_field(&MetadataField::Decimals.to_string())?
        .parse()
        .map_err(|_| NetworkErrors::InvalidContractInit)?;

    Ok((name, symbol, decimals))
}

pub fn process_eth_balance_response(response: &ResultRes<Value>) -> Result<U256, NetworkErrors> {
    let response = response.validate()?;

    response
        .result
        .as_ref()
        .and_then(|v| v.as_str())
        .ok_or_else(|| NetworkErrors::ABIError("Invalid response format".to_string()))?
        .parse()
        .map_err(|_| NetworkErrors::ABIError("Invalid balance format".to_string()))
}

pub fn process_zil_balance_response(
    response: &ResultRes<Value>,
    account: &Address,
    is_native: bool,
) -> Result<U256, NetworkErrors> {
    if response.error.is_some() {
        return Ok(U256::from(0));
    }

    if is_native {
        let balance = response
            .result
            .as_ref()
            .and_then(|v| v.get("balance"))
            .and_then(|v| v.as_str())
            .and_then(|v| v.parse::<U256>().ok())
            .unwrap_or_default();

        Ok(balance)
    } else {
        let base16_account = account
            .get_zil_check_sum_addr()
            .map_err(NetworkErrors::InvalidZilAddress)?
            .to_lowercase();

        let balance = response
            .result
            .as_ref()
            .and_then(|v| v.get("balances"))
            .and_then(|v| v.get(base16_account))
            .and_then(|v| v.as_str())
            .and_then(|v| v.parse::<U256>().ok())
            .unwrap_or_default();

        Ok(balance)
    }
}

#[cfg(test)]
mod ftoken_tests {
    use super::*;
    use config::address::ADDR_LEN;
    use serde_json::json;
    use zilliqa::json_rpc::zil_interfaces::ErrorRes;

    fn create_mock_eth_address() -> Address {
        Address::Secp256k1Keccak256Ethereum([0u8; ADDR_LEN])
    }

    fn create_mock_zil_address() -> Address {
        Address::from_zil_bech32("zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz").unwrap()
    }

    fn create_mock_error_response<T>(code: i16, message: &str) -> ResultRes<T> {
        ResultRes {
            id: 1,
            jsonrpc: "2.0".to_string(),
            result: None,
            error: Some(ErrorRes {
                code,
                message: message.to_string(),
                data: None,
            }),
        }
    }

    mod response_validator_tests {
        use super::*;

        #[test]
        fn test_validate_success() {
            let response: ResultRes<Value> = ResultRes {
                id: 1,
                jsonrpc: "2.0".to_string(),
                result: Some(json!("0x123")),
                error: None,
            };
            assert!(response.validate().is_ok());
        }

        #[test]
        fn test_validate_error() {
            let response = create_mock_error_response::<Value>(1, "Test error");
            let err = response.validate().unwrap_err();
            match err {
                NetworkErrors::RPCError(msg) => {
                    assert!(msg.contains("Test error"));
                    assert!(msg.contains("code: 1"));
                }
                _ => panic!("Expected RPCError"),
            }
        }
    }

    mod build_token_requests_tests {
        use super::*;

        #[test]
        fn test_build_eth_token_requests() {
            let contract = create_mock_eth_address();
            let accounts = vec![create_mock_eth_address()];
            let requests = build_token_requests(&contract, &accounts, false).unwrap();

            // Should have 4 requests: name, symbol, decimals, and balance
            assert_eq!(requests.len(), 4);

            // Verify metadata requests
            let metadata_requests: Vec<_> = requests
                .iter()
                .filter_map(|(_, req_type)| match req_type {
                    RequestType::Metadata(field) => Some(field),
                    _ => None,
                })
                .collect();
            assert_eq!(metadata_requests.len(), 3);

            // Verify balance request
            let balance_requests: Vec<_> = requests
                .iter()
                .filter_map(|(_, req_type)| match req_type {
                    RequestType::Balance(_) => Some(true),
                    _ => None,
                })
                .collect();
            assert_eq!(balance_requests.len(), 1);
        }

        #[test]
        fn test_build_zil_token_requests() {
            let contract = create_mock_zil_address();
            let accounts = vec![create_mock_zil_address()];
            let requests = build_token_requests(&contract, &accounts, false).unwrap();

            // Should have 2 requests: init (metadata) and balance
            assert_eq!(requests.len(), 2);
        }
    }

    mod process_eth_metadata_response_tests {
        use super::*;

        #[test]
        fn test_process_name_success() {
            let hex_string = "0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000047465737400000000000000000000000000000000000000000000000000000000";
            let response = ResultRes {
                id: 1,
                jsonrpc: "2.0".to_string(),
                result: Some(json!(hex_string)),
                error: None,
            };

            let result = process_eth_metadata_response(&response, &MetadataField::Name).unwrap();
            assert_eq!(result, "test");
        }

        #[test]
        fn test_process_decimals_success() {
            let hex_string = "0x0000000000000000000000000000000000000000000000000000000000000012"; // 18 in hex
            let response = ResultRes {
                id: 1,
                jsonrpc: "2.0".to_string(),
                result: Some(json!(hex_string)),
                error: None,
            };

            let result =
                process_eth_metadata_response(&response, &MetadataField::Decimals).unwrap();
            assert_eq!(result, "18");
        }

        #[test]
        fn test_process_rpc_error() {
            let response = create_mock_error_response::<Value>(1, "Test error");
            let result = process_eth_metadata_response(&response, &MetadataField::Name);
            assert!(matches!(result, Err(NetworkErrors::RPCError(_))));
        }
    }

    mod process_eth_balance_response_tests {
        use super::*;

        #[test]
        fn test_process_balance_success() {
            let response = ResultRes {
                id: 1,
                jsonrpc: "2.0".to_string(),
                result: Some(json!(
                    "0x0000000000000000000000000000000000000000000000000000000000000064"
                )), // 100 in hex
                error: None,
            };

            let balance = process_eth_balance_response(&response).unwrap();
            assert_eq!(balance, U256::from(100));
        }

        #[test]
        fn test_process_balance_invalid_format() {
            let response = ResultRes {
                id: 1,
                jsonrpc: "2.0".to_string(),
                result: Some(json!("invalid_hex")),
                error: None,
            };

            let result = process_eth_balance_response(&response);
            assert!(matches!(result, Err(NetworkErrors::ABIError(_))));
        }
    }

    mod process_zil_balance_response_tests {
        use super::*;

        #[test]
        fn test_process_native_balance_success() {
            let response = ResultRes {
                id: 1,
                jsonrpc: "2.0".to_string(),
                result: Some(json!({
                    "balance": "100"
                })),
                error: None,
            };

            let balance =
                process_zil_balance_response(&response, &create_mock_zil_address(), true).unwrap();
            assert_eq!(balance, U256::from(100));
        }

        #[test]
        fn test_process_token_balance_success() {
            let account = create_mock_zil_address();
            let base16_account = account.get_zil_check_sum_addr().unwrap().to_lowercase();

            let mut balances = serde_json::Map::new();
            balances.insert(base16_account, json!("200"));

            let response = ResultRes {
                id: 1,
                jsonrpc: "2.0".to_string(),
                result: Some(json!({
                    "balances": balances
                })),
                error: None,
            };

            let balance = process_zil_balance_response(&response, &account, false).unwrap();
            assert_eq!(balance, U256::from(200));
        }
    }

    mod process_zil_metadata_response_tests {
        use super::*;

        #[test]
        fn test_process_metadata_success() {
            let init_data = json!([
                {
                    "vname": "name",
                    "type": "String",
                    "value": "Test Token"
                },
                {
                    "vname": "symbol",
                    "type": "String",
                    "value": "TEST"
                },
                {
                    "vname": "decimals",
                    "value": "18",
                    "type": "Uint32",
                }
            ]);

            let (name, symbol, decimals) = process_zil_metadata_response(&init_data).unwrap();
            assert_eq!(name, "Test Token");
            assert_eq!(symbol, "TEST");
            assert_eq!(decimals, 18);
        }

        #[test]
        fn test_process_metadata_missing_field() {
            let init_data = json!([
                {
                    "type": "String",
                    "vname": "name",
                    "value": "Test Token"
                }
            ]);

            let result = process_zil_metadata_response(&init_data);

            assert!(matches!(result, Err(NetworkErrors::InvalidContractInit)));
        }
    }
}

================
File: network/Cargo.toml
================
[package]
name = "network"
version = "0.1.0"
edition = "2021"

[dependencies]
zil_errors = { path = "../zil_errors" }
config = { path = "../config" }
wallet = { path = "../wallet" }
proto = { path = "../proto" }
zilliqa = { path = "../zilliqa" }
serde = { version = "1.0.204", features = ["derive", "rc"] }
hex = "0.4.3"
serde_json = "1.0.124"
tokio = { version = "1.39.2", features = ["full", "test-util"] }
alloy = { version = "0.4.2", features = ["full"] }

[dev-dependencies]
mockito = "1.5.0"

================
File: proto/src/address.rs
================
use crate::{
    pubkey::PubKey,
    zil_address::{
        from_zil_base16, from_zil_bech32_address, from_zil_pub_key, to_checksum_address,
        to_zil_bech32,
    },
};
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::hash::{Hash, Hasher};
use std::str::FromStr;

use config::address::ADDR_LEN;
use zil_errors::address::AddressError;

#[derive(Clone, PartialEq, Eq)]
pub enum Address {
    Secp256k1Sha256Zilliqa([u8; ADDR_LEN]),     // ZILLIQA
    Secp256k1Keccak256Ethereum([u8; ADDR_LEN]), // Ethereum
}

impl Address {
    pub fn from_zil_base16(addr: &str) -> Result<Self, AddressError> {
        let addr = from_zil_base16(addr).ok_or(AddressError::InvalidBase16Address)?;

        Ok(Self::Secp256k1Sha256Zilliqa(addr))
    }

    pub fn from_zil_bech32(addr: &str) -> Result<Self, AddressError> {
        let addr = from_zil_bech32_address(addr)?;
        Ok(Self::Secp256k1Sha256Zilliqa(addr))
    }

    pub fn from_eth_address(addr: &str) -> Result<Self, AddressError> {
        let addr = alloy::primitives::Address::from_str(addr)
            .map_err(|e| AddressError::InvalidETHAddress(e.to_string()))?;
        let bytes: [u8; ADDR_LEN] = addr
            .as_slice()
            .try_into()
            .map_err(|_| AddressError::InvalidETHAddress(String::new()))?;

        Ok(Self::Secp256k1Keccak256Ethereum(bytes))
    }

    pub fn to_alloy_addr(self) -> alloy::primitives::Address {
        alloy::primitives::Address::from_slice(self.as_ref())
    }

    pub fn to_eth_checksummed(&self) -> Result<String, AddressError> {
        let addr = alloy::primitives::Address::from_slice(self.as_ref());

        // TODO: check chain id;
        Ok(addr.to_checksum(None))
    }

    pub fn from_pubkey(pk: &PubKey) -> Result<Self, AddressError> {
        match pk {
            PubKey::Secp256k1Sha256Zilliqa(pk) => {
                let addr = from_zil_pub_key(pk)?;

                Ok(Self::Secp256k1Sha256Zilliqa(addr))
            }
            PubKey::Secp256k1Keccak256Ethereum(pk) => {
                let k256_pubkey = alloy::signers::k256::ecdsa::VerifyingKey::from_sec1_bytes(pk)
                    .map_err(|e| AddressError::InvalidVerifyingKey(e.to_string()))?;
                let addr = alloy::primitives::Address::from_public_key(&k256_pubkey);

                Ok(Self::Secp256k1Keccak256Ethereum(addr.into()))
            }
            PubKey::Secp256k1Bitcoin(_) => Err(AddressError::NotImpl),
            PubKey::Ed25519Solana(_) => Err(AddressError::NotImpl),
        }
    }

    pub fn to_bytes(&self) -> [u8; ADDR_LEN + 1] {
        let mut result = [0u8; ADDR_LEN + 1];
        result[0] = match self {
            Address::Secp256k1Sha256Zilliqa(_) => 0,
            Address::Secp256k1Keccak256Ethereum(_) => 1,
        };
        result[1..].copy_from_slice(self.as_ref());
        result
    }

    pub fn addr_bytes(&self) -> &[u8; ADDR_LEN] {
        match self {
            Address::Secp256k1Sha256Zilliqa(v) => v,
            Address::Secp256k1Keccak256Ethereum(v) => v,
        }
    }

    pub fn get_bech32(&self) -> Result<String, AddressError> {
        match self {
            Address::Secp256k1Sha256Zilliqa(v) => to_zil_bech32(v),
            _ => Err(AddressError::InvalidSecp256k1Sha256Type),
        }
    }

    pub fn get_zil_base16(&self) -> Result<String, AddressError> {
        match self {
            Address::Secp256k1Sha256Zilliqa(v) => {
                let addr = hex::encode(v);

                Ok(addr)
            }
            _ => Err(AddressError::InvalidSecp256k1Sha256Type),
        }
    }

    pub fn get_zil_check_sum_addr(&self) -> Result<String, AddressError> {
        match self {
            Address::Secp256k1Sha256Zilliqa(v) => {
                let addr = hex::encode(v);

                to_checksum_address(&addr)
            }
            _ => Err(AddressError::InvalidSecp256k1Sha256Type),
        }
    }
}

impl std::fmt::Display for Address {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Secp256k1Sha256Zilliqa(bytes) => {
                // unwrap shouldn't execpt
                write!(f, "{}", to_zil_bech32(bytes).unwrap())
            }
            Self::Secp256k1Keccak256Ethereum(bytes) => {
                let h = alloy::primitives::Address::from_slice(bytes);
                // TODO: chain id.
                write!(f, "{}", h.to_checksum(None))
            }
        }
    }
}

impl std::fmt::Debug for Address {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Secp256k1Sha256Zilliqa(bytes) => {
                // unwrap shouldn't execpt
                write!(f, "{}", to_zil_bech32(bytes).unwrap())
            }
            Self::Secp256k1Keccak256Ethereum(bytes) => {
                let h = alloy::primitives::Address::from_slice(bytes);
                // TODO: chain id.
                write!(f, "{}", h.to_checksum(None))
            }
        }
    }
}

impl Hash for Address {
    fn hash<H: Hasher>(&self, state: &mut H) {
        match self {
            Address::Secp256k1Sha256Zilliqa(_) => 0u8.hash(state),
            Address::Secp256k1Keccak256Ethereum(_) => 1u8.hash(state),
        }

        self.as_ref().hash(state);
    }
}

impl Serialize for Address {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let bytes = self.to_bytes();
        serializer.serialize_str(&hex::encode(bytes))
    }
}

impl<'de> Deserialize<'de> for Address {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        Address::from_str(&s).map_err(serde::de::Error::custom)
    }
}

impl FromStr for Address {
    type Err = AddressError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let data = hex::decode(s).map_err(|_| AddressError::InvalidHex)?;
        let bytes: [u8; ADDR_LEN] = data[1..]
            .try_into()
            .map_err(|_| AddressError::InvalidLength)?;
        let prefix = data[0];

        match prefix {
            0 => Ok(Address::Secp256k1Sha256Zilliqa(bytes)),
            1 => Ok(Address::Secp256k1Keccak256Ethereum(bytes)),
            _ => Err(AddressError::InvalidKeyType),
        }
    }
}

impl From<[u8; ADDR_LEN + 1]> for Address {
    fn from(bytes: [u8; ADDR_LEN + 1]) -> Self {
        let key_type = bytes[0];
        let key_data: [u8; ADDR_LEN] = bytes[1..].try_into().unwrap();

        match key_type {
            0 => Address::Secp256k1Sha256Zilliqa(key_data),
            1 => Address::Secp256k1Keccak256Ethereum(key_data),
            _ => panic!("Invalid key type"),
        }
    }
}

impl TryFrom<&[u8]> for Address {
    type Error = AddressError;

    fn try_from(slice: &[u8]) -> Result<Self, Self::Error> {
        if slice.len() != ADDR_LEN + 1 {
            return Err(AddressError::InvalidLength);
        }

        let key_type = slice[0];
        let key_data: [u8; ADDR_LEN] = slice[1..]
            .try_into()
            .map_err(|_| AddressError::InvalidLength)?;

        match key_type {
            0 => Ok(Address::Secp256k1Sha256Zilliqa(key_data)),
            1 => Ok(Address::Secp256k1Keccak256Ethereum(key_data)),
            _ => Err(AddressError::InvalidKeyType),
        }
    }
}

impl AsRef<[u8]> for Address {
    fn as_ref(&self) -> &[u8] {
        match self {
            Address::Secp256k1Sha256Zilliqa(data) => data,
            Address::Secp256k1Keccak256Ethereum(data) => data,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_address_creation() {
        let zil_data = [1u8; ADDR_LEN];
        let eth_data = [2u8; ADDR_LEN];

        let zil_addr = Address::Secp256k1Sha256Zilliqa(zil_data);
        let eth_addr = Address::Secp256k1Keccak256Ethereum(eth_data);

        assert_eq!(zil_addr.as_ref(), &zil_data);
        assert_eq!(eth_addr.as_ref(), &eth_data);
    }

    #[test]
    fn test_to_bytes() {
        let zil_data = [1u8; ADDR_LEN];
        let eth_data = [2u8; ADDR_LEN];

        let zil_addr = Address::Secp256k1Sha256Zilliqa(zil_data);
        let eth_addr = Address::Secp256k1Keccak256Ethereum(eth_data);

        let zil_bytes = zil_addr.to_bytes();
        let eth_bytes = eth_addr.to_bytes();

        assert_eq!(zil_bytes[0], 0);
        assert_eq!(eth_bytes[0], 1);
        assert_eq!(&zil_bytes[1..], &zil_data);
        assert_eq!(&eth_bytes[1..], &eth_data);
    }

    #[test]
    fn test_display() {
        let zil_data = [1u8; ADDR_LEN];
        let zil_addr = Address::Secp256k1Sha256Zilliqa(zil_data);

        let expected = to_zil_bech32(&zil_data).unwrap();
        assert_eq!(zil_addr.to_string(), expected);
    }

    #[test]
    fn test_from_bytes() {
        let mut zil_bytes = [0u8; ADDR_LEN + 1];
        zil_bytes[0] = 0;
        zil_bytes[1..].fill(1);

        let addr = Address::from(zil_bytes);
        assert!(matches!(addr, Address::Secp256k1Sha256Zilliqa(_)));
        assert_eq!(addr.as_ref(), &zil_bytes[1..]);
    }

    #[test]
    fn test_try_from_slice() {
        let mut zil_slice = vec![0u8; ADDR_LEN + 1];
        zil_slice[1..].fill(1);

        let addr = Address::try_from(zil_slice.as_slice()).unwrap();
        assert!(matches!(addr, Address::Secp256k1Sha256Zilliqa(_)));

        // Test invalid length
        let invalid_slice = vec![0u8; ADDR_LEN];
        assert!(matches!(
            Address::try_from(invalid_slice.as_slice()),
            Err(AddressError::InvalidLength)
        ));

        // Test invalid key type
        let invalid_type_slice = vec![2u8; ADDR_LEN + 1];
        assert!(matches!(
            Address::try_from(invalid_type_slice.as_slice()),
            Err(AddressError::InvalidKeyType)
        ));
    }

    #[test]
    fn test_as_ref() {
        let data = [1u8; ADDR_LEN];
        let addr = Address::Secp256k1Sha256Zilliqa(data);
        assert_eq!(addr.as_ref(), &data);
    }

    #[test]
    fn test_roundtrip() {
        let original_data = [1u8; ADDR_LEN];
        let addr = Address::Secp256k1Sha256Zilliqa(original_data);
        let bytes = addr.to_bytes();
        let roundtrip_addr = Address::from(bytes);
        assert_eq!(addr, roundtrip_addr);
    }

    #[test]
    fn test_addr() {
        let pubkey_eth: PubKey =
            "0103150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da"
                .parse()
                .unwrap();
        let pubkey_zil: PubKey =
            "0003150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da"
                .parse()
                .unwrap();
        let addr_eth = Address::from_pubkey(&pubkey_eth).unwrap();
        let addr_zil = Address::from_pubkey(&pubkey_zil).unwrap();

        assert_eq!(
            addr_eth.to_string(),
            "0xC315295101461753b838E0BE8688E744cf52Dd6b"
        );
        assert_eq!(
            addr_zil.to_string(),
            "zil1a0vtxuxamd3kltmyzpqdyxqu25vsss8mp58jtu"
        );
    }

    #[test]
    fn test_from_eth_address() {
        let hex_eth_adr = "0xf06686B5Eb5cAe38c09f12412B729045647E74e3";
        let addr = Address::from_eth_address(hex_eth_adr).unwrap();

        assert!(matches!(addr, Address::Secp256k1Keccak256Ethereum(_)));
        assert_eq!(addr.to_eth_checksummed().unwrap(), hex_eth_adr);
        assert!(Address::from_eth_address("0x1234").is_err());

        let hex_sha256_type = "0x7aa13D6AE95fb8E843d3bCC2eea365F71c3bACbe";
        let addr = Address::from_eth_address(hex_sha256_type).unwrap();

        assert!(matches!(addr, Address::Secp256k1Keccak256Ethereum(_)));
        assert_eq!(addr.to_eth_checksummed().unwrap(), hex_sha256_type);
    }

    #[test]
    fn test_alloy_addr() {
        let hex_eth_adr = "0xf06686B5Eb5cAe38c09f12412B729045647E74e3";
        let addr = Address::from_eth_address(hex_eth_adr).unwrap();
        let alloy_addr = addr.to_alloy_addr();

        assert_eq!(alloy_addr.to_checksum(None), hex_eth_adr);
    }
}

================
File: proto/src/btc_addr.rs
================
use config::{address::BTC_ADDR_SIZE, key::PUB_KEY_SIZE};
use ripemd::{Digest as _, Ripemd160};
use sha2::Sha256;

pub fn public_key_to_bitcoin_address(
    public_key: &[u8; PUB_KEY_SIZE],
    ver: u8,
) -> [u8; BTC_ADDR_SIZE] {
    let sha256_result = Sha256::digest(public_key);
    let ripemd160_result = Ripemd160::digest(sha256_result);
    let mut address_bytes = [0u8; BTC_ADDR_SIZE];

    address_bytes[0] = ver;
    address_bytes[1..21].copy_from_slice(&ripemd160_result);

    let checksum = Sha256::digest(Sha256::digest(&address_bytes[..21]));

    address_bytes[21..].copy_from_slice(&checksum[..4]);

    address_bytes
}

#[cfg(test)]
mod tests_btc_addr {
    // use super::*;
    // use bech32::{hrp, segwit, Bech32m, Hrp};
    //
    // #[test]
    // fn test_convert_from_pk() {
    //     let pk: [u8; PUB_KEY_SIZE] =
    //         hex::decode("03150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da")
    //             .unwrap()
    //             .try_into()
    //             .unwrap();
    //     let value = public_key_to_bitcoin_address(&pk, 0x00);
    //
    //     let hrp = Hrp::parse("bc").unwrap();
    //     let string = bech32::encode::<Bech32m>(hrp, &value).unwrap();
    //
    //     // dbg!(string);
    // }
}

================
File: proto/src/keypair.rs
================
use alloy::{
    network::EthereumWallet,
    signers::{local::PrivateKeySigner, SignerSync},
};
use bincode::{FromBytes, ToBytes};
use config::key::{BIP39_SEED_SIZE, PUB_KEY_SIZE, SECRET_KEY_SIZE};
use crypto::bip49::Bip49DerivationPath;
use crypto::schnorr;
use k256::SecretKey as K256SecretKey;

use crate::{
    address::Address, pubkey::PubKey, signature::Signature, tx::TransactionReceipt,
    tx::TransactionRequest,
};

use super::secret_key::SecretKey;
use rand::{RngCore, SeedableRng};
use rand_chacha::ChaCha20Rng;
use tiny_hderive::bip32::ExtendedPrivKey;
use zil_errors::keypair::KeyPairError;

// One byte for enum type
pub const KEYPAIR_BYTES_SIZE: usize = PUB_KEY_SIZE + SECRET_KEY_SIZE + 1;

#[derive(Debug, PartialEq)]
pub enum KeyPair {
    Secp256k1Sha256Zilliqa(([u8; PUB_KEY_SIZE], [u8; SECRET_KEY_SIZE])), // ZILLIQA
    Secp256k1Keccak256Ethereum(([u8; PUB_KEY_SIZE], [u8; SECRET_KEY_SIZE])), // Ethereum
}

impl KeyPair {
    pub fn gen_sha256() -> Result<Self, KeyPairError> {
        let keys = Self::gen_keys_bytes()?;

        Ok(Self::Secp256k1Sha256Zilliqa(keys))
    }

    pub fn gen_keccak256() -> Result<Self, KeyPairError> {
        let keys = Self::gen_keys_bytes()?;

        Ok(Self::Secp256k1Keccak256Ethereum(keys))
    }

    pub fn gen_keys_bytes() -> Result<([u8; PUB_KEY_SIZE], [u8; SECRET_KEY_SIZE]), KeyPairError> {
        let mut rng = ChaCha20Rng::from_entropy();
        let mut sk_bytes = [0u8; SECRET_KEY_SIZE];

        rng.fill_bytes(&mut sk_bytes);

        let secret_key =
            K256SecretKey::from_slice(&sk_bytes).or(Err(KeyPairError::InvalidEntropy))?;
        let pub_key: [u8; PUB_KEY_SIZE] = secret_key
            .public_key()
            .to_sec1_bytes()
            .to_vec()
            .try_into()
            .or(Err(KeyPairError::InvalidSecretKey))?;
        let secret_key: [u8; SECRET_KEY_SIZE] = secret_key.to_bytes().into();

        Ok((pub_key, secret_key))
    }

    pub fn from_secret_key(sk: &SecretKey) -> Result<Self, KeyPairError> {
        let secret_key: K256SecretKey =
            K256SecretKey::from_slice(sk.as_ref()).or(Err(KeyPairError::InvalidSecretKey))?;
        let pub_key: [u8; PUB_KEY_SIZE] = secret_key
            .public_key()
            .to_sec1_bytes()
            .to_vec()
            .try_into()
            .or(Err(KeyPairError::InvalidSecretKey))?;

        match sk {
            SecretKey::Secp256k1Keccak256Ethereum(sk) => {
                Ok(KeyPair::Secp256k1Keccak256Ethereum((pub_key, *sk)))
            }
            SecretKey::Secp256k1Sha256Zilliqa(sk) => {
                Ok(KeyPair::Secp256k1Sha256Zilliqa((pub_key, *sk)))
            }
        }
    }

    pub fn from_bip39_seed(
        seed: &[u8; BIP39_SEED_SIZE],
        bip49: &Bip49DerivationPath,
    ) -> Result<Self, KeyPairError> {
        let path = bip49.get_path();
        let ext = ExtendedPrivKey::derive(seed, path.as_str())
            .map_err(|_| KeyPairError::ExtendedPrivKeyDeriveError)?;
        let secret_key =
            K256SecretKey::from_slice(&ext.secret()).or(Err(KeyPairError::InvalidEntropy))?;
        let pub_key: [u8; PUB_KEY_SIZE] = secret_key
            .public_key()
            .to_sec1_bytes()
            .to_vec()
            .try_into()
            .or(Err(KeyPairError::InvalidSecretKey))?;
        let secret_key: [u8; SECRET_KEY_SIZE] = secret_key.to_bytes().into();

        match bip49 {
            Bip49DerivationPath::Zilliqa(_) => {
                Ok(Self::Secp256k1Sha256Zilliqa((pub_key, secret_key)))
            }
            Bip49DerivationPath::Ethereum(_) => {
                Ok(Self::Secp256k1Keccak256Ethereum((pub_key, secret_key)))
            }
        }
    }

    pub fn get_addr(&self) -> Result<Address, KeyPairError> {
        let pk = self.get_pubkey()?;
        let addr = Address::from_pubkey(&pk).map_err(KeyPairError::AddressParseError)?;

        Ok(addr)
    }

    pub fn get_secretkey(&self) -> Result<SecretKey, KeyPairError> {
        match self {
            KeyPair::Secp256k1Sha256Zilliqa((_, sk)) => Ok(SecretKey::Secp256k1Sha256Zilliqa(*sk)),
            KeyPair::Secp256k1Keccak256Ethereum((_, sk)) => {
                Ok(SecretKey::Secp256k1Keccak256Ethereum(*sk))
            }
        }
    }

    pub fn get_pubkey(&self) -> Result<PubKey, KeyPairError> {
        match self {
            KeyPair::Secp256k1Sha256Zilliqa((pk, _)) => Ok(PubKey::Secp256k1Sha256Zilliqa(*pk)),
            KeyPair::Secp256k1Keccak256Ethereum((pk, _)) => {
                Ok(PubKey::Secp256k1Keccak256Ethereum(*pk))
            }
        }
    }

    pub fn get_sk_bytes(&self) -> [u8; SECRET_KEY_SIZE] {
        match self {
            KeyPair::Secp256k1Sha256Zilliqa((_, sk)) => *sk,
            KeyPair::Secp256k1Keccak256Ethereum((_, sk)) => *sk,
        }
    }

    pub fn get_local_eth_siger(&self) -> Result<PrivateKeySigner, KeyPairError> {
        let bytes = self.get_sk_bytes();
        PrivateKeySigner::from_slice(&bytes)
            .map_err(|e| KeyPairError::EthersInvalidSecretKey(e.to_string()))
    }

    pub fn get_local_eth_wallet(&self) -> Result<EthereumWallet, KeyPairError> {
        let signer: PrivateKeySigner = self.get_local_eth_siger()?;
        let wallet = EthereumWallet::from(signer);
        Ok(wallet)
    }

    pub fn sign_message(&self, msg: &[u8]) -> Result<Signature, KeyPairError> {
        match self {
            KeyPair::Secp256k1Keccak256Ethereum((_, _sk)) => {
                let signer = self.get_local_eth_siger()?;
                let sig = signer
                    .sign_message_sync(msg)
                    .map_err(|e| KeyPairError::EthersInvalidSign(e.to_string()))?
                    .try_into()
                    .map_err(KeyPairError::InvalidSignature)?;

                Ok(sig)
            }
            KeyPair::Secp256k1Sha256Zilliqa((_, sk)) => {
                let secret_key =
                    K256SecretKey::from_slice(sk).or(Err(KeyPairError::InvalidSecretKey))?;
                let sig: Signature = schnorr::sign(msg, &secret_key)
                    .map_err(KeyPairError::SchorrError)?
                    .try_into()
                    .map_err(KeyPairError::InvalidSignature)?;

                Ok(sig)
            }
        }
    }

    pub fn verify_sig(&self, msg_bytes: &[u8], sig: &Signature) -> Result<bool, KeyPairError> {
        let pk = self.get_pubkey()?;
        let is_verify = sig
            .verify(msg_bytes, &pk)
            .map_err(KeyPairError::InvalidSignature)?;

        Ok(is_verify)
    }

    pub async fn sign_tx(
        &self,
        tx: &TransactionRequest,
    ) -> Result<TransactionReceipt, KeyPairError> {
        tx.sign(self).await
    }
}

impl ToBytes<{ KEYPAIR_BYTES_SIZE }> for KeyPair {
    type Error = KeyPairError;
    fn to_bytes(&self) -> Result<[u8; KEYPAIR_BYTES_SIZE], Self::Error> {
        let mut result = [0u8; KEYPAIR_BYTES_SIZE];

        match self {
            KeyPair::Secp256k1Sha256Zilliqa((pk, sk)) => {
                result[0] = 0;
                result[1..PUB_KEY_SIZE + 1].copy_from_slice(pk);
                result[PUB_KEY_SIZE + 1..].copy_from_slice(sk);
            }
            KeyPair::Secp256k1Keccak256Ethereum((pk, sk)) => {
                result[0] = 1;
                result[1..PUB_KEY_SIZE + 1].copy_from_slice(pk);
                result[PUB_KEY_SIZE + 1..].copy_from_slice(sk);
            }
        };

        Ok(result)
    }
}

impl FromBytes for KeyPair {
    type Error = KeyPairError;

    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Result<Self, Self::Error> {
        if bytes.len() != KEYPAIR_BYTES_SIZE {
            return Err(KeyPairError::InvalidLength);
        }

        let key_type = bytes[0];
        let pk: [u8; PUB_KEY_SIZE] = bytes[1..PUB_KEY_SIZE + 1]
            .try_into()
            .map_err(|_| KeyPairError::InvalidPublicKey)?;
        let sk: [u8; SECRET_KEY_SIZE] = bytes[PUB_KEY_SIZE + 1..]
            .try_into()
            .map_err(|_| KeyPairError::InvalidSecretKey)?;

        match key_type {
            0 => Ok(KeyPair::Secp256k1Sha256Zilliqa((pk, sk))),
            1 => Ok(KeyPair::Secp256k1Keccak256Ethereum((pk, sk))),
            _ => Err(KeyPairError::InvalidKeyType),
        }
    }
}

#[cfg(test)]
mod tests {
    use bip39::Mnemonic;

    use super::*;
    use std::borrow::Cow;

    fn create_test_keypair(key_type: u8) -> KeyPair {
        let pk = [1u8; PUB_KEY_SIZE];
        let sk = [2u8; SECRET_KEY_SIZE];
        match key_type {
            0 => KeyPair::Secp256k1Sha256Zilliqa((pk, sk)),
            1 => KeyPair::Secp256k1Keccak256Ethereum((pk, sk)),
            _ => panic!("Invalid key type for test"),
        }
    }

    #[test]
    fn test_to_bytes_secp256k1_sha256() {
        let keypair = create_test_keypair(0);
        let bytes = keypair.to_bytes().unwrap();
        assert_eq!(bytes[0], 0);
        assert_eq!(&bytes[1..PUB_KEY_SIZE + 1], &[1u8; PUB_KEY_SIZE]);
        assert_eq!(&bytes[PUB_KEY_SIZE + 1..], &[2u8; SECRET_KEY_SIZE]);
    }

    #[test]
    fn test_to_bytes_secp256k1_keccak256() {
        let keypair = create_test_keypair(1);
        let bytes = keypair.to_bytes().unwrap();
        assert_eq!(bytes[0], 1);
        assert_eq!(&bytes[1..PUB_KEY_SIZE + 1], &[1u8; PUB_KEY_SIZE]);
        assert_eq!(&bytes[PUB_KEY_SIZE + 1..], &[2u8; SECRET_KEY_SIZE]);
    }

    #[test]
    fn test_from_bytes_secp256k1_sha256() {
        let original = create_test_keypair(0);
        let bytes = original.to_bytes().unwrap();
        let recovered = KeyPair::from_bytes(Cow::Borrowed(&bytes)).unwrap();
        assert_eq!(original, recovered);
    }

    #[test]
    fn test_from_bytes_secp256k1_keccak256() {
        let original = create_test_keypair(1);
        let bytes = original.to_bytes().unwrap();
        let recovered = KeyPair::from_bytes(Cow::Borrowed(&bytes)).unwrap();
        assert_eq!(original, recovered);
    }

    #[test]
    fn test_from_bytes_invalid_length() {
        let bytes = vec![0u8; KEYPAIR_BYTES_SIZE - 1];
        let result = KeyPair::from_bytes(Cow::Borrowed(&bytes));
        assert!(matches!(result, Err(KeyPairError::InvalidLength)));
    }

    #[test]
    fn test_from_bytes_invalid_key_type() {
        let mut bytes = vec![0u8; KEYPAIR_BYTES_SIZE];
        bytes[0] = 2; // Invalid key type
        let result = KeyPair::from_bytes(Cow::Borrowed(&bytes));
        assert!(matches!(result, Err(KeyPairError::InvalidKeyType)));
    }

    #[test]
    fn test_roundtrip() {
        let original = create_test_keypair(0);
        let bytes = original.to_bytes().unwrap();
        let recovered = KeyPair::from_bytes(Cow::Borrowed(&bytes)).unwrap();
        assert_eq!(original, recovered);

        let original = create_test_keypair(1);
        let bytes = original.to_bytes().unwrap();
        let recovered = KeyPair::from_bytes(Cow::Borrowed(&bytes)).unwrap();
        assert_eq!(original, recovered);
    }

    #[test]
    fn test_sign_message() {
        use rand::{RngCore, SeedableRng};
        use rand_chacha::ChaCha20Rng;

        let mut rng = ChaCha20Rng::from_entropy();

        for _ in 0..10 {
            let key_pair = KeyPair::gen_sha256().unwrap();
            let mut message_bytes = [0u8; 100];

            rng.fill_bytes(&mut message_bytes);

            let signature = key_pair.sign_message(&message_bytes).unwrap();
            let verify = key_pair.verify_sig(&message_bytes, &signature);

            assert!(verify.is_ok());
            assert!(verify.unwrap());
        }

        for _ in 0..10 {
            let key_pair = KeyPair::gen_keccak256().unwrap();
            let mut message_bytes = [0u8; 100];

            rng.fill_bytes(&mut message_bytes);
            let signature = key_pair.sign_message(&message_bytes).unwrap();
            let verify = key_pair.verify_sig(&message_bytes, &signature);

            assert!(verify.is_ok());
            assert!(verify.unwrap());
        }
    }

    #[test]
    fn from_to_bytes() {
        use crate::keypair::KeyPair;

        let key_pair = KeyPair::gen_keccak256().unwrap();
        let bytes = key_pair.to_bytes().unwrap();
        let restored_key_pair = KeyPair::from_bytes(bytes[..].into()).unwrap();

        assert_eq!(restored_key_pair, key_pair);
    }

    #[test]
    fn test_bip39_zil() {
        let mnemonic_str =
            "green process gate doctor slide whip priority shrug diamond crumble average help";
        let m = Mnemonic::parse_normalized(mnemonic_str).unwrap();
        let index = 0;
        let seed = m.to_seed("");

        let zil_path = Bip49DerivationPath::Zilliqa(index);
        let eth_path = Bip49DerivationPath::Ethereum(index);

        assert_eq!(
            [
                143, 219, 233, 88, 72, 55, 94, 13, 19, 72, 66, 197, 121, 69, 163, 46, 15, 247, 4,
                104, 60, 132, 106, 5, 135, 186, 182, 62, 54, 56, 209, 5, 182, 104, 244, 78, 184,
                167, 36, 156, 3, 14, 212, 191, 102, 69, 11, 214, 43, 181, 138, 7, 21, 241, 122,
                192, 73, 244, 36, 136, 187, 175, 159, 181,
            ],
            seed
        );
        let zil_key_pair = KeyPair::from_bip39_seed(&seed, &zil_path).unwrap();
        let eth_key_pair = KeyPair::from_bip39_seed(&seed, &eth_path).unwrap();

        let addr_eth = eth_key_pair.get_addr().unwrap();
        let addr_zil = zil_key_pair.get_addr().unwrap();

        assert_eq!(
            addr_eth.to_string(),
            "0x7aa13D6AE95fb8E843d3bCC2eea365F71c3bACbe"
        );
        assert_eq!(
            addr_zil.to_string(),
            "zil1a0vtxuxamd3kltmyzpqdyxqu25vsss8mp58jtu"
        );

        assert_ne!(
            zil_key_pair.get_pubkey().unwrap(),
            eth_key_pair.get_pubkey().unwrap()
        );
        assert_ne!(
            zil_key_pair.get_secretkey().unwrap(),
            eth_key_pair.get_secretkey().unwrap()
        );

        assert_eq!(
            zil_key_pair.get_secretkey().unwrap().to_string(),
            "00e93c035175b08613c4b0251ca92cd007026ca032ba53bafa3c839838f8b52d04"
        );
        assert_eq!(
            eth_key_pair.get_secretkey().unwrap().to_string(),
            "01b8ef60193eec0a55db93ba692035a8b5a388579c8dc58acc62ea470aba529e1c"
        );
        assert_eq!(
            eth_key_pair.get_pubkey().unwrap().to_string(),
            "010315bd7b9301a2cde69ef8092d6fb275a077e3c94e5ed166c915426850cf606600"
        );
        assert_eq!(
            zil_key_pair.get_pubkey().unwrap().to_string(),
            "0003150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da"
        );
    }
}

================
File: proto/src/lib.rs
================
pub mod zilliqa_proto {
    include!("zilliqa_message.rs");
}

pub mod address;
pub mod btc_addr;
pub mod keypair;
pub mod pubkey;
pub mod secret_key;
pub mod signature;
pub mod tx;
pub mod zil_address;
pub mod zil_tx;
pub mod zq1_proto;

================
File: proto/src/pubkey.rs
================
use bincode::ToBytes;
use config::address::ADDR_LEN;
use config::key::PUB_KEY_SIZE;
use k256::PublicKey as K256PublicKey;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::str::FromStr;
use zil_errors::keypair::PubKeyError;

use crate::address::Address;
use crate::zil_address::from_zil_pub_key;

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PubKey {
    Secp256k1Sha256Zilliqa([u8; PUB_KEY_SIZE]),     // ZILLIQA
    Secp256k1Keccak256Ethereum([u8; PUB_KEY_SIZE]), // Ethereum
    Secp256k1Bitcoin([u8; PUB_KEY_SIZE]),           // Bitcoin
    Ed25519Solana([u8; PUB_KEY_SIZE]),              // Solana
}

impl PubKey {
    pub fn get_bytes_addr(&self) -> Result<[u8; ADDR_LEN], PubKeyError> {
        match self {
            PubKey::Secp256k1Keccak256Ethereum(pk) => {
                let k256_pubkey = alloy::signers::k256::ecdsa::VerifyingKey::from_sec1_bytes(pk)
                    .map_err(|e| PubKeyError::InvalidVerifyingKey(e.to_string()))?;
                let addr = alloy::primitives::Address::from_public_key(&k256_pubkey);

                Ok(addr.into())
            }
            PubKey::Secp256k1Sha256Zilliqa(pk) => {
                from_zil_pub_key(pk).or(Err(PubKeyError::InvalidPubKey))
            }
            PubKey::Secp256k1Bitcoin(_) => Err(PubKeyError::NotImpl),
            PubKey::Ed25519Solana(_) => Err(PubKeyError::NotImpl),
        }
    }

    pub fn as_bytes(&self) -> [u8; PUB_KEY_SIZE] {
        match self {
            PubKey::Secp256k1Keccak256Ethereum(v) => *v,
            PubKey::Secp256k1Sha256Zilliqa(v) => *v,
            PubKey::Secp256k1Bitcoin(v) => *v,
            PubKey::Ed25519Solana(v) => *v,
        }
    }

    pub fn get_addr(&self) -> Result<Address, PubKeyError> {
        let buf = self.get_bytes_addr()?;

        match self {
            PubKey::Secp256k1Keccak256Ethereum(_) => Ok(Address::Secp256k1Keccak256Ethereum(buf)),
            PubKey::Secp256k1Sha256Zilliqa(_) => Ok(Address::Secp256k1Sha256Zilliqa(buf)),
            PubKey::Secp256k1Bitcoin(_) => Err(PubKeyError::NotImpl),
            PubKey::Ed25519Solana(_) => Err(PubKeyError::NotImpl),
        }
    }
}

impl TryInto<K256PublicKey> for PubKey {
    type Error = PubKeyError;

    fn try_into(self) -> Result<K256PublicKey, Self::Error> {
        let pk =
            K256PublicKey::from_sec1_bytes(self.as_ref()).or(Err(PubKeyError::FailIntoPubKey))?;

        Ok(pk)
    }
}

impl TryFrom<&PubKey> for K256PublicKey {
    type Error = PubKeyError;

    fn try_from(pk: &PubKey) -> Result<Self, Self::Error> {
        K256PublicKey::from_sec1_bytes(pk.as_ref()).map_err(|_| PubKeyError::FailIntoPubKey)
    }
}

impl ToBytes<{ PUB_KEY_SIZE + 1 }> for PubKey {
    type Error = PubKeyError;
    fn to_bytes(&self) -> Result<[u8; PUB_KEY_SIZE + 1], Self::Error> {
        let mut result = [0u8; PUB_KEY_SIZE + 1];

        result[0] = match self {
            PubKey::Secp256k1Sha256Zilliqa(_) => 0,
            PubKey::Secp256k1Keccak256Ethereum(_) => 1,
            PubKey::Secp256k1Bitcoin(_) => 2,
            PubKey::Ed25519Solana(_) => 3,
        };
        result[1..].copy_from_slice(self.as_ref());

        Ok(result)
    }
}

impl std::fmt::Display for PubKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", hex::encode(self.to_bytes().unwrap()))
    }
}

impl Serialize for PubKey {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'de> Deserialize<'de> for PubKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        PubKey::from_str(&s).map_err(serde::de::Error::custom)
    }
}

impl From<[u8; PUB_KEY_SIZE + 1]> for PubKey {
    fn from(bytes: [u8; PUB_KEY_SIZE + 1]) -> Self {
        let key_type = bytes[0];
        let key_data: [u8; PUB_KEY_SIZE] = bytes[1..].try_into().unwrap();

        match key_type {
            0 => PubKey::Secp256k1Sha256Zilliqa(key_data),
            1 => PubKey::Secp256k1Keccak256Ethereum(key_data),
            2 => PubKey::Secp256k1Bitcoin(key_data),
            3 => PubKey::Ed25519Solana(key_data),
            _ => panic!("Invalid key type"),
        }
    }
}

impl TryFrom<&[u8]> for PubKey {
    type Error = PubKeyError;

    fn try_from(slice: &[u8]) -> Result<Self, Self::Error> {
        if slice.len() != PUB_KEY_SIZE + 1 {
            return Err(PubKeyError::InvalidLength);
        }

        let key_type = slice[0];
        let key_data: [u8; PUB_KEY_SIZE] = slice[1..]
            .try_into()
            .map_err(|_| PubKeyError::InvalidLength)?;

        match key_type {
            0 => Ok(PubKey::Secp256k1Sha256Zilliqa(key_data)),
            1 => Ok(PubKey::Secp256k1Keccak256Ethereum(key_data)),
            _ => Err(PubKeyError::InvalidKeyType),
        }
    }
}

impl AsRef<[u8]> for PubKey {
    fn as_ref(&self) -> &[u8] {
        match self {
            PubKey::Secp256k1Sha256Zilliqa(data) => data,
            PubKey::Secp256k1Keccak256Ethereum(data) => data,
            PubKey::Secp256k1Bitcoin(data) => data,
            PubKey::Ed25519Solana(data) => data,
        }
    }
}

impl FromStr for PubKey {
    type Err = PubKeyError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let data = hex::decode(s).map_err(|_| PubKeyError::InvalidHex)?;
        let bytes: [u8; PUB_KEY_SIZE] = data[1..]
            .try_into()
            .map_err(|_| PubKeyError::InvalidLength)?;
        let prefix = data[0];

        match prefix {
            0 => Ok(PubKey::Secp256k1Sha256Zilliqa(bytes)),
            1 => Ok(PubKey::Secp256k1Keccak256Ethereum(bytes)),
            2 => Ok(PubKey::Secp256k1Bitcoin(bytes)),
            3 => Ok(PubKey::Ed25519Solana(bytes)),
            _ => Err(PubKeyError::InvalidKeyType),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_from_bytes() {
        let zil_bytes = [0u8; PUB_KEY_SIZE + 1];
        let eth_bytes = [1u8; PUB_KEY_SIZE + 1];

        let zil_key = PubKey::from(zil_bytes);
        let eth_key = PubKey::from(eth_bytes);

        assert!(matches!(zil_key, PubKey::Secp256k1Sha256Zilliqa(_)));
        assert!(matches!(eth_key, PubKey::Secp256k1Keccak256Ethereum(_)));
    }

    #[test]
    fn test_try_from_slice() {
        let zil_slice = &[0u8; PUB_KEY_SIZE + 1][..];
        let eth_slice = &[1u8; PUB_KEY_SIZE + 1][..];
        let invalid_slice = &[2u8; PUB_KEY_SIZE + 1][..];
        let short_slice = &[0u8; PUB_KEY_SIZE][..];

        assert!(matches!(
            PubKey::try_from(zil_slice),
            Ok(PubKey::Secp256k1Sha256Zilliqa(_))
        ));
        assert!(matches!(
            PubKey::try_from(eth_slice),
            Ok(PubKey::Secp256k1Keccak256Ethereum(_))
        ));
        assert!(matches!(
            PubKey::try_from(invalid_slice),
            Err(PubKeyError::InvalidKeyType)
        ));
        assert!(matches!(
            PubKey::try_from(short_slice),
            Err(PubKeyError::InvalidLength)
        ));
    }

    #[test]
    fn test_as_ref() {
        let data = [42u8; PUB_KEY_SIZE];
        let zil_key = PubKey::Secp256k1Sha256Zilliqa(data);
        let eth_key = PubKey::Secp256k1Keccak256Ethereum(data);

        assert_eq!(zil_key.as_ref(), &data);
        assert_eq!(eth_key.as_ref(), &data);
    }

    #[test]
    fn test_to_bytes() {
        let data = [42u8; PUB_KEY_SIZE];
        let zil_key = PubKey::Secp256k1Sha256Zilliqa(data);
        let eth_key = PubKey::Secp256k1Keccak256Ethereum(data);

        let zil_bytes = zil_key.to_bytes().unwrap();
        let eth_bytes = eth_key.to_bytes().unwrap();

        assert_eq!(zil_bytes[0], 0);
        assert_eq!(eth_bytes[0], 1);
        assert_eq!(&zil_bytes[1..], &data);
        assert_eq!(&eth_bytes[1..], &data);
    }

    #[test]
    fn test_roundtrip() {
        let original_data = [42u8; PUB_KEY_SIZE];
        let zil_key = PubKey::Secp256k1Sha256Zilliqa(original_data);
        let eth_key = PubKey::Secp256k1Keccak256Ethereum(original_data);

        let zil_bytes = zil_key.to_bytes().unwrap();
        let eth_bytes = eth_key.to_bytes().unwrap();

        let zil_key_roundtrip = PubKey::from(zil_bytes);
        let eth_key_roundtrip = PubKey::from(eth_bytes);

        assert_eq!(zil_key, zil_key_roundtrip);
        assert_eq!(eth_key, eth_key_roundtrip);
    }

    #[test]
    fn test_pubkey_to_string() {
        let zil_data = [42u8; PUB_KEY_SIZE];
        let eth_data = [69u8; PUB_KEY_SIZE];

        let zil_key = PubKey::Secp256k1Sha256Zilliqa(zil_data);
        let eth_key = PubKey::Secp256k1Keccak256Ethereum(eth_data);

        let zil_str = zil_key.to_string();
        let eth_str = eth_key.to_string();

        assert_eq!(PubKey::from_str(&zil_str).unwrap(), zil_key);
        assert_eq!(PubKey::from_str(&eth_str).unwrap(), eth_key);

        assert_eq!(PubKey::from_str("invalid"), Err(PubKeyError::InvalidHex));
        assert_eq!(
            PubKey::from_str(
                "0903150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da"
            ),
            Err(PubKeyError::InvalidKeyType)
        );
        assert_eq!(
            PubKey::from_str(
                "0030303150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da"
            ),
            Err(PubKeyError::InvalidHex)
        );
    }

    #[test]
    fn test_str_pubkey() {
        let pubkey_eth: PubKey =
            "0103150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da"
                .parse()
                .unwrap();
        let pubkey_zil: PubKey =
            "0003150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da"
                .parse()
                .unwrap();

        let addr_eth = pubkey_eth.get_bytes_addr().unwrap();
        let addr_zil = pubkey_zil.get_bytes_addr().unwrap();

        assert_eq!(
            hex::encode(addr_eth),
            "c315295101461753b838e0be8688e744cf52dd6b"
        );
        assert_eq!(
            hex::encode(addr_zil),
            "ebd8b370dddb636faf641040d2181c55190840fb"
        );
    }
}

================
File: proto/src/secret_key.rs
================
use std::str::FromStr;

use bincode::{FromBytes, ToBytes};
use config::key::SECRET_KEY_SIZE;
use zil_errors::keypair::SecretKeyError;

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum SecretKey {
    Secp256k1Sha256Zilliqa([u8; SECRET_KEY_SIZE]), // ZILLIQA
    Secp256k1Keccak256Ethereum([u8; SECRET_KEY_SIZE]), // Ethereum
}

impl SecretKey {
    pub fn to_vec(&self) -> Vec<u8> {
        match self {
            SecretKey::Secp256k1Sha256Zilliqa(buf) => buf.to_vec(),
            SecretKey::Secp256k1Keccak256Ethereum(buf) => buf.to_vec(),
        }
    }
}

impl std::fmt::Display for SecretKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", hex::encode(self.to_bytes().unwrap()))
    }
}

impl ToBytes<{ SECRET_KEY_SIZE + 1 }> for SecretKey {
    type Error = SecretKeyError;
    fn to_bytes(&self) -> Result<[u8; SECRET_KEY_SIZE + 1], Self::Error> {
        let mut result = [0u8; SECRET_KEY_SIZE + 1];

        result[0] = match self {
            SecretKey::Secp256k1Sha256Zilliqa(_) => 0,
            SecretKey::Secp256k1Keccak256Ethereum(_) => 1,
        };
        result[1..].copy_from_slice(self.as_ref());

        Ok(result)
    }
}

impl TryInto<Vec<u8>> for SecretKey {
    type Error = SecretKeyError;
    fn try_into(self) -> Result<Vec<u8>, Self::Error> {
        let bytes = self.to_bytes()?;

        Ok(bytes.to_vec())
    }
}

impl FromBytes for SecretKey {
    type Error = SecretKeyError;

    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Result<Self, Self::Error> {
        let key_type = bytes[0];
        let key_data: [u8; SECRET_KEY_SIZE] = bytes[1..]
            .try_into()
            .or(Err(SecretKeyError::SecretKeySliceError))?;

        match key_type {
            0 => Ok(SecretKey::Secp256k1Sha256Zilliqa(key_data)),
            1 => Ok(SecretKey::Secp256k1Keccak256Ethereum(key_data)),
            _ => panic!("Invalid key type"),
        }
    }
}

impl AsRef<[u8]> for SecretKey {
    fn as_ref(&self) -> &[u8] {
        match self {
            SecretKey::Secp256k1Sha256Zilliqa(data) => data,
            SecretKey::Secp256k1Keccak256Ethereum(data) => data,
        }
    }
}

impl FromStr for SecretKey {
    type Err = SecretKeyError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let data = hex::decode(s).map_err(|_| SecretKeyError::InvalidHex)?;
        let bytes: [u8; SECRET_KEY_SIZE] = data[1..]
            .try_into()
            .map_err(|_| SecretKeyError::InvalidLength)?;
        let prefix = data[0];

        match prefix {
            0 => Ok(SecretKey::Secp256k1Sha256Zilliqa(bytes)),
            1 => Ok(SecretKey::Secp256k1Keccak256Ethereum(bytes)),
            _ => Err(SecretKeyError::InvalidKeyType),
        }
    }
}

================
File: proto/src/signature.rs
================
use alloy::signers::k256;
use alloy::signers::Signature as EthersSignature;
use config::sha::{ECDSAS_ECP256K1_KECCAK256_SIZE, SHA256_SIZE, SHA512_SIZE};
use crypto::schnorr;
use k256::ecdsa::Signature as SchnorrSignature;
use k256::PublicKey as K256PublicKey;
use zil_errors::crypto::SignatureError;

use crate::pubkey::PubKey;

#[derive(Debug, PartialEq, Eq)]
pub enum Signature {
    SchnorrSecp256k1Sha256([u8; SHA512_SIZE]), // Zilliqa
    ECDSASecp256k1Keccak256([u8; ECDSAS_ECP256K1_KECCAK256_SIZE]), // Ethereum
}

impl Signature {
    pub fn verify(&self, msg_bytes: &[u8], pk: &PubKey) -> Result<bool, SignatureError> {
        match self {
            Signature::SchnorrSecp256k1Sha256(sig) => {
                let sig = SchnorrSignature::from_slice(sig)
                    .or(Err(SignatureError::FailParseSignature))?;
                let pk: K256PublicKey = pk.try_into().map_err(SignatureError::FailIntoPubKey)?;
                let verify = schnorr::verify(msg_bytes, pk, sig);

                Ok(verify.is_some())
            }
            Signature::ECDSASecp256k1Keccak256(sig) => {
                let signature = EthersSignature::from_bytes_and_parity(&sig[..64], sig[64] as u64)
                    .or(Err(SignatureError::FailParseSignature))?;
                let signer_address = pk
                    .get_bytes_addr()
                    .map_err(SignatureError::FailIntoPubKey)?;
                let recovered_address = signature
                    .recover_address_from_msg(msg_bytes)
                    .map_err(|e| SignatureError::FailParseRecover(e.to_string()))?;

                Ok(recovered_address == signer_address)
            }
        }
    }
}

impl TryFrom<&[u8]> for Signature {
    type Error = SignatureError;

    fn try_from(sig_bytes: &[u8]) -> Result<Self, Self::Error> {
        if sig_bytes.len() == SHA256_SIZE {
            let buf: [u8; SHA512_SIZE] = sig_bytes
                .try_into()
                .or(Err(SignatureError::InvalidLength))?;

            Ok(Signature::SchnorrSecp256k1Sha256(buf))
        } else if sig_bytes.len() == ECDSAS_ECP256K1_KECCAK256_SIZE {
            let buf: [u8; ECDSAS_ECP256K1_KECCAK256_SIZE] = sig_bytes
                .try_into()
                .or(Err(SignatureError::InvalidLength))?;

            Ok(Signature::ECDSASecp256k1Keccak256(buf))
        } else {
            Err(SignatureError::InvalidLength)
        }
    }
}

impl TryFrom<EthersSignature> for Signature {
    type Error = SignatureError;

    fn try_from(eth_sig: EthersSignature) -> Result<Self, Self::Error> {
        let sig_bytes: [u8; ECDSAS_ECP256K1_KECCAK256_SIZE] = eth_sig.into();

        Ok(Signature::ECDSASecp256k1Keccak256(sig_bytes))
    }
}

impl TryFrom<SchnorrSignature> for Signature {
    type Error = SignatureError;

    fn try_from(sig: SchnorrSignature) -> Result<Self, Self::Error> {
        let sig_bytes: [u8; SHA512_SIZE] = sig.to_bytes().into();

        Ok(Signature::SchnorrSecp256k1Sha256(sig_bytes))
    }
}

================
File: proto/src/tx.rs
================
use crate::keypair::KeyPair;
use crate::zil_tx::{
    encode_zilliqa_transaction, version_from_chainid, ZILTransactionReceipt, ZILTransactionRequest,
};
use alloy::consensus::TxEnvelope;
use alloy::network::TransactionBuilder;
use alloy::rpc::types::TransactionRequest as ETHTransactionRequest;
use crypto::schnorr::sign as zil_sign;
use k256::SecretKey as K256SecretKey;
use zil_errors::keypair::KeyPairError;

#[derive(Debug, PartialEq, Eq)]
pub enum TransactionReceipt {
    Zilliqa(ZILTransactionReceipt), // ZILLIQA
    Ethereum(TxEnvelope),           // Ethereum
}

#[derive(Debug, PartialEq, Eq)]
pub enum TransactionRequest {
    Zilliqa(ZILTransactionRequest),  // ZILLIQA
    Ethereum(ETHTransactionRequest), // Ethereum
}

impl TransactionRequest {
    pub async fn sign(&self, keypair: &KeyPair) -> Result<TransactionReceipt, KeyPairError> {
        match self {
            TransactionRequest::Zilliqa(tx) => {
                let pub_key = keypair.get_pubkey()?;
                let bytes = encode_zilliqa_transaction(tx, &pub_key);
                let secret_key = keypair.get_secretkey()?.to_vec();
                let secret_key = K256SecretKey::from_slice(&secret_key)
                    .or(Err(KeyPairError::InvalidSecretKey))?;
                let signature = zil_sign(&bytes, &secret_key)
                    .map_err(|e| KeyPairError::EthersInvalidSign(e.to_string()))?;
                let signature = hex::encode(signature.to_bytes());
                let to_addr = tx.to_addr.to_eth_checksummed()?;

                Ok(TransactionReceipt::Zilliqa(ZILTransactionReceipt {
                    signature,
                    to_addr,
                    pub_key: hex::encode(pub_key.as_bytes()),
                    version: version_from_chainid(tx.chain_id),
                    nonce: tx.nonce,
                    gas_price: tx.gas_price,
                    gas_limit: tx.gas_limit,
                    amount: tx.amount,
                    code: tx.code.clone(),
                    data: tx.data.clone(),
                    priority: false, // TODO: no more use in ZILLiqa chain
                }))
            }
            TransactionRequest::Ethereum(tx) => {
                let wallet = keypair.get_local_eth_wallet()?;
                let tx_envelope = tx
                    .clone()
                    .build(&wallet)
                    .await
                    .map_err(|e| KeyPairError::FailToSignTx(e.to_string()))?;

                Ok(TransactionReceipt::Ethereum(tx_envelope))
            }
        }
    }

    pub fn json(&self) -> Result<String, serde_json::Error> {
        match self {
            Self::Zilliqa(tx) => serde_json::to_string(tx),
            Self::Ethereum(tx) => serde_json::to_string(tx),
        }
    }
}

================
File: proto/src/zil_address.rs
================
use alloy::primitives::U256;
use bech32::{Bech32, Hrp};
use config::address::{ADDR_LEN, HRP};
use sha2::{Digest, Sha256};
use zil_errors::address::AddressError;

pub fn to_checksum_address(address: &str) -> Result<String, AddressError> {
    let address = address.trim_start_matches("0x").to_lowercase();
    let address_bytes = hex::decode(&address).or(Err(AddressError::InvalidHex))?;

    let mut hasher = Sha256::new();
    hasher.update(&address_bytes);

    let hash = hasher.finalize();
    let v = U256::from_be_slice(&hash);
    let mut ret = String::from("0x");

    for (i, ch) in address.chars().enumerate() {
        if ch.is_ascii_digit() {
            ret.push(ch);
        } else {
            let mask = U256::from(2).pow(U256::from(255 - 6 * i));
            if v & mask >= U256::from(1) {
                ret.push(ch.to_ascii_uppercase());
            } else {
                ret.push(ch.to_ascii_lowercase());
            }
        }
    }

    Ok(ret)
}

pub fn from_zil_base16(addr: &str) -> Option<[u8; ADDR_LEN]> {
    let mb_bytes = hex::decode(addr).ok()?;
    let value = mb_bytes.try_into().ok()?;

    Some(value)
}

pub fn from_zil_pub_key(pub_key: &[u8]) -> Result<[u8; ADDR_LEN], AddressError> {
    let mut hasher = Sha256::new();
    hasher.update(pub_key);
    let hash = hasher.finalize();
    let hash_slice = &hash[12..];
    let value: [u8; ADDR_LEN] = hash_slice.try_into().or(Err(AddressError::InvalidPubKey))?;

    Ok(value)
}

pub fn from_zil_bech32_address(address: &str) -> Result<[u8; ADDR_LEN], AddressError> {
    let (hrp, bytes) = bech32::decode(address).map_err(|_| AddressError::InvalidBech32Len)?;
    let bytes: [u8; ADDR_LEN] = bytes.try_into().or(Err(AddressError::InvalidBech32Len))?;

    if hrp.to_string() != HRP {
        return Err(AddressError::InvalidHRP);
    }

    Ok(bytes)
}

pub fn to_zil_bech32(value: &[u8; ADDR_LEN]) -> Result<String, AddressError> {
    let hrp = Hrp::parse(HRP).map_err(|_| AddressError::InvalidHRP)?;

    bech32::encode::<Bech32>(hrp, value).map_err(|_| AddressError::InvalidBech32Len)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_from_bech32_address() {
        let bech32 = "zil1w7f636xqn5vf6n2zrnjmckekw3jkckkpyrd6z8";
        let base16_buff = from_zil_bech32_address(bech32).unwrap();
        let base16 = hex::encode(base16_buff);

        assert_eq!(base16, "7793a8e8c09d189d4d421ce5bc5b3674656c5ac1");

        let base16_buff = from_zil_bech32_address("zi21w7f636xqn5vf6n2zrnjmckekw3jkckkpyrd6z8");

        assert_eq!(base16_buff, Err(AddressError::InvalidBech32Len));
    }

    #[test]
    fn test_to_bech32_address() {
        let bech32 = "zil1w7f636xqn5vf6n2zrnjmckekw3jkckkpyrd6z8";
        let addr = from_zil_base16("7793a8e8c09d189d4d421ce5bc5b3674656c5ac1").unwrap();

        assert_eq!(bech32, to_zil_bech32(&addr).unwrap());
    }

    #[test]
    fn test_addr_from_pubkey() {
        let pubkey =
            hex::decode("03150a7f37063b134cde30070431a69148d60b252f4c7b38de33d813d329a7b7da")
                .unwrap();
        let addr = from_zil_pub_key(&pubkey).unwrap();

        assert_eq!(
            to_zil_bech32(&addr).unwrap(),
            "zil1a0vtxuxamd3kltmyzpqdyxqu25vsss8mp58jtu"
        );
    }

    #[test]
    fn test_to_checksum_address() {
        let addr = "8617b72e22090f0c13167865147ec48a6db788ff";
        let check_sum_addr = to_checksum_address(addr).unwrap();

        assert_eq!(check_sum_addr, "0x8617B72E22090f0c13167865147eC48a6dB788ff");
    }
}

================
File: proto/src/zil_tx.rs
================
use std::{
    fmt::{Display, Formatter},
    ops::Sub,
    str::FromStr,
};

use crate::pubkey::PubKey;
use crate::{
    address::Address,
    zq1_proto::{Code, Data, Nonce, ProtoTransactionCoreInfo},
};
use serde::{Deserialize, Deserializer, Serialize, Serializer};

pub const EVM_GAS_PER_SCILLA_GAS: u64 = 420;

pub fn version_from_chainid(chain_id: u16) -> u32 {
    ((chain_id as u32) << 16) | 0x0001
}

pub fn encode_zilliqa_transaction(txn: &ZILTransactionRequest, pub_key: &PubKey) -> Vec<u8> {
    let oneof8 = (!txn.code.is_empty()).then_some(Code::Code(txn.code.clone().into_bytes()));
    let oneof9 = (!txn.data.is_empty()).then_some(Data::Data(txn.data.clone().into_bytes()));
    let proto = ProtoTransactionCoreInfo {
        version: version_from_chainid(txn.chain_id),
        toaddr: txn.to_addr.addr_bytes().to_vec(),
        senderpubkey: Some(pub_key.as_ref().to_vec().into()),
        amount: Some((txn.amount).to_be_bytes().to_vec().into()),
        gasprice: Some((txn.gas_price).to_be_bytes().to_vec().into()),
        gaslimit: txn.gas_limit.0,
        oneof2: Some(Nonce::Nonce(txn.nonce)),
        oneof8,
        oneof9,
    };

    prost::Message::encode_to_vec(&proto)
}

impl ScillaGas {
    pub fn checked_sub(self, rhs: ScillaGas) -> Option<ScillaGas> {
        Some(ScillaGas(self.0.checked_sub(rhs.0)?))
    }
}

impl Sub for ScillaGas {
    type Output = ScillaGas;

    fn sub(self, rhs: Self) -> Self::Output {
        self.checked_sub(rhs).expect("scilla gas underflow")
    }
}

impl Display for ScillaGas {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

impl FromStr for ScillaGas {
    type Err = <u64 as FromStr>::Err;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self(u64::from_str(s)?))
    }
}

/// A quantity of Scilla gas. This is the currency used to pay for [TxZilliqa] transactions. When EVM gas is converted
/// to Scilla gas, the quantity is rounded down.
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Default)]
pub struct ScillaGas(pub u64);

impl Serialize for ScillaGas {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.0.to_string())
    }
}

impl<'de> Deserialize<'de> for ScillaGas {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        let value = s.parse().map_err(serde::de::Error::custom)?;

        Ok(ScillaGas(value))
    }
}

/// A wrapper for ZIL amounts in the Zilliqa API. These are represented in units of (10^-12) ZILs, rather than (10^-18)
/// like in the rest of our code. The implementations of [Serialize], [Deserialize], [Display] and [FromStr] represent
/// the amount in units of (10^-12) ZILs, so this type can be used in the Zilliqa API layer.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]
pub struct ZilAmount(pub u128);

impl ZilAmount {
    /// Construct a [ZilAmount] from an amount in (10^-18) ZILs. The value will be truncated and rounded down.
    pub fn from_amount(amount: u128) -> ZilAmount {
        ZilAmount(amount / 10u128.pow(6))
    }

    // Construct a [ZilAmount] from an amount in (10^-12) ZILs.
    pub fn from_raw(amount: u128) -> ZilAmount {
        ZilAmount(amount)
    }

    /// Get the ZIL amount in units of (10^-18) ZILs.
    pub fn get(self) -> u128 {
        self.0.checked_mul(10u128.pow(6)).expect("amount overflow")
    }

    /// Return the memory representation of this amount as a big-endian byte array.
    pub fn to_be_bytes(self) -> [u8; 16] {
        self.0.to_be_bytes()
    }
}

impl Serialize for ZilAmount {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.0.to_string())
    }
}

impl<'de> Deserialize<'de> for ZilAmount {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        let value: u128 = s.parse().map_err(serde::de::Error::custom)?;

        Ok(ZilAmount::from_raw(value))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct ZILTransactionRequest {
    pub chain_id: u16,
    pub nonce: u64,
    pub gas_price: ZilAmount,
    pub gas_limit: ScillaGas,
    pub to_addr: Address,
    pub amount: ZilAmount,
    pub code: String,
    pub data: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct ZILTransactionReceipt {
    pub version: u32,
    pub nonce: u64,
    #[serde(default, rename = "gasPrice")]
    pub gas_price: ZilAmount,
    #[serde(default, rename = "gasLimit")]
    pub gas_limit: ScillaGas,
    #[serde(default, rename = "toAddr")]
    pub to_addr: String,
    pub amount: ZilAmount,
    #[serde(default, rename = "pubKey")]
    pub pub_key: String,
    pub code: String,
    pub data: String,
    pub signature: String,
    pub priority: bool,
}

================
File: proto/src/zilliqa_message.rs
================
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ByteArray {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Used in database "blockLinks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoBlockLink {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "5")]
    pub blockhash: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "proto_block_link::Oneof1", tags = "1")]
    pub oneof1: ::core::option::Option<proto_block_link::Oneof1>,
    #[prost(oneof = "proto_block_link::Oneof2", tags = "2")]
    pub oneof2: ::core::option::Option<proto_block_link::Oneof2>,
    #[prost(oneof = "proto_block_link::Oneof3", tags = "3")]
    pub oneof3: ::core::option::Option<proto_block_link::Oneof3>,
    #[prost(oneof = "proto_block_link::Oneof4", tags = "4")]
    pub oneof4: ::core::option::Option<proto_block_link::Oneof4>,
}
/// Nested message and enum types in `ProtoBlockLink`.
pub mod proto_block_link {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof1 {
        #[prost(uint32, tag = "1")]
        Version(u32),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof2 {
        #[prost(uint64, tag = "2")]
        Index(u64),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof3 {
        #[prost(uint64, tag = "3")]
        Dsindex(u64),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof4 {
        #[prost(uint32, tag = "4")]
        Blocktype(u32),
    }
}
/// Used in databases "dsBlocks", "microBlocks", "txBlocks", "VCBlocks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoBlockBase {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "1")]
    pub blockhash: ::prost::alloc::vec::Vec<u8>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "2")]
    pub cosigs: ::core::option::Option<proto_block_base::CoSignatures>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(uint64, tag = "3")]
    pub timestamp: u64,
}
/// Nested message and enum types in `ProtoBlockBase`.
pub mod proto_block_base {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CoSignatures {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "1")]
        pub cs1: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bool, repeated, tag = "2")]
        pub b1: ::prost::alloc::vec::Vec<bool>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "3")]
        pub cs2: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bool, repeated, tag = "4")]
        pub b2: ::prost::alloc::vec::Vec<bool>,
    }
}
/// Used in "dsBlockHeader", "microBlockHeader", "txBlockHeader", and "VCBlockHeader"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoBlockHeaderBase {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "2")]
    pub committeehash: ::prost::alloc::vec::Vec<u8>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "3")]
    pub prevhash: ::prost::alloc::vec::Vec<u8>,
}
/// Used in database "dsBlocks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoDsBlock {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<proto_ds_block::DsBlockHeader>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "2")]
    pub blockbase: ::core::option::Option<ProtoBlockBase>,
}
/// Nested message and enum types in `ProtoDSBlock`.
pub mod proto_ds_block {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DsBlockHashSet {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "1")]
        pub shardinghash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "2")]
        pub reservedfield: ::prost::alloc::vec::Vec<u8>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DsBlockHeader {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "1")]
        pub blockheaderbase: ::core::option::Option<super::ProtoBlockHeaderBase>,
        /// Added in: v1.0, Deprecated in: N/A, Only LSB used
        #[prost(uint32, tag = "2")]
        pub dsdifficulty: u32,
        /// Added in: v1.0, Deprecated in: N/A, Only LSB used
        #[prost(uint32, tag = "3")]
        pub difficulty: u32,
        /// Added in: v1.0, Deprecated in: N/A, 32 bytes
        #[prost(bytes = "vec", tag = "4")]
        pub prevhash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "5")]
        pub leaderpubkey: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "8")]
        pub gasprice: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "9")]
        pub swinfo: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, repeated, tag = "10")]
        pub dswinners: ::prost::alloc::vec::Vec<ds_block_header::PowDsWinners>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "11")]
        pub hash: ::core::option::Option<DsBlockHashSet>,
        /// Added in: v2.0, Deprecated in: N/A
        #[prost(message, repeated, tag = "12")]
        pub dsremoved: ::prost::alloc::vec::Vec<super::ByteArray>,
        #[prost(message, repeated, tag = "13")]
        pub proposals: ::prost::alloc::vec::Vec<ds_block_header::Proposal>,
        #[prost(oneof = "ds_block_header::Oneof6", tags = "6")]
        pub oneof6: ::core::option::Option<ds_block_header::Oneof6>,
        #[prost(oneof = "ds_block_header::Oneof7", tags = "7")]
        pub oneof7: ::core::option::Option<ds_block_header::Oneof7>,
    }
    /// Nested message and enum types in `DSBlockHeader`.
    pub mod ds_block_header {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PowDsWinners {
            /// Added in: v1.0, Deprecated in: N/A
            #[prost(message, optional, tag = "1")]
            pub key: ::core::option::Option<super::super::ByteArray>,
            /// Added in: v1.0, Deprecated in: N/A
            #[prost(message, optional, tag = "2")]
            pub val: ::core::option::Option<super::super::ByteArray>,
        }
        /// Add new members here
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Vote {
            #[prost(uint32, tag = "1")]
            pub value: u32,
            #[prost(uint32, tag = "2")]
            pub count: u32,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Proposal {
            #[prost(uint32, tag = "1")]
            pub proposalid: u32,
            #[prost(message, repeated, tag = "2")]
            pub dsvotes: ::prost::alloc::vec::Vec<Vote>,
            #[prost(message, repeated, tag = "3")]
            pub minervotes: ::prost::alloc::vec::Vec<Vote>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof6 {
            #[prost(uint64, tag = "6")]
            Blocknum(u64),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof7 {
            #[prost(uint64, tag = "7")]
            Epochnum(u64),
        }
    }
}
/// Used in database "dsCommittee"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoDsNode {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub pubkey: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "2")]
    pub peer: ::core::option::Option<ByteArray>,
}
/// Used in database "dsCommittee"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoDsCommittee {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, repeated, tag = "2")]
    pub dsnodes: ::prost::alloc::vec::Vec<ProtoDsNode>,
}
/// Used in database "microBlocks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoMicroBlock {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<proto_micro_block::MicroBlockHeader>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub tranhashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "3")]
    pub blockbase: ::core::option::Option<ProtoBlockBase>,
}
/// Nested message and enum types in `ProtoMicroBlock`.
pub mod proto_micro_block {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MicroBlockHeader {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "1")]
        pub blockheaderbase: ::core::option::Option<super::ProtoBlockHeaderBase>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(uint64, tag = "3")]
        pub gaslimit: u64,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "5")]
        pub rewards: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "6")]
        pub prevhash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "8")]
        pub txroothash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "10")]
        pub minerpubkey: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(uint64, tag = "11")]
        pub dsblocknum: u64,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "12")]
        pub statedeltahash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "13")]
        pub tranreceipthash: ::prost::alloc::vec::Vec<u8>,
        #[prost(oneof = "micro_block_header::Oneof2", tags = "2")]
        pub oneof2: ::core::option::Option<micro_block_header::Oneof2>,
        #[prost(oneof = "micro_block_header::Oneof4", tags = "4")]
        pub oneof4: ::core::option::Option<micro_block_header::Oneof4>,
        #[prost(oneof = "micro_block_header::Oneof7", tags = "7")]
        pub oneof7: ::core::option::Option<micro_block_header::Oneof7>,
        #[prost(oneof = "micro_block_header::Oneof9", tags = "9")]
        pub oneof9: ::core::option::Option<micro_block_header::Oneof9>,
    }
    /// Nested message and enum types in `MicroBlockHeader`.
    pub mod micro_block_header {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof2 {
            #[prost(uint32, tag = "2")]
            Shardid(u32),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof4 {
            #[prost(uint64, tag = "4")]
            Gasused(u64),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof7 {
            #[prost(uint64, tag = "7")]
            Epochnum(u64),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof9 {
            #[prost(uint32, tag = "9")]
            Numtxs(u32),
        }
    }
}
/// Used in database "shardStructure"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoShardingStructure {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, repeated, tag = "2")]
    pub shards: ::prost::alloc::vec::Vec<proto_sharding_structure::Shard>,
}
/// Nested message and enum types in `ProtoShardingStructure`.
pub mod proto_sharding_structure {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Member {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "1")]
        pub pubkey: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "2")]
        pub peerinfo: ::core::option::Option<super::ByteArray>,
        #[prost(oneof = "member::Oneof3", tags = "3")]
        pub oneof3: ::core::option::Option<member::Oneof3>,
    }
    /// Nested message and enum types in `Member`.
    pub mod member {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof3 {
            #[prost(uint32, tag = "3")]
            Reputation(u32),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Shard {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, repeated, tag = "1")]
        pub members: ::prost::alloc::vec::Vec<Member>,
    }
}
/// Used in database "txBlocks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoMbInfo {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "1")]
    pub mbhash: ::prost::alloc::vec::Vec<u8>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "2")]
    pub txroot: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "proto_mb_info::Oneof3", tags = "3")]
    pub oneof3: ::core::option::Option<proto_mb_info::Oneof3>,
}
/// Nested message and enum types in `ProtoMbInfo`.
pub mod proto_mb_info {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof3 {
        #[prost(uint32, tag = "3")]
        Shardid(u32),
    }
}
/// Used in database "txBlocks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTxBlock {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<proto_tx_block::TxBlockHeader>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, repeated, tag = "2")]
    pub mbinfos: ::prost::alloc::vec::Vec<ProtoMbInfo>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "3")]
    pub blockbase: ::core::option::Option<ProtoBlockBase>,
}
/// Nested message and enum types in `ProtoTxBlock`.
pub mod proto_tx_block {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TxBlockHashSet {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "1")]
        pub stateroothash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "2")]
        pub statedeltahash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "3")]
        pub mbinfohash: ::prost::alloc::vec::Vec<u8>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TxBlockHeader {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "1")]
        pub blockheaderbase: ::core::option::Option<super::ProtoBlockHeaderBase>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(uint64, tag = "2")]
        pub gaslimit: u64,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "4")]
        pub rewards: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "5")]
        pub prevhash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "7")]
        pub hash: ::core::option::Option<TxBlockHashSet>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "9")]
        pub minerpubkey: ::core::option::Option<super::ByteArray>,
        #[prost(oneof = "tx_block_header::Oneof3", tags = "3")]
        pub oneof3: ::core::option::Option<tx_block_header::Oneof3>,
        #[prost(oneof = "tx_block_header::Oneof6", tags = "6")]
        pub oneof6: ::core::option::Option<tx_block_header::Oneof6>,
        #[prost(oneof = "tx_block_header::Oneof8", tags = "8")]
        pub oneof8: ::core::option::Option<tx_block_header::Oneof8>,
        #[prost(oneof = "tx_block_header::Oneof10", tags = "10")]
        pub oneof10: ::core::option::Option<tx_block_header::Oneof10>,
    }
    /// Nested message and enum types in `TxBlockHeader`.
    pub mod tx_block_header {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof3 {
            #[prost(uint64, tag = "3")]
            Gasused(u64),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof6 {
            #[prost(uint64, tag = "6")]
            Blocknum(u64),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof8 {
            #[prost(uint32, tag = "8")]
            Numtxs(u32),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof10 {
            #[prost(uint64, tag = "10")]
            Dsblocknum(u64),
        }
    }
}
/// Used in database "VCBlocks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoVcBlock {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<proto_vc_block::VcBlockHeader>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "2")]
    pub blockbase: ::core::option::Option<ProtoBlockBase>,
}
/// Nested message and enum types in `ProtoVCBlock`.
pub mod proto_vc_block {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VcBlockHeader {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "1")]
        pub blockheaderbase: ::core::option::Option<super::ProtoBlockHeaderBase>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(uint64, tag = "2")]
        pub viewchangedsepochno: u64,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(uint64, tag = "3")]
        pub viewchangeepochno: u64,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "5")]
        pub candidateleadernetworkinfo: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "6")]
        pub candidateleaderpubkey: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, repeated, tag = "8")]
        pub faultyleaders: ::prost::alloc::vec::Vec<super::ProtoDsNode>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "9")]
        pub prevhash: ::prost::alloc::vec::Vec<u8>,
        #[prost(oneof = "vc_block_header::Oneof4", tags = "4")]
        pub oneof4: ::core::option::Option<vc_block_header::Oneof4>,
        #[prost(oneof = "vc_block_header::Oneof7", tags = "7")]
        pub oneof7: ::core::option::Option<vc_block_header::Oneof7>,
    }
    /// Nested message and enum types in `VCBlockHeader`.
    pub mod vc_block_header {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof4 {
            #[prost(uint32, tag = "4")]
            Viewchangestate(u32),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof7 {
            #[prost(uint32, tag = "7")]
            Vccounter(u32),
        }
    }
}
/// Used in database "diagnosticNodes"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoDiagnosticDataNodes {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub shards: ::core::option::Option<ProtoShardingStructure>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "2")]
    pub dscommittee: ::core::option::Option<ProtoDsCommittee>,
}
/// Used in database "diagnosticCoinb"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoDiagnosticDataCoinbase {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub nodecount: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "2")]
    pub sigcount: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(uint32, tag = "3")]
    pub lookupcount: u32,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "4")]
    pub totalreward: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "5")]
    pub basereward: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "6")]
    pub baserewardeach: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "7")]
    pub lookupreward: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "8")]
    pub rewardeachlookup: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "9")]
    pub nodereward: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "10")]
    pub rewardeach: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "11")]
    pub balanceleft: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "12")]
    pub luckydrawwinnerkey: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "13")]
    pub luckydrawwinneraddr: ::prost::alloc::vec::Vec<u8>,
}
/// Used in database "minerInfoDSComm"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoMinerInfoDsComm {
    #[prost(message, repeated, tag = "1")]
    pub dsnodes: ::prost::alloc::vec::Vec<proto_miner_info_ds_comm::Node>,
    /// Add new members here
    #[prost(message, repeated, tag = "2")]
    pub dsnodesejected: ::prost::alloc::vec::Vec<proto_miner_info_ds_comm::Node>,
}
/// Nested message and enum types in `ProtoMinerInfoDSComm`.
pub mod proto_miner_info_ds_comm {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Node {
        #[prost(message, optional, tag = "1")]
        pub pubkey: ::core::option::Option<super::ByteArray>,
    }
}
/// Used in database "minerInfoShards"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoMinerInfoShards {
    /// Add new members here
    #[prost(message, repeated, tag = "1")]
    pub shards: ::prost::alloc::vec::Vec<proto_miner_info_shards::Shard>,
}
/// Nested message and enum types in `ProtoMinerInfoShards`.
pub mod proto_miner_info_shards {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Node {
        #[prost(message, optional, tag = "1")]
        pub pubkey: ::core::option::Option<super::ByteArray>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Shard {
        #[prost(uint32, tag = "1")]
        pub shardsize: u32,
        #[prost(message, repeated, tag = "2")]
        pub shardnodes: ::prost::alloc::vec::Vec<Node>,
    }
}
/// Used in database "microBlocks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoMicroBlockKey {
    #[prost(uint64, tag = "1")]
    pub epochnum: u64,
    #[prost(uint32, tag = "2")]
    pub shardid: u32,
}
/// Used in database "txEpochs"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTxEpoch {
    #[prost(uint64, tag = "1")]
    pub epochnum: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoAccountBase {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "2")]
    pub balance: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "4")]
    pub codehash: ::prost::alloc::vec::Vec<u8>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "5")]
    pub storageroot: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "proto_account_base::Oneof3", tags = "3")]
    pub oneof3: ::core::option::Option<proto_account_base::Oneof3>,
}
/// Nested message and enum types in `ProtoAccountBase`.
pub mod proto_account_base {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof3 {
        #[prost(uint64, tag = "3")]
        Nonce(u64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoAccount {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub base: ::core::option::Option<ProtoAccountBase>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "2")]
    pub code: ::prost::alloc::vec::Vec<u8>,
    /// For account delta (false=neg, true=pos) // Added in: v1.0, Deprecated in: N/A
    #[prost(bool, tag = "4")]
    pub numbersign: bool,
    /// Added in: v1.1, Deprecated in: N/A
    #[prost(message, repeated, tag = "5")]
    pub storage2: ::prost::alloc::vec::Vec<proto_account::StorageData2>,
    /// Added in: v1.1, Deprecated in: N/A
    #[prost(string, repeated, tag = "6")]
    pub todelete: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Added in: v1.1, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "7")]
    pub initdata: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `ProtoAccount`.
pub mod proto_account {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StorageData2 {
        /// Added in: v1.1, Deprecated in: N/A
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        /// Added in: v1.1, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "2")]
        pub data: ::prost::alloc::vec::Vec<u8>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoStateIndex {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub index: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoStateData {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(string, tag = "2")]
    pub vname: ::prost::alloc::string::String,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bool, tag = "3")]
    pub ismutable: bool,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(string, tag = "4")]
    pub r#type: ::prost::alloc::string::String,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(string, tag = "5")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoAccountStore {
    #[prost(message, repeated, tag = "3")]
    pub entries: ::prost::alloc::vec::Vec<proto_account_store::AddressAccount>,
}
/// Nested message and enum types in `ProtoAccountStore`.
pub mod proto_account_store {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddressAccount {
        #[prost(bytes = "vec", tag = "1")]
        pub address: ::prost::alloc::vec::Vec<u8>,
        #[prost(message, optional, tag = "2")]
        pub account: ::core::option::Option<super::ProtoAccount>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoPeer {
    #[prost(message, optional, tag = "1")]
    pub ipaddress: ::core::option::Option<ByteArray>,
    #[prost(oneof = "proto_peer::Oneof2", tags = "2")]
    pub oneof2: ::core::option::Option<proto_peer::Oneof2>,
}
/// Nested message and enum types in `ProtoPeer`.
pub mod proto_peer {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof2 {
        #[prost(uint32, tag = "2")]
        Listenporthost(u32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoPoWSolution {
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub result: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub mixhash: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub gasprice: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "6")]
    pub govdata: ::core::option::Option<GovernanceData>,
    #[prost(bytes = "vec", tag = "7")]
    pub extradata: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "proto_po_w_solution::Oneof4", tags = "4")]
    pub oneof4: ::core::option::Option<proto_po_w_solution::Oneof4>,
}
/// Nested message and enum types in `ProtoPoWSolution`.
pub mod proto_po_w_solution {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof4 {
        #[prost(uint32, tag = "4")]
        Lookupid(u32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoCommittee {
    #[prost(message, repeated, tag = "1")]
    pub members: ::prost::alloc::vec::Vec<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoShardingStructureWithPoWSolns {
    #[prost(message, repeated, tag = "1")]
    pub shards: ::prost::alloc::vec::Vec<
        proto_sharding_structure_with_po_w_solns::Shard,
    >,
}
/// Nested message and enum types in `ProtoShardingStructureWithPoWSolns`.
pub mod proto_sharding_structure_with_po_w_solns {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Member {
        #[prost(message, optional, tag = "1")]
        pub pubkey: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "2")]
        pub peerinfo: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "4")]
        pub powsoln: ::core::option::Option<super::ProtoPoWSolution>,
        #[prost(oneof = "member::Oneof3", tags = "3")]
        pub oneof3: ::core::option::Option<member::Oneof3>,
    }
    /// Nested message and enum types in `Member`.
    pub mod member {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof3 {
            #[prost(uint32, tag = "3")]
            Reputation(u32),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Shard {
        #[prost(message, repeated, tag = "1")]
        pub members: ::prost::alloc::vec::Vec<Member>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoDsWinnerPoW {
    #[prost(message, optional, tag = "1")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "2")]
    pub powsoln: ::core::option::Option<ProtoPoWSolution>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTransactionCoreInfo {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    #[prost(bytes = "vec", tag = "3")]
    pub toaddr: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "4")]
    pub senderpubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "5")]
    pub amount: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "6")]
    pub gasprice: ::core::option::Option<ByteArray>,
    #[prost(uint64, tag = "7")]
    pub gaslimit: u64,
    #[prost(message, repeated, tag = "10")]
    pub access_list: ::prost::alloc::vec::Vec<AccessListItem>,
    #[prost(message, optional, tag = "11")]
    pub maxpriorityfeepergas: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "12")]
    pub maxfeepergas: ::core::option::Option<ByteArray>,
    #[prost(oneof = "proto_transaction_core_info::Oneof2", tags = "2")]
    pub oneof2: ::core::option::Option<proto_transaction_core_info::Oneof2>,
    #[prost(oneof = "proto_transaction_core_info::Oneof8", tags = "8")]
    pub oneof8: ::core::option::Option<proto_transaction_core_info::Oneof8>,
    #[prost(oneof = "proto_transaction_core_info::Oneof9", tags = "9")]
    pub oneof9: ::core::option::Option<proto_transaction_core_info::Oneof9>,
}
/// Nested message and enum types in `ProtoTransactionCoreInfo`.
pub mod proto_transaction_core_info {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof2 {
        #[prost(uint64, tag = "2")]
        Nonce(u64),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof8 {
        #[prost(bytes, tag = "8")]
        Code(::prost::alloc::vec::Vec<u8>),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof9 {
        #[prost(bytes, tag = "9")]
        Data(::prost::alloc::vec::Vec<u8>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessListItem {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub storagekeys: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTransaction {
    #[prost(bytes = "vec", tag = "1")]
    pub tranid: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub info: ::core::option::Option<ProtoTransactionCoreInfo>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTxnFileOffset {
    #[prost(uint32, repeated, tag = "1")]
    pub offsetinfile: ::prost::alloc::vec::Vec<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTransactionArray {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<ProtoTransaction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTransactionReceipt {
    #[prost(bytes = "vec", tag = "1")]
    pub receipt: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "proto_transaction_receipt::Oneof2", tags = "2")]
    pub oneof2: ::core::option::Option<proto_transaction_receipt::Oneof2>,
}
/// Nested message and enum types in `ProtoTransactionReceipt`.
pub mod proto_transaction_receipt {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof2 {
        #[prost(uint64, tag = "2")]
        Cumgas(u64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTransactionWithReceipt {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<ProtoTransaction>,
    #[prost(message, optional, tag = "2")]
    pub receipt: ::core::option::Option<ProtoTransactionReceipt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoBloomFilter {
    #[prost(uint32, repeated, tag = "1")]
    pub salt: ::prost::alloc::vec::Vec<u32>,
    #[prost(bytes = "vec", tag = "2")]
    pub bittable: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "3")]
    pub saltcount: u32,
    #[prost(uint64, tag = "4")]
    pub tablesize: u64,
    #[prost(uint64, tag = "5")]
    pub projectedelementcount: u64,
    #[prost(uint64, tag = "6")]
    pub insertedelementcount: u64,
    #[prost(uint64, tag = "7")]
    pub randomseed: u64,
    #[prost(double, tag = "8")]
    pub probability: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoSwInfo {
    #[prost(uint32, tag = "1")]
    pub zilliqamajorversion: u32,
    #[prost(uint32, tag = "2")]
    pub zilliqaminorversion: u32,
    #[prost(uint32, tag = "3")]
    pub zilliqafixversion: u32,
    #[prost(uint64, tag = "4")]
    pub zilliqaupgradeds: u64,
    #[prost(uint32, tag = "5")]
    pub zilliqacommit: u32,
    #[prost(uint32, tag = "6")]
    pub scillamajorversion: u32,
    #[prost(uint32, tag = "7")]
    pub scillaminorversion: u32,
    #[prost(uint32, tag = "8")]
    pub scillafixversion: u32,
    #[prost(uint64, tag = "9")]
    pub scillaupgradeds: u64,
    #[prost(uint32, tag = "10")]
    pub scillacommit: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoSingleDirectoryBlock {
    #[prost(oneof = "proto_single_directory_block::Directoryblock", tags = "1, 2")]
    pub directoryblock: ::core::option::Option<
        proto_single_directory_block::Directoryblock,
    >,
}
/// Nested message and enum types in `ProtoSingleDirectoryBlock`.
pub mod proto_single_directory_block {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Directoryblock {
        #[prost(message, tag = "1")]
        Dsblock(super::ProtoDsBlock),
        #[prost(message, tag = "2")]
        Vcblock(super::ProtoVcBlock),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PmHello {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<pm_hello::Data>,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `PMHello`.
pub mod pm_hello {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, optional, tag = "1")]
        pub pubkey: ::core::option::Option<super::ByteArray>,
        #[prost(uint32, tag = "2")]
        pub listenport: u32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GovernanceData {
    #[prost(uint32, tag = "1")]
    pub proposalid: u32,
    #[prost(uint32, tag = "2")]
    pub votevalue: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsPoWSubmission {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ds_po_w_submission::Data>,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `DSPoWSubmission`.
pub mod ds_po_w_submission {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub blocknumber: u64,
        /// only LSB used
        #[prost(uint32, tag = "2")]
        pub difficultylevel: u32,
        #[prost(message, optional, tag = "3")]
        pub submitterpeer: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "4")]
        pub submitterpub_key: ::core::option::Option<super::ByteArray>,
        #[prost(uint64, tag = "5")]
        pub nonce: u64,
        #[prost(string, tag = "6")]
        pub resultinghash: ::prost::alloc::string::String,
        #[prost(string, tag = "7")]
        pub mixhash: ::prost::alloc::string::String,
        #[prost(uint32, tag = "8")]
        pub lookupid: u32,
        #[prost(message, optional, tag = "9")]
        pub gasprice: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "10")]
        pub govdata: ::core::option::Option<super::GovernanceData>,
        #[prost(string, tag = "11")]
        pub version: ::prost::alloc::string::String,
        #[prost(bytes = "vec", tag = "12")]
        pub extra_data: ::prost::alloc::vec::Vec<u8>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsPoWPacketSubmission {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ds_po_w_packet_submission::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `DSPoWPacketSubmission`.
pub mod ds_po_w_packet_submission {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, repeated, tag = "1")]
        pub ds_pow_submissions: ::prost::alloc::vec::Vec<super::DsPoWSubmission>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsMicroBlockSubmission {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ds_micro_block_submission::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `DSMicroBlockSubmission`.
pub mod ds_micro_block_submission {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        /// only LSB used
        #[prost(uint32, tag = "1")]
        pub microblocktype: u32,
        #[prost(uint64, tag = "2")]
        pub epochnumber: u64,
        #[prost(message, repeated, tag = "3")]
        pub microblocks: ::prost::alloc::vec::Vec<super::ProtoMicroBlock>,
        #[prost(bytes = "vec", repeated, tag = "4")]
        pub statedeltas: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsdsBlockAnnouncement {
    #[prost(message, optional, tag = "1")]
    pub dsblock: ::core::option::Option<ProtoDsBlock>,
    #[prost(message, optional, tag = "2")]
    pub sharding: ::core::option::Option<ProtoShardingStructureWithPoWSolns>,
    #[prost(message, repeated, tag = "3")]
    pub dswinnerpows: ::prost::alloc::vec::Vec<ProtoDsWinnerPoW>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsFinalBlockAnnouncement {
    #[prost(message, optional, tag = "1")]
    pub txblock: ::core::option::Option<ProtoTxBlock>,
    #[prost(message, optional, tag = "2")]
    pub microblock: ::core::option::Option<ProtoMicroBlock>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsvcBlockAnnouncement {
    #[prost(message, optional, tag = "1")]
    pub vcblock: ::core::option::Option<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsMissingMicroBlocksErrorMsg {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub mbhashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, tag = "2")]
    pub epochnum: u64,
    #[prost(uint32, tag = "3")]
    pub listenport: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeDsBlock {
    #[prost(uint32, tag = "1")]
    pub shardid: u32,
    #[prost(message, optional, tag = "2")]
    pub dsblock: ::core::option::Option<ProtoDsBlock>,
    #[prost(message, repeated, tag = "3")]
    pub vcblocks: ::prost::alloc::vec::Vec<ProtoVcBlock>,
    #[prost(message, optional, tag = "4")]
    pub sharding: ::core::option::Option<ProtoShardingStructure>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeFinalBlock {
    #[prost(uint64, tag = "1")]
    pub dsblocknumber: u64,
    #[prost(uint32, tag = "2")]
    pub consensusid: u32,
    #[prost(message, optional, tag = "3")]
    pub txblock: ::core::option::Option<ProtoTxBlock>,
    #[prost(bytes = "vec", tag = "4")]
    pub statedelta: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, repeated, tag = "5")]
    pub shardids: ::prost::alloc::vec::Vec<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeVcFinalBlock {
    #[prost(uint64, tag = "1")]
    pub dsblocknumber: u64,
    #[prost(uint32, tag = "2")]
    pub consensusid: u32,
    #[prost(message, optional, tag = "3")]
    pub txblock: ::core::option::Option<ProtoTxBlock>,
    #[prost(bytes = "vec", tag = "4")]
    pub statedelta: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "5")]
    pub vcblocks: ::prost::alloc::vec::Vec<ProtoVcBlock>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeMBnForwardTransaction {
    #[prost(message, optional, tag = "1")]
    pub microblock: ::core::option::Option<ProtoMicroBlock>,
    #[prost(message, repeated, tag = "2")]
    pub txnswithreceipt: ::prost::alloc::vec::Vec<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodePendingTxn {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<node_pending_txn::Data>,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `NodePendingTxn`.
pub mod node_pending_txn {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, repeated, tag = "1")]
        pub hashcodepair: ::prost::alloc::vec::Vec<data::Pair>,
        #[prost(uint64, tag = "2")]
        pub epochnumber: u64,
        #[prost(uint32, tag = "3")]
        pub shardid: u32,
        #[prost(message, optional, tag = "4")]
        pub pubkey: ::core::option::Option<super::ByteArray>,
        #[prost(bytes = "vec", tag = "5")]
        pub txnlisthash: ::prost::alloc::vec::Vec<u8>,
    }
    /// Nested message and enum types in `Data`.
    pub mod data {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Pair {
            #[prost(bytes = "vec", tag = "1")]
            pub txnhash: ::prost::alloc::vec::Vec<u8>,
            #[prost(uint32, tag = "2")]
            pub code: u32,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeVcBlock {
    #[prost(message, optional, tag = "1")]
    pub vcblock: ::core::option::Option<ProtoVcBlock>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeForwardTxnBlock {
    #[prost(uint64, tag = "1")]
    pub epochnumber: u64,
    #[prost(uint64, tag = "2")]
    pub dsblocknum: u64,
    #[prost(uint32, tag = "3")]
    pub shardid: u32,
    #[prost(message, optional, tag = "4")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, repeated, tag = "5")]
    pub transactions: ::prost::alloc::vec::Vec<ProtoTransaction>,
    #[prost(message, optional, tag = "6")]
    pub signature: ::core::option::Option<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeMicroBlockAnnouncement {
    #[prost(message, optional, tag = "1")]
    pub microblock: ::core::option::Option<ProtoMicroBlock>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeMissingTxnsErrorMsg {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub txnhashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, tag = "2")]
    pub epochnum: u64,
    #[prost(uint32, tag = "3")]
    pub listenport: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGetVersion {
    #[prost(uint32, tag = "1")]
    pub listenport: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeSetVersion {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetSeedPeers {
    #[prost(uint32, tag = "1")]
    pub listenport: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetSeedPeers {
    #[prost(message, repeated, tag = "1")]
    pub candidateseeds: ::prost::alloc::vec::Vec<ByteArray>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// From normal node to lookup nodes.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetDsInfoFromSeed {
    #[prost(uint32, tag = "1")]
    pub listenport: u32,
    #[prost(bool, tag = "2")]
    pub initialds: bool,
}
/// From DS leader to lookup nodes and from lookup nodes to normal nodes.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetDsInfoFromSeed {
    #[prost(message, optional, tag = "1")]
    pub dscommittee: ::core::option::Option<ProtoDsCommittee>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
    #[prost(bool, tag = "4")]
    pub initialds: bool,
}
/// From new join lookup node or new join normal node to existing lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetDsBlockFromSeed {
    #[prost(uint64, tag = "1")]
    pub lowblocknum: u64,
    #[prost(uint64, tag = "2")]
    pub highblocknum: u64,
    #[prost(uint32, tag = "3")]
    pub listenport: u32,
    #[prost(bool, tag = "4")]
    pub includeminerinfo: bool,
}
/// From lookup nodes to new join lookup node or new join normal node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetDsBlockFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_ds_block_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetDSBlockFromSeed`.
pub mod lookup_set_ds_block_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub lowblocknum: u64,
        #[prost(uint64, tag = "2")]
        pub highblocknum: u64,
        #[prost(message, repeated, tag = "3")]
        pub dsblocks: ::prost::alloc::vec::Vec<super::ProtoDsBlock>,
    }
}
/// From lookup nodes to new join lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetMinerInfoFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_miner_info_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetMinerInfoFromSeed`.
pub mod lookup_set_miner_info_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MinerInfo {
        #[prost(message, optional, tag = "1")]
        pub minerinfodscomm: ::core::option::Option<super::ProtoMinerInfoDsComm>,
        #[prost(message, optional, tag = "2")]
        pub minerinfoshards: ::core::option::Option<super::ProtoMinerInfoShards>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(map = "uint64, message", tag = "1")]
        pub minerinfoperds: ::std::collections::HashMap<u64, MinerInfo>,
    }
}
/// From new join lookup node or new join normal node to existing lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetTxBlockFromSeed {
    #[prost(uint64, tag = "1")]
    pub lowblocknum: u64,
    #[prost(uint64, tag = "2")]
    pub highblocknum: u64,
    #[prost(uint32, tag = "3")]
    pub listenport: u32,
}
/// From lookup nodes to new join lookup node or new join normal node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetTxBlockFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_tx_block_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetTxBlockFromSeed`.
pub mod lookup_set_tx_block_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub lowblocknum: u64,
        #[prost(uint64, tag = "2")]
        pub highblocknum: u64,
        #[prost(message, repeated, tag = "3")]
        pub txblocks: ::prost::alloc::vec::Vec<super::ProtoTxBlock>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetStateDeltaFromSeed {
    #[prost(uint64, tag = "1")]
    pub blocknum: u64,
    #[prost(uint32, tag = "2")]
    pub listenport: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetStateDeltasFromSeed {
    #[prost(uint64, tag = "1")]
    pub lowblocknum: u64,
    #[prost(uint64, tag = "2")]
    pub highblocknum: u64,
    #[prost(uint32, tag = "3")]
    pub listenport: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetStateDeltaFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_state_delta_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetStateDeltaFromSeed`.
pub mod lookup_set_state_delta_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub blocknum: u64,
        #[prost(bytes = "vec", tag = "2")]
        pub statedelta: ::prost::alloc::vec::Vec<u8>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetStateDeltasFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_state_deltas_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetStateDeltasFromSeed`.
pub mod lookup_set_state_deltas_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub lowblocknum: u64,
        #[prost(uint64, tag = "2")]
        pub highblocknum: u64,
        #[prost(bytes = "vec", repeated, tag = "3")]
        pub statedeltas: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    }
}
/// msgtype is used to prevent replay attacks
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetLookupOffline {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_lookup_offline::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetLookupOffline`.
pub mod lookup_set_lookup_offline {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        /// Only LSB used
        #[prost(uint32, tag = "1")]
        pub msgtype: u32,
        #[prost(uint32, tag = "2")]
        pub listenport: u32,
    }
}
/// msgtype and blocknumber are used to prevent replay attacks
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetLookupOnline {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_lookup_online::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetLookupOnline`.
pub mod lookup_set_lookup_online {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        /// Only LSB used
        #[prost(uint32, tag = "1")]
        pub msgtype: u32,
        #[prost(uint32, tag = "2")]
        pub listenport: u32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetOfflineLookups {
    #[prost(uint32, tag = "1")]
    pub listenport: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetOfflineLookups {
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<ByteArray>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// From archival node to lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetShardsFromSeed {
    #[prost(uint32, tag = "1")]
    pub listenport: u32,
}
/// From lookup node to archival node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetShardsFromSeed {
    #[prost(message, optional, tag = "1")]
    pub sharding: ::core::option::Option<ProtoShardingStructure>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetMicroBlockFromLookup {
    #[prost(uint32, tag = "1")]
    pub portno: u32,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub mbhashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetMicroBlockFromLookup {
    #[prost(message, repeated, tag = "1")]
    pub microblocks: ::prost::alloc::vec::Vec<ProtoMicroBlock>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetMicroBlockFromL2l {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_micro_block_from_l2l::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetMicroBlockFromL2l`.
pub mod lookup_get_micro_block_from_l2l {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint32, tag = "1")]
        pub portno: u32,
        #[prost(bytes = "vec", repeated, tag = "2")]
        pub mbhashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupForwardTxnsFromSeed {
    #[prost(message, optional, tag = "1")]
    pub transactions: ::core::option::Option<ProtoTransactionArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetTxnsFromLookup {
    #[prost(uint32, tag = "1")]
    pub portno: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub mbhash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub txnhashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetTxnsFromL2l {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_txns_from_l2l::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetTxnsFromL2l`.
pub mod lookup_get_txns_from_l2l {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint32, tag = "1")]
        pub portno: u32,
        #[prost(bytes = "vec", tag = "2")]
        pub mbhash: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", repeated, tag = "3")]
        pub txnhashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetTxnsFromLookup {
    #[prost(bytes = "vec", tag = "1")]
    pub mbhash: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "2")]
    pub transactions: ::prost::alloc::vec::Vec<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "4")]
    pub signature: ::core::option::Option<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetDirectoryBlocksFromSeed {
    #[prost(uint32, tag = "1")]
    pub portno: u32,
    #[prost(uint64, tag = "2")]
    pub indexnum: u64,
    #[prost(bool, tag = "3")]
    pub includeminerinfo: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetDirectoryBlocksFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_directory_blocks_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetDirectoryBlocksFromSeed`.
pub mod lookup_set_directory_blocks_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub indexnum: u64,
        #[prost(message, repeated, tag = "2")]
        pub dirblocks: ::prost::alloc::vec::Vec<super::ProtoSingleDirectoryBlock>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusAnnouncement {
    #[prost(message, optional, tag = "1")]
    pub consensusinfo: ::core::option::Option<consensus_announcement::ConsensusInfo>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    /// The signature of the consensus info
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "9")]
    pub finalsignature: ::core::option::Option<ByteArray>,
    #[prost(oneof = "consensus_announcement::Announcement", tags = "4, 5, 6, 7")]
    pub announcement: ::core::option::Option<consensus_announcement::Announcement>,
}
/// Nested message and enum types in `ConsensusAnnouncement`.
pub mod consensus_announcement {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsensusInfo {
        #[prost(uint32, tag = "1")]
        pub consensusid: u32,
        #[prost(uint64, tag = "2")]
        pub blocknumber: u64,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub blockhash: ::prost::alloc::vec::Vec<u8>,
        /// only lower 2 bytes used
        #[prost(uint32, tag = "4")]
        pub leaderid: u32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Announcement {
        #[prost(message, tag = "4")]
        Dsblock(super::DsdsBlockAnnouncement),
        #[prost(message, tag = "5")]
        Microblock(super::NodeMicroBlockAnnouncement),
        #[prost(message, tag = "6")]
        Finalblock(super::DsFinalBlockAnnouncement),
        #[prost(message, tag = "7")]
        Vcblock(super::DsvcBlockAnnouncement),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusCommit {
    #[prost(message, optional, tag = "1")]
    pub consensusinfo: ::core::option::Option<consensus_commit::ConsensusInfo>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `ConsensusCommit`.
pub mod consensus_commit {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CommitInfo {
        #[prost(message, optional, tag = "1")]
        pub commitpoint: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "2")]
        pub commitpointhash: ::core::option::Option<super::ByteArray>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsensusInfo {
        #[prost(uint32, tag = "1")]
        pub consensusid: u32,
        #[prost(uint64, tag = "2")]
        pub blocknumber: u64,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub blockhash: ::prost::alloc::vec::Vec<u8>,
        /// only lower 2 bytes used
        #[prost(uint32, tag = "4")]
        pub backupid: u32,
        #[prost(message, repeated, tag = "5")]
        pub commitinfo: ::prost::alloc::vec::Vec<CommitInfo>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusChallenge {
    #[prost(message, optional, tag = "1")]
    pub consensusinfo: ::core::option::Option<consensus_challenge::ConsensusInfo>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `ConsensusChallenge`.
pub mod consensus_challenge {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubsetInfo {
        #[prost(message, optional, tag = "1")]
        pub aggregatedcommit: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "2")]
        pub aggregatedkey: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "3")]
        pub challenge: ::core::option::Option<super::ByteArray>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsensusInfo {
        #[prost(uint32, tag = "1")]
        pub consensusid: u32,
        #[prost(uint64, tag = "2")]
        pub blocknumber: u64,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub blockhash: ::prost::alloc::vec::Vec<u8>,
        /// only lower 2 bytes used
        #[prost(uint32, tag = "4")]
        pub leaderid: u32,
        #[prost(message, repeated, tag = "5")]
        pub subsetinfo: ::prost::alloc::vec::Vec<SubsetInfo>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusResponse {
    #[prost(message, optional, tag = "1")]
    pub consensusinfo: ::core::option::Option<consensus_response::ConsensusInfo>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `ConsensusResponse`.
pub mod consensus_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubsetInfo {
        #[prost(message, optional, tag = "1")]
        pub response: ::core::option::Option<super::ByteArray>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsensusInfo {
        #[prost(uint32, tag = "1")]
        pub consensusid: u32,
        #[prost(uint64, tag = "2")]
        pub blocknumber: u64,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub blockhash: ::prost::alloc::vec::Vec<u8>,
        /// only lower 2 byte used
        #[prost(uint32, tag = "4")]
        pub backupid: u32,
        #[prost(message, repeated, tag = "5")]
        pub subsetinfo: ::prost::alloc::vec::Vec<SubsetInfo>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusCollectiveSig {
    #[prost(message, optional, tag = "1")]
    pub consensusinfo: ::core::option::Option<consensus_collective_sig::ConsensusInfo>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
    #[prost(bytes = "vec", tag = "4")]
    pub newannouncement: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub finalsignature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `ConsensusCollectiveSig`.
pub mod consensus_collective_sig {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsensusInfo {
        #[prost(uint32, tag = "1")]
        pub consensusid: u32,
        #[prost(uint64, tag = "2")]
        pub blocknumber: u64,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub blockhash: ::prost::alloc::vec::Vec<u8>,
        /// only lower 2 bytes used
        #[prost(uint32, tag = "4")]
        pub leaderid: u32,
        #[prost(message, optional, tag = "5")]
        pub collectivesig: ::core::option::Option<super::ByteArray>,
        #[prost(bool, repeated, tag = "6")]
        pub bitmap: ::prost::alloc::vec::Vec<bool>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusCommitFailure {
    #[prost(message, optional, tag = "1")]
    pub consensusinfo: ::core::option::Option<consensus_commit_failure::ConsensusInfo>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `ConsensusCommitFailure`.
pub mod consensus_commit_failure {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsensusInfo {
        #[prost(uint32, tag = "1")]
        pub consensusid: u32,
        #[prost(uint64, tag = "2")]
        pub blocknumber: u64,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub blockhash: ::prost::alloc::vec::Vec<u8>,
        /// only lower 2 bytes used
        #[prost(uint32, tag = "4")]
        pub backupid: u32,
        #[prost(bytes = "vec", tag = "5")]
        pub errormsg: ::prost::alloc::vec::Vec<u8>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusConsensusFailure {
    #[prost(message, optional, tag = "1")]
    pub consensusinfo: ::core::option::Option<
        consensus_consensus_failure::ConsensusInfo,
    >,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `ConsensusConsensusFailure`.
pub mod consensus_consensus_failure {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsensusInfo {
        #[prost(uint32, tag = "1")]
        pub consensusid: u32,
        #[prost(uint64, tag = "2")]
        pub blocknumber: u64,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub blockhash: ::prost::alloc::vec::Vec<u8>,
        /// only lower 2 bytes used
        #[prost(uint32, tag = "4")]
        pub leaderid: u32,
    }
}
/// From node undergoing vc pre check to fetch latest blocks
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetDsTxBlockFromSeed {
    #[prost(uint64, tag = "1")]
    pub dslowblocknum: u64,
    #[prost(uint64, tag = "2")]
    pub dshighblocknum: u64,
    #[prost(uint64, tag = "3")]
    pub txlowblocknum: u64,
    #[prost(uint64, tag = "4")]
    pub txhighblocknum: u64,
    #[prost(uint32, tag = "5")]
    pub listenport: u32,
}
/// From lookup nodes to node under going vc pre check
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VcNodeSetDsTxBlockFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<vc_node_set_ds_tx_block_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `VCNodeSetDSTxBlockFromSeed`.
pub mod vc_node_set_ds_tx_block_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, repeated, tag = "1")]
        pub dsblocks: ::prost::alloc::vec::Vec<super::ProtoDsBlock>,
        #[prost(message, repeated, tag = "2")]
        pub txblocks: ::prost::alloc::vec::Vec<super::ProtoTxBlock>,
    }
}
/// From shard node to lookup/dsCommittee. New shard node network info.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeSetShardNodeNetworkInfoUpdate {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<node_set_shard_node_network_info_update::Data>,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `NodeSetShardNodeNetworkInfoUpdate`.
pub mod node_set_shard_node_network_info_update {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub dsepochnumber: u64,
        #[prost(message, optional, tag = "2")]
        pub shardnodepubkey: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "3")]
        pub shardnodenewnetworkinfo: ::core::option::Option<super::ProtoPeer>,
        #[prost(uint64, tag = "4")]
        pub timestamp: u64,
    }
}
/// From DS Guard to lookup. New DS guard node network info.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsLookupSetDsGuardNetworkInfoUpdate {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ds_lookup_set_ds_guard_network_info_update::Data>,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `DSLookupSetDSGuardNetworkInfoUpdate`.
pub mod ds_lookup_set_ds_guard_network_info_update {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub dsepochnumber: u64,
        #[prost(message, optional, tag = "2")]
        pub dsguardpubkey: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "3")]
        pub dsguardnewnetworkinfo: ::core::option::Option<super::ProtoPeer>,
        #[prost(uint64, tag = "4")]
        pub timestamp: u64,
    }
}
/// To update shard node of guard node's network info change
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGetGuardNodeNetworkInfoUpdate {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<node_get_guard_node_network_info_update::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `NodeGetGuardNodeNetworkInfoUpdate`.
pub mod node_get_guard_node_network_info_update {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint32, tag = "1")]
        pub portno: u32,
        #[prost(uint64, tag = "2")]
        pub dsepochnumber: u64,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoDsGuardUpdateStruct {
    #[prost(message, optional, tag = "1")]
    pub dsguardpubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "2")]
    pub dsguardnewnetworkinfo: ::core::option::Option<ProtoPeer>,
    #[prost(uint64, tag = "3")]
    pub timestamp: u64,
}
/// From sending New DS guard node network info to requesing shard node
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeSetGuardNodeNetworkInfoUpdate {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<node_set_guard_node_network_info_update::Data>,
    #[prost(message, optional, tag = "2")]
    pub lookuppubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `NodeSetGuardNodeNetworkInfoUpdate`.
pub mod node_set_guard_node_network_info_update {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, repeated, tag = "1")]
        pub dsguardupdatestruct: ::prost::alloc::vec::Vec<
            super::ProtoDsGuardUpdateStruct,
        >,
    }
}
/// For removing sender from local blacklist
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeRemoveFromBlacklist {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<node_remove_from_blacklist::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `NodeRemoveFromBlacklist`.
pub mod node_remove_from_blacklist {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, optional, tag = "1")]
        pub ip_address: ::core::option::Option<super::ByteArray>,
        #[prost(uint64, tag = "2")]
        pub dsepochnumber: u64,
    }
}
/// Holds cosigs and rewards structure for specific shard of specific epoch
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoCosigsRewardsStructure {
    #[prost(uint64, tag = "1")]
    pub epochnumber: u64,
    #[prost(int32, tag = "2")]
    pub shardid: i32,
    #[prost(message, optional, tag = "3")]
    pub blockbase: ::core::option::Option<ProtoBlockBase>,
    #[prost(message, optional, tag = "4")]
    pub rewards: ::core::option::Option<ByteArray>,
}
/// From DS node for fetching cosig/rewards from Lookup
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetCosigsRewardsFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_cosigs_rewards_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetCosigsRewardsFromSeed`.
pub mod lookup_get_cosigs_rewards_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint32, tag = "1")]
        pub portno: u32,
        #[prost(uint64, tag = "2")]
        pub epochnumber: u64,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetDsLeaderTxnPool {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_ds_leader_txn_pool::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetDSLeaderTxnPool`.
pub mod lookup_get_ds_leader_txn_pool {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint32, tag = "1")]
        pub portno: u32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetDsLeaderTxnPool {
    #[prost(message, optional, tag = "1")]
    pub ds_leader_txn_pool: ::core::option::Option<ProtoTransactionArray>,
}
/// Lookup set cosigs/rewards for ds node
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetCosigsRewardsFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_cosigs_rewards_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetCosigsRewardsFromSeed`.
pub mod lookup_set_cosigs_rewards_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, repeated, tag = "1")]
        pub cosigsrewards: ::prost::alloc::vec::Vec<super::ProtoCosigsRewardsStructure>,
    }
}
/// From seed node to level2lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetVcFinalBlockFromL2l {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_vc_final_block_from_l2l::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetVCFinalBlockFromL2l`.
pub mod lookup_get_vc_final_block_from_l2l {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub blocknum: u64,
        #[prost(message, optional, tag = "2")]
        pub sender: ::core::option::Option<super::ProtoPeer>,
    }
}
/// From seed node to level2lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetDsBlockFromL2l {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_ds_block_from_l2l::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetDSBlockFromL2l`.
pub mod lookup_get_ds_block_from_l2l {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub blocknum: u64,
        #[prost(message, optional, tag = "2")]
        pub sender: ::core::option::Option<super::ProtoPeer>,
    }
}
/// From seed node to level2lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetMBnForwardTxnFromL2l {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_m_bn_forward_txn_from_l2l::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetMBnForwardTxnFromL2l`.
pub mod lookup_get_m_bn_forward_txn_from_l2l {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub blocknum: u64,
        #[prost(uint32, tag = "2")]
        pub shard_id: u32,
        #[prost(message, optional, tag = "3")]
        pub sender: ::core::option::Option<super::ProtoPeer>,
    }
}
/// From seed node to level2lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetPendingTxnFromL2l {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_pending_txn_from_l2l::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetPendingTxnFromL2l`.
pub mod lookup_get_pending_txn_from_l2l {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub blocknum: u64,
        #[prost(uint32, tag = "2")]
        pub shard_id: u32,
        #[prost(message, optional, tag = "3")]
        pub sender: ::core::option::Option<super::ProtoPeer>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxTraceStoredDisk {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<ByteArray>,
    #[prost(uint64, tag = "2")]
    pub index: u64,
    #[prost(string, tag = "3")]
    pub tx_trace: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OtterscanTrace {
    #[prost(string, tag = "1")]
    pub trace: ::prost::alloc::string::String,
}
/// tx address will map to this and contain all tx hashes
/// associated with that address
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OtterscanTraceAddressMapping {
    #[prost(message, repeated, tag = "1")]
    pub hashes: ::prost::alloc::vec::Vec<otterscan_trace_address_mapping::TxHashInfo>,
}
/// Nested message and enum types in `OtterscanTraceAddressMapping`.
pub mod otterscan_trace_address_mapping {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TxHashInfo {
        #[prost(string, tag = "1")]
        pub hash: ::prost::alloc::string::String,
        #[prost(uint64, tag = "2")]
        pub blocknum: u64,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OtterscanAddressNonceLookup {
    #[prost(string, tag = "1")]
    pub hash: ::prost::alloc::string::String,
}

================
File: proto/src/ZilliqaMessage.proto
================
syntax = "proto3";

package ZilliqaMessage;

message ByteArray
{
    bytes data = 1;
}

// ============================================================================
// Primitives that are used for persistent storage
//
// NOTE:
//   Only append new fields to the end of these messages.
//   This means that if a field is to be deprecated, do not remove it.
// ============================================================================

// Used in database "blockLinks"
message ProtoBlockLink
{
    oneof oneof1 { uint32 version   = 1; } // Added in: v1.0, Deprecated in: N/A
    oneof oneof2 { uint64 index     = 2; } // Added in: v1.0, Deprecated in: N/A
    oneof oneof3 { uint64 dsindex   = 3; } // Added in: v1.0, Deprecated in: N/A
    oneof oneof4 { uint32 blocktype = 4; } // Added in: v1.0, Deprecated in: N/A
    bytes blockhash  = 5; // Added in: v1.0, Deprecated in: N/A
    // Add new members here
}

// Used in databases "dsBlocks", "microBlocks", "txBlocks", "VCBlocks"
message ProtoBlockBase
{
    message CoSignatures
    {
        ByteArray cs1   = 1;               // Added in: v1.0, Deprecated in: N/A
        repeated bool b1         = 2 [packed=true]; // Added in: v1.0, Deprecated in: N/A
        ByteArray cs2   = 3;               // Added in: v1.0, Deprecated in: N/A
        repeated bool b2         = 4 [packed=true]; // Added in: v1.0, Deprecated in: N/A
        // Add new members here
    }
    bytes blockhash     = 1;               // Added in: v1.0, Deprecated in: N/A
    CoSignatures cosigs = 2;               // Added in: v1.0, Deprecated in: N/A
    uint64 timestamp    = 3;               // Added in: v1.0, Deprecated in: N/A
    // Add new members here
}

// Used in "dsBlockHeader", "microBlockHeader", "txBlockHeader", and "VCBlockHeader"
message ProtoBlockHeaderBase
{
    uint32 version      = 1;   // Added in: v1.0, Deprecated in: N/A
    bytes committeehash = 2;   // Added in: v1.0, Deprecated in: N/A
    bytes prevhash      = 3;   // Added in: v1.0, Deprecated in: N/A
}

// Used in database "dsBlocks"
message ProtoDSBlock
{
    message DSBlockHashSet
    {
        bytes shardinghash     = 1;  // Added in: v1.0, Deprecated in: N/A
        bytes reservedfield    = 2;  // Added in: v1.0, Deprecated in: N/A
        // Add new members here
    }
    message DSBlockHeader
    {
        ProtoBlockHeaderBase blockheaderbase = 1;  // Added in: v1.0, Deprecated in: N/A
        uint32 dsdifficulty                  = 2;  // Added in: v1.0, Deprecated in: N/A, Only LSB used
        uint32 difficulty                    = 3;  // Added in: v1.0, Deprecated in: N/A, Only LSB used
        bytes prevhash                       = 4;  // Added in: v1.0, Deprecated in: N/A, 32 bytes
        ByteArray leaderpubkey               = 5;  // Added in: v1.0, Deprecated in: N/A
        oneof oneof6 { uint64 blocknum       = 6; } // Added in: v1.0, Deprecated in: N/A
        oneof oneof7 { uint64 epochnum       = 7; } // Added in: v1.0, Deprecated in: N/A
        ByteArray gasprice                   = 8;  // Added in: v1.0, Deprecated in: N/A
        ByteArray swinfo                     = 9;  // Added in: v1.0, Deprecated in: N/A
        message PowDSWinners
        {
            ByteArray key      = 1;  // Added in: v1.0, Deprecated in: N/A
            ByteArray val      = 2;  // Added in: v1.0, Deprecated in: N/A
            // Add new members here
        }
        repeated PowDSWinners dswinners = 10; // Added in: v1.0, Deprecated in: N/A
        DSBlockHashSet hash    = 11; // Added in: v1.0, Deprecated in: N/A
        repeated ByteArray dsremoved    = 12; // Added in: v2.0, Deprecated in: N/A
        // Add new members here
        message Vote
        {
            uint32 value = 1;
            uint32 count = 2;
        }
        message Proposal
        {
            uint32 proposalid           = 1;
            repeated Vote dsvotes       = 2;
            repeated Vote minervotes    = 3;
        }
        repeated Proposal proposals      = 13;
    }
    DSBlockHeader header       = 1;  // Added in: v1.0, Deprecated in: N/A
    ProtoBlockBase blockbase   = 2;  // Added in: v1.0, Deprecated in: N/A
    // Add new members here
}

// Used in database "dsCommittee"
message ProtoDSNode
{
    ByteArray pubkey = 1; // Added in: v1.0, Deprecated in: N/A
    ByteArray peer   = 2; // Added in: v1.0, Deprecated in: N/A
    // Add new members here
}

// Used in database "dsCommittee"
message ProtoDSCommittee
{
    uint32 version      = 1; // Added in: v1.0, Deprecated in: N/A
    repeated ProtoDSNode dsnodes = 2; // Added in: v1.0, Deprecated in: N/A
    // Add new members here
}

// Used in database "microBlocks"
message ProtoMicroBlock
{
    message MicroBlockHeader
    {
        ProtoBlockHeaderBase blockheaderbase = 1;  // Added in: v1.0, Deprecated in: N/A
        oneof oneof2 { uint32 shardid        = 2; } // Added in: v1.0, Deprecated in: N/A
        uint64 gaslimit                      = 3;  // Added in: v1.0, Deprecated in: N/A
        oneof oneof4 { uint64 gasused        = 4; } // Added in: v1.0, Deprecated in: N/A
        ByteArray rewards                    = 5;  // Added in: v1.0, Deprecated in: N/A
        bytes prevhash                       = 6;  // Added in: v1.0, Deprecated in: N/A
        oneof oneof7 { uint64 epochnum       = 7; } // Added in: v1.0, Deprecated in: N/A
        bytes txroothash                     = 8;  // Added in: v1.0, Deprecated in: N/A
        oneof oneof9 { uint32 numtxs         = 9; } // Added in: v1.0, Deprecated in: N/A
        ByteArray minerpubkey                = 10; // Added in: v1.0, Deprecated in: N/A
        uint64 dsblocknum                    = 11; // Added in: v1.0, Deprecated in: N/A
        bytes statedeltahash                 = 12; // Added in: v1.0, Deprecated in: N/A
        bytes tranreceipthash                = 13; // Added in: v1.0, Deprecated in: N/A
        // Add new members here
    }
    MicroBlockHeader header   = 1;  // Added in: v1.0, Deprecated in: N/A
    repeated bytes tranhashes          = 2;  // Added in: v1.0, Deprecated in: N/A
    ProtoBlockBase blockbase  = 3;  // Added in: v1.0, Deprecated in: N/A
    // Add new members here
}

// Used in database "shardStructure"
message ProtoShardingStructure
{
    message Member
    {
        ByteArray pubkey   = 1; // Added in: v1.0, Deprecated in: N/A
        ByteArray peerinfo = 2; // Added in: v1.0, Deprecated in: N/A
        oneof oneof3 { uint32 reputation  = 3; } // Added in: v1.0, Deprecated in: N/A
        // Add new members here
    }
    message Shard
    {
        repeated Member members     = 1; // Added in: v1.0, Deprecated in: N/A
        // Add new members here
    }
    uint32 version         = 1; // Added in: v1.0, Deprecated in: N/A
    repeated Shard shards           = 2; // Added in: v1.0, Deprecated in: N/A
    // Add new members here
}

// Used in database "txBlocks"
message ProtoMbInfo
{
    bytes mbhash   = 1; // Added in: v1.0, Deprecated in: N/A
    bytes txroot   = 2; // Added in: v1.0, Deprecated in: N/A
    oneof oneof3 { uint32 shardid = 3; } // Added in: v1.0, Deprecated in: N/A
    // Add new members here
}

// Used in database "txBlocks"
message ProtoTxBlock
{
    message TxBlockHashSet
    {
        bytes stateroothash   = 1;  // Added in: v1.0, Deprecated in: N/A
        bytes statedeltahash  = 2;  // Added in: v1.0, Deprecated in: N/A
        bytes mbinfohash      = 3;  // Added in: v1.0, Deprecated in: N/A
        // Add new members here
    }
    message TxBlockHeader
    {
        ProtoBlockHeaderBase blockheaderbase = 1;  // Added in: v1.0, Deprecated in: N/A
        uint64 gaslimit                      = 2;  // Added in: v1.0, Deprecated in: N/A
        oneof oneof3 { uint64 gasused        = 3;} // Added in: v1.0, Deprecated in: N/A
        ByteArray rewards                    = 4;  // Added in: v1.0, Deprecated in: N/A
        bytes prevhash                       = 5;  // Added in: v1.0, Deprecated in: N/A
        oneof oneof6 {uint64 blocknum        = 6;} // Added in: v1.0, Deprecated in: N/A
        TxBlockHashSet hash                  = 7;  // Added in: v1.0, Deprecated in: N/A
        oneof oneof8 { uint32 numtxs         = 8;} // Added in: v1.0, Deprecated in: N/A
        ByteArray minerpubkey                = 9;  // Added in: v1.0, Deprecated in: N/A
        oneof oneof10 {uint64 dsblocknum     = 10;}// Added in: v1.0, Deprecated in: N/A
        // Add new members here
    }
    TxBlockHeader header      = 1;  // Added in: v1.0, Deprecated in: N/A
    repeated ProtoMbInfo mbinfos       = 2;  // Added in: v1.0, Deprecated in: N/A
    ProtoBlockBase blockbase  = 3;  // Added in: v1.0, Deprecated in: N/A
    // Add new members here
}

// Used in database "VCBlocks"
message ProtoVCBlock
{
    message VCBlockHeader
    {
        ProtoBlockHeaderBase blockheaderbase = 1; // Added in: v1.0, Deprecated in: N/A
        uint64 viewchangedsepochno           = 2; // Added in: v1.0, Deprecated in: N/A
        uint64 viewchangeepochno             = 3; // Added in: v1.0, Deprecated in: N/A
        oneof oneof4 { uint32 viewchangestate = 4; } // Added in: v1.0, Deprecated in: N/A, Only LSB used
        ByteArray candidateleadernetworkinfo = 5; // Added in: v1.0, Deprecated in: N/A
        ByteArray candidateleaderpubkey      = 6; // Added in: v1.0, Deprecated in: N/A
        oneof oneof7 { uint32 vccounter      = 7; } // Added in: v1.0, Deprecated in: N/A
        repeated ProtoDSNode faultyleaders            = 8; // Added in: v1.0, Deprecated in: N/A
        bytes prevhash                       = 9; // Added in: v1.0, Deprecated in: N/A
        // Add new members here
    }
    VCBlockHeader header                     = 1; // Added in: v1.0, Deprecated in: N/A
    ProtoBlockBase blockbase                 = 2; // Added in: v1.0, Deprecated in: N/A
    // Add new members here
}

// Used in database "diagnosticNodes"
message ProtoDiagnosticDataNodes
{
    ProtoShardingStructure shards = 1; // Added in: v1.0, Deprecated in: N/A
    ProtoDSCommittee dscommittee  = 2; // Added in: v1.0, Deprecated in: N/A
    // Add new members here
}

// Used in database "diagnosticCoinb"
message ProtoDiagnosticDataCoinbase
{
  ByteArray nodecount          = 1;  // Added in: v1.0, Deprecated in: N/A
  ByteArray sigcount           = 2;  // Added in: v1.0, Deprecated in: N/A
  uint32 lookupcount           = 3;  // Added in: v1.0, Deprecated in: N/A
  ByteArray totalreward        = 4;  // Added in: v1.0, Deprecated in: N/A
  ByteArray basereward         = 5;  // Added in: v1.0, Deprecated in: N/A
  ByteArray baserewardeach     = 6;  // Added in: v1.0, Deprecated in: N/A
  ByteArray lookupreward       = 7;  // Added in: v1.0, Deprecated in: N/A
  ByteArray rewardeachlookup   = 8;  // Added in: v1.0, Deprecated in: N/A
  ByteArray nodereward         = 9;  // Added in: v1.0, Deprecated in: N/A
  ByteArray rewardeach         = 10; // Added in: v1.0, Deprecated in: N/A
  ByteArray balanceleft        = 11; // Added in: v1.0, Deprecated in: N/A
  ByteArray luckydrawwinnerkey = 12; // Added in: v1.0, Deprecated in: N/A
  bytes luckydrawwinneraddr    = 13; // Added in: v1.0, Deprecated in: N/A
    // Add new members here
}

// Used in database "minerInfoDSComm"
message ProtoMinerInfoDSComm
{
    message Node
    {
        ByteArray pubkey         = 1;
    }
    repeated Node dsnodes        = 1;
    repeated Node dsnodesejected = 2;
    // Add new members here
}

// Used in database "minerInfoShards"
message ProtoMinerInfoShards
{
    message Node
    {
        ByteArray pubkey         = 1;
    }
    message Shard
    {
        uint32 shardsize         = 1;
        repeated Node shardnodes = 2;
    }
    repeated Shard shards        = 1;
    // Add new members here
}

// Used in database "microBlocks"
message ProtoMicroBlockKey
{
    uint64 epochnum = 1;
    uint32 shardid  = 2;
}

// Used in database "txEpochs"
message ProtoTxEpoch
{
    uint64 epochnum = 1;
}

// ============================================================================
// Primitives
// ============================================================================

message ProtoAccountBase
{
    uint32 version    = 1; // Added in: v1.0, Deprecated in: N/A
    ByteArray balance = 2; // Added in: v1.0, Deprecated in: N/A
    oneof oneof3 { uint64 nonce = 3; } // Added in: v1.0, Deprecated in: N/A
    bytes codehash    = 4; // Added in: v1.0, Deprecated in: N/A
    bytes storageroot = 5; // Added in: v1.0, Deprecated in: N/A
}

message ProtoAccount
{
    ProtoAccountBase base = 1; // Added in: v1.0, Deprecated in: N/A

    bytes code                      = 2; // Added in: v1.0, Deprecated in: N/A
    bool numbersign                 = 4; // For account delta (false=neg, true=pos) // Added in: v1.0, Deprecated in: N/A
    message StorageData2
    {
        string key        = 1; // Added in: v1.1, Deprecated in: N/A
        bytes data        = 2; // Added in: v1.1, Deprecated in: N/A
    }
    repeated StorageData2 storage2  = 5; // Added in: v1.1, Deprecated in: N/A
    repeated string todelete        = 6; // Added in: v1.1, Deprecated in: N/A
    bytes initdata                  = 7; // Added in: v1.1, Deprecated in: N/A
}

message ProtoStateIndex
{
    repeated bytes index = 1;
}

message ProtoStateData
{
    uint32 version = 1; // Added in: v1.0, Deprecated in: N/A
    string vname   = 2; // Added in: v1.0, Deprecated in: N/A
    bool ismutable = 3; // Added in: v1.0, Deprecated in: N/A
    string type    = 4; // Added in: v1.0, Deprecated in: N/A
    string value   = 5; // Added in: v1.0, Deprecated in: N/A
}

message ProtoAccountStore
{
    message AddressAccount
    {
        bytes address        = 1;
        ProtoAccount account = 2;
    }
    repeated AddressAccount entries   = 3;
}

message ProtoPeer
{
    ByteArray ipaddress    = 1;
    oneof oneof2 { uint32 listenporthost  = 2; }
}

message ProtoPoWSolution
{
    uint64 nonce        = 1;
    bytes result        = 2;
    bytes mixhash       = 3;
    oneof oneof4 { uint32 lookupid     = 4; }
    ByteArray gasprice  = 5;
    GovernanceData govdata  = 6;
    bytes extradata     = 7;
}

message ProtoCommittee
{
    repeated ByteArray members = 1;
}

message ProtoShardingStructureWithPoWSolns
{
    message Member
    {
        ByteArray pubkey         = 1;
        ByteArray peerinfo       = 2;
        oneof oneof3 { uint32 reputation = 3; }
        ProtoPoWSolution powsoln = 4;
    }
    message Shard
    {
        repeated Member members           = 1;
    }
    repeated Shard shards                 = 1;
}

message ProtoDSWinnerPoW
{
     ByteArray pubkey         = 1;
     ProtoPoWSolution powsoln = 2;
}

message ProtoTransactionCoreInfo
{
    uint32 version         = 1;
    oneof oneof2 { uint64 nonce = 2; }
    bytes toaddr           = 3;
    ByteArray senderpubkey = 4;
    ByteArray amount       = 5;
    ByteArray gasprice     = 6;
    uint64 gaslimit        = 7;
    oneof oneof8 { bytes code = 8; }
    oneof oneof9 { bytes data = 9; }
    repeated AccessListItem accessList = 10;
    ByteArray maxpriorityfeepergas = 11;
    ByteArray maxfeepergas = 12;
}

message AccessListItem
{
    bytes address = 1;
    repeated bytes storagekeys = 2;
}

message ProtoTransaction
{
    bytes tranid                  = 1;
    ProtoTransactionCoreInfo info = 2;
    ByteArray signature           = 3;
}

message ProtoTxnFileOffset
{
    repeated uint32 offsetinfile = 1;
}

message ProtoTransactionArray
{
    repeated ProtoTransaction transactions = 1;
}


message ProtoTransactionReceipt
{
    bytes receipt    = 1;
    oneof oneof2 { uint64 cumgas = 2; }
}

message ProtoTransactionWithReceipt
{
    ProtoTransaction transaction    = 1;
    ProtoTransactionReceipt receipt = 2;
}

message ProtoBloomFilter
{
    repeated uint32 salt           = 1;
    bytes bittable                = 2;
    uint32 saltcount              = 3;
    uint64 tablesize              = 4;
    uint64 projectedelementcount = 5;
    uint64 insertedelementcount  = 6;
    uint64 randomseed             = 7;
    double probability             = 8;
}

message ProtoSWInfo
{
    uint32 zilliqamajorversion        = 1;
    uint32 zilliqaminorversion        = 2;
    uint32 zilliqafixversion          = 3;
    uint64 zilliqaupgradeds           = 4;
    uint32 zilliqacommit              = 5;
    uint32 scillamajorversion         = 6;
    uint32 scillaminorversion         = 7;
    uint32 scillafixversion           = 8;
    uint64 scillaupgradeds            = 9;
    uint32 scillacommit               = 10;
}

message ProtoSingleDirectoryBlock
{
    oneof directoryblock
    {
        ProtoDSBlock dsblock                                     = 1;
        ProtoVCBlock vcblock                                     = 2;
    }
}

// ============================================================================
// Peer Manager messages
// ============================================================================

message PMHello
{
    message Data
    {
        ByteArray pubkey  = 1;
        uint32 listenport = 2;
    }
    Data data             = 1;
    ByteArray signature   = 2;
}

// ============================================================================
// Governance message
// ============================================================================

message GovernanceData
{
    uint32 proposalid   = 1;
    uint32 votevalue    = 2;
}

// ============================================================================
// Directory Service messages
// ============================================================================

message DSPoWSubmission
{
    message Data
    {
        uint64 blocknumber          = 1;
        uint32 difficultylevel      = 2; // only LSB used
        ByteArray submitterpeer     = 3;
        ByteArray submitterpubKey   = 4;
        uint64 nonce                = 5;
        string resultinghash        = 6;
        string mixhash              = 7;
        uint32 lookupid             = 8;
        ByteArray gasprice          = 9;
        GovernanceData govdata      = 10;
        string version              = 11;
        bytes extraData             = 12;
    }
    Data data                       = 1;
    ByteArray signature             = 2;
}

message DSPoWPacketSubmission
{
    message Data
    {
        repeated DSPoWSubmission dsPowSubmissions    = 1;
    }
    Data data                               = 1;
    ByteArray pubkey                        = 2;
    ByteArray signature                     = 3;
}

message DSMicroBlockSubmission
{
    message Data
    {
        uint32 microblocktype       = 1; // only LSB used
        uint64 epochnumber          = 2;
        repeated ProtoMicroBlock microblocks = 3;
        repeated bytes statedeltas           = 4;
    }
    Data data                       = 1;
    ByteArray pubkey                = 2;
    ByteArray signature             = 3;
}

message DSDSBlockAnnouncement
{
    ProtoDSBlock dsblock                        = 1;
    ProtoShardingStructureWithPoWSolns sharding = 2;
    repeated ProtoDSWinnerPoW dswinnerpows               = 3;
}

message DSFinalBlockAnnouncement
{
    ProtoTxBlock txblock       = 1;
    ProtoMicroBlock microblock = 2;
}

message DSVCBlockAnnouncement
{
    ByteArray vcblock = 1;
}

message DSMissingMicroBlocksErrorMsg
{
    repeated bytes mbhashes    = 1;
    uint64 epochnum   = 2;
    uint32 listenport = 3;
}

// ============================================================================
// Node messages
// ============================================================================

message NodeDSBlock
{
    uint32 shardid                        = 1;
    ProtoDSBlock dsblock                  = 2;
    repeated ProtoVCBlock vcblocks                 = 3;
    ProtoShardingStructure sharding       = 4;
}

message NodeFinalBlock
{
    uint64 dsblocknumber = 1;
    uint32 consensusid   = 2;
    ProtoTxBlock txblock = 3;
    bytes statedelta     = 4;
    repeated uint32 shardids      = 5;
}

message NodeVCFinalBlock
{
    uint64 dsblocknumber = 1;
    uint32 consensusid   = 2;
    ProtoTxBlock txblock = 3;
    bytes statedelta     = 4;
    repeated ProtoVCBlock vcblocks  = 5;
}

message NodeMBnForwardTransaction
{
    ProtoMicroBlock microblock          = 1;
    repeated ByteArray txnswithreceipt  = 2;
}

message NodePendingTxn
{
    message Data
    {
        message Pair
        {
            bytes txnhash          = 1;
            uint32 code            = 2;
        }
        repeated Pair hashcodepair = 1;
        uint64 epochnumber         = 2;
        uint32 shardid             = 3;
        ByteArray pubkey           = 4;
        bytes txnlisthash          = 5;
    }
    Data data             = 1;
    ByteArray signature   = 2;
}

message NodeVCBlock
{
    ProtoVCBlock vcblock = 1;
}

message NodeForwardTxnBlock
{
    uint64 epochnumber            = 1;
    uint64 dsblocknum             = 2;
    uint32 shardid                = 3;
    ByteArray pubkey              = 4;
    repeated ProtoTransaction transactions = 5;
    ByteArray signature           = 6;
}

message NodeMicroBlockAnnouncement
{
    ProtoMicroBlock microblock = 1;
}

message NodeMissingTxnsErrorMsg
{
    repeated bytes txnhashes   = 1;
    uint64 epochnum   = 2;
    uint32 listenport = 3;
}

message NodeGetVersion
{
    uint32 listenport = 1;
}

message NodeSetVersion
{
    string version = 1;
}

// ============================================================================
// Lookup messages
// ============================================================================

message LookupGetSeedPeers
{
    uint32 listenport = 1;
}

message LookupSetSeedPeers
{
    repeated ByteArray candidateseeds = 1;
    ByteArray pubkey         = 2;
    ByteArray signature      = 3;
}

// From normal node to lookup nodes.
message LookupGetDSInfoFromSeed
{
    uint32 listenport =        1;
    bool initialds =           2;
}

// From DS leader to lookup nodes and from lookup nodes to normal nodes.
message LookupSetDSInfoFromSeed
{
    ProtoDSCommittee dscommittee = 1;
    ByteArray pubkey             = 2;
    ByteArray signature          = 3;
    bool initialds               = 4;
}

// From new join lookup node or new join normal node to existing lookup node.
message LookupGetDSBlockFromSeed
{
    uint64 lowblocknum            = 1;
    uint64 highblocknum           = 2;
    uint32 listenport             = 3;
    bool includeminerinfo         = 4;
}

// From lookup nodes to new join lookup node or new join normal node.
message LookupSetDSBlockFromSeed
{
    message Data
    {
        uint64 lowblocknum    = 1;
        uint64 highblocknum   = 2;
        repeated ProtoDSBlock dsblocks = 3;
    }
    Data data             = 1;
    ByteArray pubkey      = 2;
    ByteArray signature   = 3;
}

// From lookup nodes to new join lookup node.
message LookupSetMinerInfoFromSeed
{
    message MinerInfo
    {
        ProtoMinerInfoDSComm minerinfodscomm = 1;
        ProtoMinerInfoShards minerinfoshards = 2;
    }
    message Data
    {
        map<uint64, MinerInfo> minerinfoperds = 1;
    }
    Data data           = 1;
    ByteArray pubkey    = 2;
    ByteArray signature = 3;
}

// From new join lookup node or new join normal node to existing lookup node.
message LookupGetTxBlockFromSeed
{
    uint64 lowblocknum     = 1;
    uint64 highblocknum    = 2;
    uint32 listenport      = 3;
}

// From lookup nodes to new join lookup node or new join normal node.
message LookupSetTxBlockFromSeed
{
    message Data
    {
        uint64 lowblocknum    = 1;
        uint64 highblocknum   = 2;
        repeated ProtoTxBlock txblocks = 3;
    }
    Data data             = 1;
    ByteArray pubkey      = 2;
    ByteArray signature   = 3;
}

message LookupGetStateDeltaFromSeed
{
    uint64 blocknum     = 1;
    uint32 listenport   = 2;
}

message LookupGetStateDeltasFromSeed
{
    uint64 lowblocknum  = 1;
    uint64 highblocknum = 2;
    uint32 listenport   = 3;
}

message LookupSetStateDeltaFromSeed
{
    message Data
    {
        uint64 blocknum     = 1;
        bytes statedelta    = 2;
    }
    Data data           = 1;
    ByteArray pubkey    = 2;
    ByteArray signature = 3;
}

message LookupSetStateDeltasFromSeed
{
    message Data
    {
        uint64 lowblocknum    = 1;
        uint64 highblocknum   = 2;
        repeated bytes statedeltas = 3;
    }
    Data data           = 1;
    ByteArray pubkey    = 2;
    ByteArray signature = 3;
}

// msgtype is used to prevent replay attacks
message LookupSetLookupOffline
{
    message Data
    {
        uint32 msgtype     = 1; // Only LSB used
        uint32 listenport  = 2;
    }
    Data data              = 1;
    ByteArray pubkey       = 2;
    ByteArray signature    = 3;
}

// msgtype and blocknumber are used to prevent replay attacks
message LookupSetLookupOnline
{
    message Data
    {
        uint32 msgtype     = 1; // Only LSB used
        uint32 listenport  = 2;
    }
    Data data              = 1;
    ByteArray pubkey       = 2;
    ByteArray signature    = 3;
}

message LookupGetOfflineLookups
{
    uint32 listenport = 1;
}

message LookupSetOfflineLookups
{
    repeated ByteArray nodes     = 1;
    ByteArray pubkey    = 2;
    ByteArray signature = 3;
}

// From archival node to lookup node.
message LookupGetShardsFromSeed
{
    uint32 listenport = 1;
}

// From lookup node to archival node.
message LookupSetShardsFromSeed
{
    ProtoShardingStructure sharding = 1;
    ByteArray pubkey                = 2;
    ByteArray signature             = 3;
}

message LookupGetMicroBlockFromLookup
{
    uint32 portno            = 1;
    repeated bytes mbhashes  = 2;
}

message LookupSetMicroBlockFromLookup
{
    repeated ProtoMicroBlock microblocks = 1;
    ByteArray pubkey                     = 2;
    ByteArray signature                  = 3;
}

message LookupGetMicroBlockFromL2l
{
    message Data
    {
        uint32 portno            = 1;
        repeated bytes mbhashes  = 2;
    }
    Data data                    = 1;
    ByteArray pubkey             = 2;
    ByteArray signature          = 3;
}

message LookupForwardTxnsFromSeed
{
    ProtoTransactionArray transactions = 1;
}

message LookupGetTxnsFromLookup
{
    uint32 portno            = 1;
    bytes mbhash             = 2;
    repeated bytes txnhashes = 3;
}

message LookupGetTxnsFromL2l
{
    message Data
    {
        uint32 portno            = 1;
        bytes mbhash             = 2;
        repeated bytes txnhashes = 3;
    }
    Data data                    = 1;
    ByteArray pubkey             = 2;
    ByteArray signature          = 3;
}

message LookupSetTxnsFromLookup
{
    bytes mbhash                    = 1;
    repeated ByteArray transactions = 2;
    ByteArray pubkey                = 3;
    ByteArray signature             = 4;
}

message LookupGetDirectoryBlocksFromSeed
{
    uint32 portno         = 1;
    uint64 indexnum       = 2;
    bool includeminerinfo = 3;
}

message LookupSetDirectoryBlocksFromSeed
{
    message Data
    {
        uint64 indexnum                     = 1;
        repeated ProtoSingleDirectoryBlock dirblocks = 2;
    }
    Data data           = 1;
    ByteArray pubkey    = 2;
    ByteArray signature = 3;
}

// ============================================================================
// Consensus messages
// ============================================================================

message ConsensusAnnouncement
{
    message ConsensusInfo
    {
        uint32 consensusid           = 1;
        uint64 blocknumber           = 2;
        bytes blockhash              = 3; // 32 bytes
        uint32 leaderid              = 4; // only lower 2 bytes used
    }
    ConsensusInfo consensusinfo      = 1;
    ByteArray pubkey                 = 2;
    ByteArray signature              = 3; // The signature of the consensus info
    oneof announcement
    {
        DSDSBlockAnnouncement dsblock         = 4;
        NodeMicroBlockAnnouncement microblock = 5;
        DSFinalBlockAnnouncement finalblock   = 6;
        DSVCBlockAnnouncement vcblock         = 7;
    }
    ByteArray finalsignature         = 9;
}

message ConsensusCommit
{
    message CommitInfo
    {
        ByteArray commitpoint     = 1;
        ByteArray commitpointhash = 2;
    }
    message ConsensusInfo
    {
        uint32 consensusid        = 1;
        uint64 blocknumber        = 2;
        bytes blockhash           = 3; // 32 bytes
        uint32 backupid           = 4; // only lower 2 bytes used
        repeated CommitInfo commitinfo       = 5;
    }
    ConsensusInfo consensusinfo   = 1;
    ByteArray pubkey              = 2;
    ByteArray signature           = 3;
}

message ConsensusChallenge
{
    message SubsetInfo
    {
        ByteArray aggregatedcommit = 1;
        ByteArray aggregatedkey    = 2;
        ByteArray challenge        = 3;
    }
    message ConsensusInfo
    {
        uint32 consensusid         = 1;
        uint64 blocknumber         = 2;
        bytes blockhash            = 3; // 32 bytes
        uint32 leaderid            = 4; // only lower 2 bytes used
        repeated SubsetInfo subsetinfo      = 5;
    }
    ConsensusInfo consensusinfo    = 1;
    ByteArray pubkey               = 2;
    ByteArray signature            = 3;
}

message ConsensusResponse
{
    message SubsetInfo
    {
        ByteArray response      = 1;
    }
    message ConsensusInfo
    {
        uint32 consensusid      = 1;
        uint64 blocknumber      = 2;
        bytes blockhash         = 3; // 32 bytes
        uint32 backupid         = 4; // only lower 2 byte used
        repeated SubsetInfo subsetinfo   = 5;
    }
    ConsensusInfo consensusinfo = 1;
    ByteArray pubkey            = 2;
    ByteArray signature         = 3;
}

message ConsensusCollectiveSig
{
    message ConsensusInfo
    {
        uint32 consensusid      = 1;
        uint64 blocknumber      = 2;
        bytes blockhash         = 3; // 32 bytes
        uint32 leaderid         = 4; // only lower 2 bytes used
        ByteArray collectivesig = 5;
        repeated bool bitmap             = 6 [packed=true];
    }
    ConsensusInfo consensusinfo = 1;
    ByteArray pubkey            = 2;
    ByteArray signature         = 3;
    bytes newannouncement       = 4;
    ByteArray finalsignature    = 5;    
}

message ConsensusCommitFailure
{
    message ConsensusInfo
    {
        uint32 consensusid      = 1;
        uint64 blocknumber      = 2;
        bytes blockhash         = 3; // 32 bytes
        uint32 backupid         = 4; // only lower 2 bytes used
        bytes errormsg          = 5;
    }
    ConsensusInfo consensusinfo = 1;
    ByteArray pubkey            = 2;
    ByteArray signature         = 3;
}

message ConsensusConsensusFailure
{
    message ConsensusInfo
    {
        uint32 consensusid      = 1;
        uint64 blocknumber      = 2;
        bytes blockhash         = 3; // 32 bytes
        uint32 leaderid         = 4; // only lower 2 bytes used
    }
    ConsensusInfo consensusinfo = 1;
    ByteArray pubkey            = 2;
    ByteArray signature         = 3;
}

// ============================================================================
// View change pre check messages
// ============================================================================

// From node undergoing vc pre check to fetch latest blocks
message LookupGetDSTxBlockFromSeed
{
    uint64 dslowblocknum            = 1;
    uint64 dshighblocknum           = 2;
    uint64 txlowblocknum            = 3;
    uint64 txhighblocknum           = 4;
    uint32 listenport               = 5;
}

// From lookup nodes to node under going vc pre check
message VCNodeSetDSTxBlockFromSeed
{
    message Data
    {
        repeated ProtoDSBlock dsblocks   = 1;
        repeated ProtoTxBlock txblocks   = 2;
    }
    Data data               = 1;
    ByteArray pubkey        = 2;
    ByteArray signature     = 3;
}

// ============================================================================
// Shard node identity update
// ============================================================================

// From shard node to lookup/dsCommittee. New shard node network info.
message NodeSetShardNodeNetworkInfoUpdate
{
    message Data
    {
        uint64 dsepochnumber               = 1;
        ByteArray shardnodepubkey          = 2;
        ProtoPeer shardnodenewnetworkinfo  = 3;
        uint64 timestamp                   = 4;
    }
    Data data                              = 1;
    ByteArray signature                    = 2;
}

// ============================================================================
// DS Guard identity update
// ============================================================================

// From DS Guard to lookup. New DS guard node network info.
message DSLookupSetDSGuardNetworkInfoUpdate
{
    message Data
    {
        uint64 dsepochnumber               = 1;
        ByteArray dsguardpubkey            = 2;
        ProtoPeer dsguardnewnetworkinfo    = 3;
        uint64 timestamp                   = 4;
    }
    Data data                              = 1;
    ByteArray signature                    = 2;
}

// To update shard node of guard node's network info change
message NodeGetGuardNodeNetworkInfoUpdate
{
    message Data
    {
        uint32 portno          = 1;
        uint64 dsepochnumber   = 2;
    }
    Data data                  = 1;
    ByteArray pubkey           = 2;
    ByteArray signature        = 3;
}

message ProtoDSGuardUpdateStruct
{
    ByteArray dsguardpubkey            = 1;
    ProtoPeer dsguardnewnetworkinfo    = 2;
    uint64 timestamp                   = 3;
}

// From sending New DS guard node network info to requesing shard node
message NodeSetGuardNodeNetworkInfoUpdate
{
    message Data
    {
        repeated ProtoDSGuardUpdateStruct dsguardupdatestruct = 1;
    }
    Data data                              = 1;
    ByteArray lookuppubkey                 = 2;
    ByteArray signature                    = 3;
}

// For removing sender from local blacklist
message NodeRemoveFromBlacklist
{
    message Data
    {
        ByteArray ipAddress    = 1;
        uint64 dsepochnumber   = 2;
    }
    Data data                  = 1;
    ByteArray pubkey           = 2;
    ByteArray signature        = 3;
}

// Holds cosigs and rewards structure for specific shard of specific epoch
message ProtoCosigsRewardsStructure
{
    uint64 epochnumber         = 1;
    int32 shardid              = 2;
    ProtoBlockBase blockbase   = 3;
    ByteArray rewards          = 4;
}

// From DS node for fetching cosig/rewards from Lookup
message LookupGetCosigsRewardsFromSeed
{
    message Data
    {
        uint32 portno           = 1;
        uint64 epochnumber      = 2;
    }
    Data data                   = 1;
    ByteArray pubkey            = 2;
    ByteArray signature         = 3;
}

message LookupGetDSLeaderTxnPool
{
    message Data
    {
        uint32 portno           = 1;
    }

    Data data                       = 1;
    ByteArray pubkey                = 2;
    ByteArray signature             = 3;
}

message LookupSetDSLeaderTxnPool
{
    ProtoTransactionArray dsLeaderTxnPool = 1;
}

// Lookup set cosigs/rewards for ds node
message LookupSetCosigsRewardsFromSeed
{
    message Data
    {
        repeated ProtoCosigsRewardsStructure cosigsrewards  = 1;
    }
    Data data                                               = 1;
    ByteArray pubkey                                        = 2;
    ByteArray signature                                     = 3;
}

// From seed node to level2lookup node.
message LookupGetVCFinalBlockFromL2l
{
    
    message Data
    {
        uint64 blocknum     = 1;
        ProtoPeer sender    = 2;    
    }
    Data data               = 1;
    ByteArray pubkey        = 2;
    ByteArray signature     = 3;
}

// From seed node to level2lookup node.
message LookupGetDSBlockFromL2l
{
    
    message Data
    {
        uint64 blocknum     = 1;
        ProtoPeer sender    = 2;    
    }
    Data data               = 1;
    ByteArray pubkey        = 2;
    ByteArray signature     = 3;
}

// From seed node to level2lookup node.
message LookupGetMBnForwardTxnFromL2l
{
    
    message Data
    {
        uint64 blocknum     = 1;
        uint32 shardId      = 2;  
        ProtoPeer sender    = 3;    
    }
    Data data               = 1;
    ByteArray pubkey        = 2;
    ByteArray signature     = 3;
}

// From seed node to level2lookup node.
message LookupGetPendingTxnFromL2l
{
    
    message Data
    {
        uint64 blocknum     = 1;
        uint32 shardId      = 2;
        ProtoPeer sender    = 3;    
    }
    Data data               = 1;
    ByteArray pubkey        = 2;
    ByteArray signature     = 3;
}

message TxTraceStoredDisk
{
    repeated ByteArray items    = 1;
    uint64          index       = 2;
    string          txTrace     = 3;
}

message OtterscanTrace
{
    string          trace     = 1;
}

// tx address will map to this and contain all tx hashes
// associated with that address
message OtterscanTraceAddressMapping
{
    message TxHashInfo
    {
        string hash      = 1;
        uint64 blocknum  = 2;
    }
    repeated TxHashInfo hashes = 1;
}

message OtterscanAddressNonceLookup
{
    string hash      = 1;
}

================
File: proto/src/zq1_proto.rs
================
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ByteArray {
    #[prost(bytes = "vec", tag = "1")]
    pub data: Vec<u8>,
}

impl From<Vec<u8>> for ByteArray {
    fn from(data: Vec<u8>) -> Self {
        ByteArray { data }
    }
}

impl From<Box<[u8]>> for ByteArray {
    fn from(data: Box<[u8]>) -> Self {
        ByteArray { data: data.into() }
    }
}

#[derive(Clone, PartialEq, prost::Message)]
pub struct ProtoTransactionCoreInfo {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    #[prost(bytes = "vec", tag = "3")]
    pub toaddr: Vec<u8>,
    #[prost(message, optional, tag = "4")]
    pub senderpubkey: Option<ByteArray>,
    #[prost(message, optional, tag = "5")]
    pub amount: Option<ByteArray>,
    #[prost(message, optional, tag = "6")]
    pub gasprice: Option<ByteArray>,
    #[prost(uint64, tag = "7")]
    pub gaslimit: u64,
    #[prost(oneof = "Nonce", tags = "2")]
    pub oneof2: Option<Nonce>,
    #[prost(oneof = "Code", tags = "8")]
    pub oneof8: Option<Code>,
    #[prost(oneof = "Data", tags = "9")]
    pub oneof9: Option<Data>,
}

#[derive(Clone, PartialEq, prost::Oneof)]
pub enum Nonce {
    #[prost(uint64, tag = "2")]
    Nonce(u64),
}
#[derive(Clone, PartialEq, prost::Oneof)]
pub enum Code {
    #[prost(bytes, tag = "8")]
    Code(Vec<u8>),
}
#[derive(Clone, PartialEq, prost::Oneof)]
pub enum Data {
    #[prost(bytes, tag = "9")]
    Data(Vec<u8>),
}

================
File: proto/build.rs
================
use prost_build::Config;
use std::io::Result;

fn main() -> Result<()> {
    Config::new()
        .out_dir("src/")
        .compile_protos(&["src/ZilliqaMessage.proto"], &["protos/"])?;

    Ok(())
}

================
File: proto/Cargo.toml
================
[package]
name = "proto"
version = "0.1.0"
edition = "2021"

[dependencies]
prost = "0.12.6"
crypto = { path = "../crypto" }
config = { path = "../config" }
bincode = { path = "../bincode" }
zil_errors = { path = "../zil_errors" }
serde = { version = "1.0.204", features = ["derive"] }
sha2 = "0.10.8"
hex = "0.4.3"
rand_chacha = "0.3.1"
rand = "0.8.5"
k256 = "0.13.3"
tiny-hderive = "0.3.0"
bip39 = "2.0.0"
ripemd = "0.1.3"
serde_json = "1.0.124"
bech32 = "0.11.0"
alloy = { version = "0.4.2", features = ["signer-local", "network", "consensus", "rpc", "rpc-types"] }

[build-dependencies]
prost-build = "0.12.6"

================
File: session/src/lib.rs
================
use cipher::{argon2, keychain::KeyChain, options::CipherOrders};
use config::argon::{KEY_SIZE, SESSION_SALT};
use zil_errors::session::SessionErrors;

/// Encrypts a seed (password) using device fingerprint and multiple encryption layers
///
/// This function implements a multi-layer encryption scheme where a device-specific
/// fingerprint is used to encrypt a cached password/seed. The process involves:
/// 1. Deriving a key from the device fingerprint using Argon2
/// 2. Creating a keychain from the derived key
/// 3. Encrypting the seed using multiple cipher layers
///
/// # Parameters
/// * `fingerprint` - A device-specific identifier string containing static device information
///                   Used as the base for key derivation
/// * `seed_bytes` - The password/seed to be encrypted (must be KEY_SIZE bytes long)
///                  This is typically a cached password that needs to be secured
/// * `options` - Vector of encryption layer configurations (CipherOrders)
///               Specifies the sequence and types of encryption to be applied
///
/// # Returns
/// * `Ok(Vec<u8>)` - The encrypted seed as a byte vector if successful
/// * `Err(SessionErrors)` - Various error types that might occur during:
///   - Argon2 key derivation
///   - Keychain creation
///   - Encryption process
///
/// # Security Notes
/// - The fingerprint should be reliably reproducible across sessions
/// - The seed_bytes should be properly generated and secured before passing
/// - The encryption layers (options) should be carefully chosen for security requirements
pub fn encrypt_session(
    fingerprint: &str,
    seed_bytes: &[u8; KEY_SIZE],
    options: &[CipherOrders],
) -> Result<Vec<u8>, SessionErrors> {
    let argon_seed = argon2::derive_key(fingerprint.as_bytes(), SESSION_SALT)
        .map_err(SessionErrors::ArgonError)?;
    let keychain = KeyChain::from_seed(&argon_seed).map_err(SessionErrors::KeychainError)?;
    let seed_cipher = keychain
        .encrypt(seed_bytes.to_vec(), options)
        .map_err(SessionErrors::KeychainError)?;

    Ok(seed_cipher)
}

/// Decrypts a previously encrypted seed using device fingerprint and encryption layers
///
/// This function is the inverse operation of `from_fingerprint()`. It decrypts a seed
/// (typically a cached password) that was encrypted using a device-specific fingerprint.
/// The process involves:
/// 1. Deriving the same key from the device fingerprint using Argon2
/// 2. Recreating the keychain from the derived key
/// 3. Decrypting the seed using the same cipher layers in reverse order
///
/// # Parameters
/// * `fingerprint` - A device-specific identifier string containing static device information
///                   Must match the fingerprint used for encryption
/// * `seed_cipher` - The encrypted seed bytes that were returned from `from_fingerprint()`
/// * `options` - Vector of encryption layer configurations (CipherOrders)
///               Must match the exact sequence used during encryption
///
/// # Returns
/// * `Ok([u8; KEY_SIZE])` - The decrypted seed as a fixed-size byte array if successful
/// * `Err(SessionErrors)` - Various error types that might occur during:
///   - Argon2 key derivation
///   - Keychain creation
///   - Decryption process
///   - Invalid seed size after decryption
///
/// # Security Notes
/// - The fingerprint must exactly match the one used for encryption
/// - The options sequence must match the encryption sequence
/// - Failed decryption might indicate tampering or incorrect device fingerprint
///
pub fn decrypt_session(
    fingerprint: &str,
    seed_cipher: Vec<u8>,
    options: &[CipherOrders],
) -> Result<[u8; KEY_SIZE], SessionErrors> {
    let argon_seed = argon2::derive_key(fingerprint.as_bytes(), SESSION_SALT)
        .map_err(SessionErrors::ArgonError)?;
    let keychain = KeyChain::from_seed(&argon_seed).map_err(SessionErrors::KeychainError)?;
    let seed_bytes: [u8; KEY_SIZE] = keychain
        .decrypt(seed_cipher, options)
        .map_err(SessionErrors::KeychainError)?
        .try_into()
        .map_err(|_| SessionErrors::InvalidDecryptSession)?;

    Ok(seed_bytes)
}

#[cfg(test)]
mod tests {
    use super::*;
    use config::argon::KEY_SIZE;

    fn setup_test_data() -> ([u8; KEY_SIZE], String, [CipherOrders; 2]) {
        let test_seed = [1u8; KEY_SIZE];
        let test_fingerprint = "test_device_id_123".to_string();
        let options = [CipherOrders::AESGCM256, CipherOrders::NTRUP1277];
        (test_seed, test_fingerprint, options)
    }

    #[test]
    fn test_successful_encryption_decryption_cycle() {
        let (seed, fingerprint, options) = setup_test_data();

        let encrypted =
            encrypt_session(&fingerprint, &seed, &options).expect("Encryption should succeed");

        assert_ne!(&encrypted.as_slice(), &seed);

        let decrypted =
            decrypt_session(&fingerprint, encrypted, &options).expect("Decryption should succeed");

        assert_eq!(decrypted, seed);
    }

    #[test]
    fn test_wrong_fingerprint_fails() {
        let (seed, fingerprint, options) = setup_test_data();

        let encrypted =
            encrypt_session(&fingerprint, &seed, &options).expect("Encryption should succeed");
        let wrong_fingerprint = "wrong_device_id_456";
        let result = decrypt_session(wrong_fingerprint, encrypted, &options);

        assert!(matches!(result, Err(SessionErrors::KeychainError(_))));
    }

    #[test]
    fn test_wrong_cipher_options() {
        let (seed, fingerprint, options) = setup_test_data();

        let encrypted =
            encrypt_session(&fingerprint, &seed, &options).expect("Encryption should succeed");
        let wrong_options = vec![CipherOrders::NTRUP1277];
        let result = decrypt_session(&fingerprint, encrypted, &wrong_options);

        assert!(matches!(result, Err(SessionErrors::InvalidDecryptSession)));
    }

    #[test]
    fn test_large_fingerprint() {
        let (seed, _, options) = setup_test_data();
        let large_fingerprint = "a".repeat(10000);

        let result = encrypt_session(&large_fingerprint, &seed, &options);

        let encrypted = result.expect("Should handle large fingerprint");
        let decrypted = decrypt_session(&large_fingerprint, encrypted, &options)
            .expect("Should decrypt successfully");

        assert_eq!(decrypted, seed);
    }
}

================
File: session/Cargo.toml
================
[package]
name = "session"
version = "0.1.0"
edition = "2021"

[dependencies]
zil_errors = { path = "../zil_errors" }
cipher = { path = "../cipher" }
config = { path = "../config" }
rand_chacha = "0.3.1"
rand = "0.8.5"

================
File: settings/src/common_settings.rs
================
use crate::{language::Language, notificcations::Notificcations, storage::Storage, theme::Theme};

#[derive(Debug, Clone)]
pub struct CommonSettings {
    pub language: Language,
    pub notificcations: Notificcations,
    pub storage: Storage,
    pub theme: Theme,
}

impl Default for CommonSettings {
    fn default() -> Self {
        Self {
            language: Language {},
            notificcations: Notificcations {},
            storage: Storage {},
            theme: Theme {},
        }
    }
}

================
File: settings/src/crypto.rs
================
use cipher::options::CipherOrders;
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct CryptoSettings {
    pub cipher_orders: Vec<CipherOrders>,
}

impl Default for CryptoSettings {
    fn default() -> Self {
        Self {
            cipher_orders: [CipherOrders::AESGCM256, CipherOrders::NTRUP1277].into(),
        }
    }
}

================
File: settings/src/currency.rs
================
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct Currency {}

================
File: settings/src/language.rs
================
#[derive(Debug, Clone, Copy)]
pub struct Language {}

================
File: settings/src/lib.rs
================
pub mod common_settings;
pub mod crypto;
pub mod currency;
pub mod language;
pub mod network;
pub mod notificcations;
pub mod security;
pub mod storage;
pub mod theme;
pub mod wallet_settings;

================
File: settings/src/network.rs
================
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct Network {}

================
File: settings/src/notificcations.rs
================
#[derive(Debug, Clone)]
pub struct Notificcations {}

================
File: settings/src/security.rs
================
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct Security {}

================
File: settings/src/storage.rs
================
#[derive(Debug, Clone)]
pub struct Storage {}

================
File: settings/src/theme.rs
================
#[derive(Debug, Clone, Copy)]
pub struct Theme {}

================
File: settings/src/wallet_settings.rs
================
use crate::{crypto::CryptoSettings, currency::Currency, network::Network, security::Security};
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone)]
pub struct WalletSettings {
    pub crypto: CryptoSettings,
    pub currency: Currency,
    pub network: Network,
    pub security: Security,
}

impl Default for WalletSettings {
    fn default() -> Self {
        Self {
            crypto: CryptoSettings::default(),
            currency: Currency {},
            network: Network {},
            security: Security {},
        }
    }
}

================
File: settings/Cargo.toml
================
[package]
name = "settings"
version = "0.1.0"
edition = "2021"

[dependencies]
zil_errors = { path = "../zil_errors" }
config = { path = "../config" }
cipher = { path = "../cipher" }
serde = { version = "1.0.204", features = ["derive"] }
serde_json = "1.0.124"

================
File: storage/src/data_warp.rs
================
use bincode::{FromBytes, ToVecBytes};
use std::borrow::Cow;
use std::mem::size_of;
use zil_errors::storage::LocalStorageError;

#[derive(Debug)]
pub struct DataWarp {
    pub payload: Vec<u8>,
    // Storage verions
    pub version: u16,
}

impl FromBytes for DataWarp {
    type Error = LocalStorageError;

    fn from_bytes(bytes: Cow<[u8]>) -> Result<Self, Self::Error> {
        if bytes.len() < size_of::<usize>() + size_of::<u16>() {
            return Err(LocalStorageError::InsufficientBytes);
        }

        let (len_bytes, rest) = bytes.split_at(size_of::<usize>());

        let payload_len = usize::from_le_bytes(
            len_bytes
                .as_ref()
                .try_into()
                .map_err(|_| LocalStorageError::PayloadLengthError)?,
        );
        let remains_len = payload_len
            .checked_add(size_of::<u16>())
            .ok_or(LocalStorageError::InvalidBytesSizeOverflow)?;

        if rest.len() < remains_len {
            return Err(LocalStorageError::InsufficientBytes);
        }

        let (payload, version_bytes) = rest.split_at(payload_len);
        let version = u16::from_le_bytes(
            version_bytes[..size_of::<u16>()]
                .try_into()
                .or(Err(LocalStorageError::PayloadVersionParseError))?,
        );

        Ok(Self {
            payload: payload.to_vec(),
            version,
        })
    }
}

impl ToVecBytes for DataWarp {
    fn to_bytes(&self) -> Vec<u8> {
        // let payload_bytes = ST::to_bytes(&self.payload);
        let payload_len = self.payload.len();
        let mut bytes: Vec<u8> =
            Vec::with_capacity(size_of::<usize>() + payload_len + size_of::<u16>());

        bytes.extend_from_slice(&payload_len.to_le_bytes());
        bytes.extend_from_slice(&self.payload);
        bytes.extend_from_slice(&self.version.to_le_bytes());

        bytes
    }
}

impl PartialEq for DataWarp {
    fn eq(&self, other: &Self) -> bool {
        self.version == other.version
    }
}

#[cfg(test)]
mod storage_tests {
    use super::*;

    #[test]
    fn test_datawarp_serialization_deserialization() {
        let data = DataWarp {
            payload: b"Hello, World!".to_vec(),
            version: 1,
        };

        let bytes = data.to_bytes();
        assert_eq!(bytes.len(), size_of::<usize>() + 13 + size_of::<u16>());

        let (len_bytes, rest) = bytes.split_at(size_of::<usize>());
        assert_eq!(usize::from_le_bytes(len_bytes.try_into().unwrap()), 13);

        let (payload_bytes, version_bytes) = rest.split_at(13);
        assert_eq!(payload_bytes, b"Hello, World!");
        assert_eq!(u16::from_le_bytes(version_bytes.try_into().unwrap()), 1);

        let res_data: DataWarp = DataWarp::from_bytes(bytes.into()).unwrap();

        assert_eq!(res_data, data);
    }

    #[test]
    fn test_datawarp_roundtrip() {
        let original = DataWarp {
            payload: b"Test data".to_vec(),
            version: 42,
        };

        let bytes = original.to_bytes();
        let deserialized = DataWarp::from_bytes(bytes.into()).unwrap();

        assert_eq!(original.payload, deserialized.payload);
        assert_eq!(original.version, deserialized.version);
    }

    #[test]
    fn test_datawarp_invalid_payload() {
        let invalid_bytes = vec![255; 10]; // Invalid UTF-8
        let result = DataWarp::from_bytes(invalid_bytes.into());

        assert!(matches!(
            result,
            Err(LocalStorageError::InvalidBytesSizeOverflow)
        ));
    }

    #[test]
    fn test_datawarp_invalid_version() {
        let mut bytes = b"Valid payload".to_vec();
        bytes.push(0); // Add only one byte for version instead of two
        let result = DataWarp::from_bytes(bytes.into());
        assert!(matches!(result, Err(LocalStorageError::InsufficientBytes)));
    }
}

================
File: storage/src/lib.rs
================
pub mod data_warp;

use bincode::{FromBytes, ToVecBytes};
use config::storage::STORAGE_VERSION;
use data_warp::DataWarp;
use directories::ProjectDirs;
use sled::{Db, IVec};
use zil_errors::storage::LocalStorageError;

pub struct LocalStorage {
    tree: Db,
    version: u16,
    path: String,
}

impl std::fmt::Display for LocalStorage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let size = self.get_db_size().to_string();
        let path = self.get_path();

        write!(f, "size: {}, path: {:?}", size, path)
    }
}

impl LocalStorage {
    pub fn from(path: &str) -> Result<Self, LocalStorageError> {
        let tree =
            sled::open(path).map_err(|e| LocalStorageError::StorageAccessError(e.to_string()))?;
        let version = STORAGE_VERSION;

        Ok(LocalStorage {
            tree,
            version,
            path: path.to_owned(),
        })
    }

    pub fn new(
        qualifier: &str,
        organization: &str,
        application: &str,
    ) -> Result<Self, LocalStorageError> {
        let path = ProjectDirs::from(qualifier, organization, application)
            .ok_or(LocalStorageError::StoragePathError)?;
        let tree = sled::open(path.data_dir())
            .map_err(|e| LocalStorageError::StorageAccessError(e.to_string()))?;
        let version = STORAGE_VERSION;

        Ok(LocalStorage {
            tree,
            version,
            path: path.data_dir().to_str().unwrap_or("").to_string(),
        })
    }

    pub fn get_path(&self) -> String {
        self.path.clone()
    }

    pub fn get_db_size(&self) -> u64 {
        self.tree.size_on_disk().unwrap_or(0)
    }

    pub fn exists(&self, key: &[u8]) -> Result<bool, LocalStorageError> {
        self.tree
            .contains_key(key)
            .map_err(|e| LocalStorageError::StorageAccessError(e.to_string()))
    }

    pub fn get(&self, key: &[u8]) -> Result<Vec<u8>, LocalStorageError> {
        let some_value = self
            .tree
            .get(key)
            .map_err(|e| LocalStorageError::StorageAccessError(e.to_string()))?;
        let value = some_value
            .ok_or(LocalStorageError::StorageDataNotFound)?
            .to_vec();
        let data = DataWarp::from_bytes(value.into())?;

        Ok(data.payload)
    }

    pub fn set(&self, key: &[u8], payload: &[u8]) -> Result<(), LocalStorageError> {
        let data = DataWarp {
            payload: payload.into(),
            version: self.version,
        };
        let vec = IVec::from(data.to_bytes());

        self.tree
            .insert(key, vec)
            .map_err(|e| LocalStorageError::StorageWriteError(e.to_string()))?;

        Ok(())
    }

    pub fn flush(&self) -> Result<(), LocalStorageError> {
        self.tree
            .flush()
            .map_err(|e| LocalStorageError::StorageWriteError(e.to_string()))?;

        Ok(())
    }
}

#[cfg(test)]
mod storage_tests {
    use super::*;

    #[test]
    fn test_read_write() {
        const KEY: &[u8] = b"TEST_KEY_FOR_STORAGE";

        let payload = b"Hello, World!".to_vec();
        let db = LocalStorage::new("com.test_write", "WriteTest Corp", "WriteTest App").unwrap();

        db.set(KEY, &payload).unwrap();

        let out = db.get(KEY).unwrap();

        assert_eq!(out, payload);
    }
}

================
File: storage/Cargo.toml
================
[package]
name = "storage"
version = "0.1.0"
edition = "2021"

[dependencies]
zil_errors = { path = "../zil_errors" }
config = { path = "../config" }
bincode = { path = "../bincode" }
sled = "0.34.7"
hex = "0.4.3"
directories = "5.0.1"

================
File: wallet/src/account_type.rs
================
use bincode::ToBytes;
use config::SYS_SIZE;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::str::FromStr;
use zil_errors::account::AccountErrors;

pub const ACCOUNT_TYPE_SIZE: usize = SYS_SIZE + 1;

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum AccountType {
    Ledger(usize),     // Ledger cipher index
    Bip39HD(usize),    // HD key bip39 index
    PrivateKey(usize), // A storage key for cipher secret key
}

impl AccountType {
    pub fn from_bytes(bytes: &[u8; ACCOUNT_TYPE_SIZE]) -> Result<Self, AccountErrors> {
        let code = bytes[0];
        let bytes_value: [u8; SYS_SIZE] = bytes[1..]
            .try_into()
            .or(Err(AccountErrors::InvalidAccountTypeValue))?;
        let value: usize = usize::from_ne_bytes(bytes_value);

        match code {
            0 => Ok(AccountType::Ledger(value)),
            1 => Ok(AccountType::Bip39HD(value)),
            2 => Ok(AccountType::PrivateKey(value)),
            _ => Err(AccountErrors::InvalidAccountTypeCode),
        }
    }

    pub fn code(&self) -> u8 {
        match self {
            AccountType::Ledger(_) => 0,
            AccountType::Bip39HD(_) => 1,
            AccountType::PrivateKey(_) => 2,
        }
    }

    pub fn value(&self) -> usize {
        match self {
            AccountType::Ledger(v) => *v,
            AccountType::Bip39HD(v) => *v,
            AccountType::PrivateKey(v) => *v,
        }
    }
}

impl std::fmt::Display for AccountType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // TODO: unwrap should call
        let hex_str = hex::encode(self.to_bytes().unwrap());

        write!(f, "{}", hex_str)
    }
}

impl FromStr for AccountType {
    type Err = AccountErrors;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let bytes = hex::decode(s).map_err(|_| AccountErrors::InvalidAccountTypeCode)?;
        let bytes: [u8; ACCOUNT_TYPE_SIZE] = bytes
            .try_into()
            .or(Err(AccountErrors::InvalidAccountTypeCode))?;

        AccountType::from_bytes(&bytes)
    }
}

impl TryFrom<[u8; ACCOUNT_TYPE_SIZE]> for AccountType {
    type Error = AccountErrors;
    fn try_from(value: [u8; ACCOUNT_TYPE_SIZE]) -> Result<Self, Self::Error> {
        AccountType::from_bytes(&value)
    }
}

impl TryInto<[u8; ACCOUNT_TYPE_SIZE]> for AccountType {
    type Error = AccountErrors;

    fn try_into(self) -> Result<[u8; ACCOUNT_TYPE_SIZE], Self::Error> {
        Ok(self.to_bytes().unwrap())
    }
}

impl ToBytes<{ ACCOUNT_TYPE_SIZE }> for AccountType {
    type Error = AccountErrors;

    fn to_bytes(&self) -> Result<[u8; ACCOUNT_TYPE_SIZE], Self::Error> {
        let mut res = [0u8; ACCOUNT_TYPE_SIZE];
        let code = self.code();
        let value_bytes = self.value().to_ne_bytes();

        res[0] = code;
        res[1..].copy_from_slice(&value_bytes);
        Ok(res)
    }
}

impl Serialize for AccountType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'de> Deserialize<'de> for AccountType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        AccountType::from_str(&s).map_err(serde::de::Error::custom)
    }
}

#[cfg(test)]
mod tests_account_type {
    use super::*;

    #[test]
    fn test_bytes_try_into() {
        let origin_acc_type = AccountType::Ledger(42);
        let bytes = origin_acc_type.to_bytes().unwrap();
        let acc = AccountType::from_bytes(&bytes).unwrap();

        assert_eq!(acc, origin_acc_type);
    }

    #[test]
    fn test_invalid_bytes_try_into() {
        let origin_acc_type = AccountType::Ledger(42);
        let mut bytes = origin_acc_type.to_bytes().unwrap();

        bytes[0] = 69;

        let acc = AccountType::from_bytes(&bytes);

        assert_eq!(acc, Err(AccountErrors::InvalidAccountTypeCode));
    }

    #[test]
    fn test_from_to_str() {
        let origin_acc_type = AccountType::Ledger(42);
        let hex_str = origin_acc_type.to_string();
        let restored: AccountType = hex_str.parse().unwrap();

        assert_eq!(origin_acc_type, restored);
    }
}

================
File: wallet/src/account.rs
================
use crate::account_type::AccountType;
use bincode::{FromBytes, ToOptionVecBytes};
use config::sha::SHA512_SIZE;
use crypto::bip49::Bip49DerivationPath;
use proto::address::Address;
use proto::keypair::KeyPair;
use proto::pubkey::PubKey;
use proto::secret_key::SecretKey;
use serde::{Deserialize, Serialize};
use zil_errors::account::AccountErrors;

#[derive(Debug, PartialEq, Eq, Deserialize, Serialize, Clone)]
pub struct Account {
    pub name: String,
    pub account_type: AccountType,
    pub addr: Address,
    pub pub_key: PubKey,
}

impl Account {
    pub fn from_ledger(
        pub_key: &PubKey,
        name: String,
        cipher_index: usize,
    ) -> Result<Self, AccountErrors> {
        let addr = pub_key.get_addr().map_err(AccountErrors::PubKeyError)?;
        let account_type = AccountType::Ledger(cipher_index);

        Ok(Self {
            account_type,
            addr,
            name,
            pub_key: pub_key.to_owned(),
        })
    }

    pub fn from_secret_key(
        sk: &SecretKey,
        name: String,
        key: usize,
    ) -> Result<Self, AccountErrors> {
        let keypair = KeyPair::from_secret_key(sk).map_err(AccountErrors::InvalidSecretKeyBytes)?;
        let pub_key = keypair.get_pubkey().map_err(AccountErrors::InvalidPubKey)?;
        let addr = keypair.get_addr().map_err(AccountErrors::InvalidAddress)?;
        let account_type = AccountType::PrivateKey(key);

        Ok(Self {
            account_type,
            addr,
            pub_key,
            name,
        })
    }

    pub fn from_hd(
        mnemonic_seed: &[u8; SHA512_SIZE],
        name: String,
        bip49: &Bip49DerivationPath,
    ) -> Result<Self, AccountErrors> {
        let keypair =
            KeyPair::from_bip39_seed(mnemonic_seed, bip49).map_err(AccountErrors::InvalidSeed)?;
        let pub_key = keypair.get_pubkey().map_err(AccountErrors::InvalidPubKey)?;
        let addr = keypair.get_addr().map_err(AccountErrors::InvalidAddress)?;
        let account_type = AccountType::Bip39HD(bip49.get_index());

        Ok(Self {
            account_type,
            addr,
            pub_key,
            name,
        })
    }

    pub fn get_bip49(&self) -> Result<Bip49DerivationPath, AccountErrors> {
        match &self.account_type {
            AccountType::Bip39HD(v) => match &self.pub_key {
                PubKey::Secp256k1Sha256Zilliqa(_) => Ok(Bip49DerivationPath::Zilliqa(*v)),
                PubKey::Secp256k1Keccak256Ethereum(_) => Ok(Bip49DerivationPath::Ethereum(*v)),
                _ => Err(AccountErrors::InvalidPubKeyType),
            },
            _ => Err(AccountErrors::InvalidAccountType(
                self.account_type.to_string(),
            )),
        }
    }
}

// TODO: maybe remake it bytes encode.
impl ToOptionVecBytes for Account {
    type Error = AccountErrors;
    fn to_bytes(&self) -> Result<Vec<u8>, Self::Error> {
        serde_json::to_vec(&self).or(Err(AccountErrors::FailToSerialize))
    }
}

impl FromBytes for Account {
    type Error = AccountErrors;
    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Result<Self, Self::Error> {
        serde_json::from_slice(&bytes).or(Err(AccountErrors::FailToDeserialize))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use bip39::Mnemonic;
    use config::address::ADDR_LEN;
    use rand::RngCore;

    #[test]
    fn test_from_zil_sk_ser() {
        let mut rng = rand::thread_rng();

        let sk: SecretKey = "00e93c035175b08613c4b0251ca92cd007026ca032ba53bafa3c839838f8b52d04"
            .parse()
            .unwrap();
        let name = "Account 0";
        let acc = Account::from_secret_key(&sk, name.to_string(), 0).unwrap();

        for _ in 0..100 {
            let mut nft_addr = [0u8; ADDR_LEN];
            let mut ft_addr = [0u8; ADDR_LEN];

            rng.fill_bytes(&mut nft_addr);
            rng.fill_bytes(&mut ft_addr);
        }

        let json_file = serde_json::to_string(&acc).unwrap();
        let res_acc: Account = serde_json::from_str(&json_file).unwrap();

        assert_eq!(res_acc, acc);

        let buf = acc.to_bytes().unwrap();
        let res = Account::from_bytes(buf.into()).unwrap();

        assert_eq!(res.pub_key, acc.pub_key);
        assert_eq!(res.addr, acc.addr);
        assert_eq!(res, acc);
    }

    #[test]
    fn test_init_from_bip39() {
        let mut rng = rand::thread_rng();

        let mnemonic_str =
            "green process gate doctor slide whip priority shrug diamond crumble average help";
        let name = "Account 0";
        let m = Mnemonic::parse_normalized(mnemonic_str).unwrap();
        let bip49 = Bip49DerivationPath::Zilliqa(0);
        let seed = m.to_seed("");
        let acc = Account::from_hd(&seed, name.to_owned(), &bip49).unwrap();

        for _ in 0..100 {
            let mut nft_addr = [0u8; ADDR_LEN];
            let mut ft_addr = [0u8; ADDR_LEN];

            rng.fill_bytes(&mut nft_addr);
            rng.fill_bytes(&mut ft_addr);
        }

        let json_file = serde_json::to_string(&acc).unwrap();
        let res_acc: Account = serde_json::from_str(&json_file).unwrap();

        assert_eq!(res_acc, acc);

        let buf = acc.to_bytes().unwrap();
        let res = Account::from_bytes(buf.into()).unwrap();

        assert_eq!(res.pub_key, acc.pub_key);
        assert_eq!(res.addr, acc.addr);
        assert_eq!(res, acc);
    }
}

================
File: wallet/src/ft.rs
================
use std::collections::HashMap;

use alloy::primitives::U256;
use config::address::ADDR_LEN;
use proto::address::Address;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct FToken {
    pub name: String,
    pub symbol: String,
    pub decimals: u8,
    pub addr: Address,
    pub logo: Option<String>,
    pub balances: HashMap<Address, U256>,
    pub default: bool,
    pub native: bool,
}

impl FToken {
    pub fn zil() -> Self {
        FToken {
            default: true,
            name: "Zilliqa".to_string(),
            symbol: "ZIL".to_string(),
            decimals: 12,
            addr: Address::Secp256k1Sha256Zilliqa([0u8; ADDR_LEN]),
            logo: None, // TODO: add logo
            balances: HashMap::new(),
            native: true,
        }
    }

    pub fn eth() -> Self {
        FToken {
            default: true,
            name: "Ethereum".to_string(),
            symbol: "ETH".to_string(),
            decimals: 18,
            addr: Address::Secp256k1Keccak256Ethereum([0u8; ADDR_LEN]),
            logo: None, // TODO: add logo
            balances: HashMap::new(),
            native: true,
        }
    }
}

================
File: wallet/src/lib.rs
================
pub mod account;
pub mod account_type;
pub mod ft;
pub mod wallet_data;
pub mod wallet_types;

use std::sync::Arc;

use cipher::argon2::derive_key;
use config::argon::KEY_SIZE;
use config::cipher::{PROOF_SALT, PROOF_SIZE};
use config::storage::FTOKENS_DB_KEY;
use ft::FToken;
use proto::keypair::KeyPair;
use proto::pubkey::PubKey;
use proto::secret_key::SecretKey;
use proto::signature::Signature;
use proto::tx::{TransactionReceipt, TransactionRequest};
use rand::{Rng, SeedableRng};
use rand_chacha::ChaCha20Rng;

use bincode::{FromBytes, ToBytes};
use bip39::Mnemonic;
use cipher::keychain::KeyChain;
use config::sha::SHA256_SIZE;
use config::wallet::{N_BYTES_HASH, N_SALT};
use crypto::bip49::Bip49DerivationPath;
use settings::wallet_settings::WalletSettings;
use sha2::{Digest, Sha256};
use storage::LocalStorage;
use wallet_data::{AuthMethod, WalletData};
use wallet_types::WalletTypes;
use zil_errors::wallet::WalletErrors;

pub struct WalletConfig {
    pub storage: Arc<LocalStorage>,
    pub keychain: KeyChain,
    pub settings: WalletSettings,
}

pub struct LedgerParams<'a> {
    pub pub_key: &'a PubKey,
    pub ledger_id: Vec<u8>,
    pub name: String,
    pub wallet_index: usize,
    pub wallet_name: String,
    pub biometric_type: AuthMethod,
    pub networks: Vec<usize>,
}

pub struct Bip39Params<'a> {
    pub proof: &'a [u8; KEY_SIZE],
    pub mnemonic: &'a Mnemonic,
    pub passphrase: &'a str,
    pub indexes: &'a [(Bip49DerivationPath, String)],
    pub config: WalletConfig,
    pub wallet_name: String,
    pub biometric_type: AuthMethod,
    pub network: Vec<usize>,
}

pub struct Wallet {
    storage: Arc<LocalStorage>,
    pub data: WalletData,
    pub ftokens: Vec<FToken>,
}

fn safe_storage_save(
    cipher_entropy: &[u8],
    storage: Arc<LocalStorage>,
) -> Result<usize, WalletErrors> {
    let mut rng = ChaCha20Rng::from_entropy();
    let mut cipher_entropy_key: usize;

    loop {
        cipher_entropy_key = rng.r#gen();
        let key = usize::to_le_bytes(cipher_entropy_key);
        let is_exists_key = storage
            .exists(&key)
            .map_err(WalletErrors::FailToSaveCipher)?;

        if is_exists_key {
            continue;
        }

        storage
            .set(&key, cipher_entropy)
            .map_err(WalletErrors::FailToSaveCipher)?;

        break;
    }

    Ok(cipher_entropy_key)
}

impl Wallet {
    pub const ZIL_DEFAULT_TOKENS: usize = 1;
    pub const ETH_DEFAULT_TOKENS: usize = 1;

    pub fn load_from_storage(
        key: &[u8; SHA256_SIZE],
        storage: Arc<LocalStorage>,
    ) -> Result<Self, WalletErrors> {
        let data = storage
            .get(key)
            .map_err(WalletErrors::FailToLoadWalletData)?;
        let data = serde_json::from_slice::<WalletData>(&data)
            .or(Err(WalletErrors::FailToDeserializeWalletData))?;
        let ftokens = Vec::new();

        Ok(Self {
            storage,
            data,
            ftokens,
        })
    }

    pub fn from_ledger(
        params: LedgerParams,
        proof: &[u8; KEY_SIZE],
        config: WalletConfig,
    ) -> Result<Self, WalletErrors> {
        // TODO: add cipher for encrypt account index.
        let cipher_proof = config
            .keychain
            .make_proof(proof, &config.settings.crypto.cipher_orders)
            .map_err(WalletErrors::KeyChainMakeCipherProofError)?;
        let proof_key = safe_storage_save(&cipher_proof, Arc::clone(&config.storage))?;
        drop(cipher_proof);

        let mut hasher = Sha256::new();

        hasher.update(params.pub_key.as_bytes());
        hasher.update(&params.ledger_id);

        let wallet_address: [u8; SHA256_SIZE] = hasher.finalize().into();
        let wallet_address = hex::encode(wallet_address);
        let account =
            account::Account::from_ledger(params.pub_key, params.name, params.wallet_index)
                .or(Err(WalletErrors::InvalidSecretKeyAccount))?;

        let accounts: Vec<account::Account> = vec![account];
        let data = WalletData {
            network: params.networks,
            wallet_name: params.wallet_name,
            biometric_type: params.biometric_type,
            proof_key,
            settings: config.settings,
            accounts,
            wallet_address,
            wallet_type: WalletTypes::Ledger(params.ledger_id),
            selected_account: 0,
        };
        let ftokens = match params.pub_key {
            PubKey::Secp256k1Sha256Zilliqa(_) => {
                vec![FToken::zil()]
            }
            PubKey::Secp256k1Keccak256Ethereum(_) => {
                vec![FToken::eth()]
            }
            _ => unreachable!(),
        };

        Ok(Self {
            storage: config.storage,
            data,
            ftokens,
        })
    }

    pub fn from_sk(
        sk: &SecretKey,
        name: String,
        proof: &[u8; KEY_SIZE],
        config: WalletConfig,
        wallet_name: String,
        biometric_type: AuthMethod,
        network: Vec<usize>,
    ) -> Result<Self, WalletErrors> {
        let sk_as_bytes = sk.to_bytes().map_err(WalletErrors::FailToGetSKBytes)?;
        let mut combined = [0u8; SHA256_SIZE];

        combined[..N_BYTES_HASH].copy_from_slice(&sk_as_bytes[..N_BYTES_HASH]);
        combined[N_BYTES_HASH..].copy_from_slice(&N_SALT);

        let cipher_sk = config
            .keychain
            .encrypt(sk_as_bytes.to_vec(), &config.settings.crypto.cipher_orders)
            .or(Err(WalletErrors::TryEncryptSecretKeyError))?;
        let cipher_proof = config
            .keychain
            .make_proof(proof, &config.settings.crypto.cipher_orders)
            .map_err(WalletErrors::KeyChainMakeCipherProofError)?;
        let proof_key = safe_storage_save(&cipher_proof, Arc::clone(&config.storage))?;
        drop(cipher_proof);
        let cipher_entropy_key = safe_storage_save(&cipher_sk, Arc::clone(&config.storage))?;

        let mut hasher = Sha256::new();
        hasher.update(combined);

        let wallet_address: [u8; SHA256_SIZE] = hasher.finalize().into();
        let wallet_address = hex::encode(wallet_address);
        // SecretKey may stores only one account.
        let account = account::Account::from_secret_key(sk, name, cipher_entropy_key)
            .or(Err(WalletErrors::InvalidSecretKeyAccount))?;
        let accounts: Vec<account::Account> = vec![account];
        let data = WalletData {
            network,
            wallet_name,
            biometric_type,
            proof_key,
            settings: config.settings,
            accounts,
            wallet_address,
            wallet_type: WalletTypes::SecretKey,
            selected_account: 0,
        };
        let ftokens = match sk {
            SecretKey::Secp256k1Sha256Zilliqa(_) => {
                vec![FToken::zil()]
            }
            SecretKey::Secp256k1Keccak256Ethereum(_) => {
                vec![FToken::eth()]
            }
        };

        Ok(Self {
            storage: config.storage,
            data,
            ftokens,
        })
    }

    pub fn from_bip39_words(params: Bip39Params) -> Result<Self, WalletErrors> {
        let cipher_entropy = params
            .config
            .keychain
            .encrypt(
                params.mnemonic.to_entropy(),
                &params.config.settings.crypto.cipher_orders,
            )
            .map_err(WalletErrors::EncryptKeyChainErrors)?;
        let mut combined = [0u8; SHA256_SIZE];
        let mnemonic_seed = params.mnemonic.to_seed_normalized(params.passphrase);
        let cipher_proof = params
            .config
            .keychain
            .make_proof(params.proof, &params.config.settings.crypto.cipher_orders)
            .map_err(WalletErrors::KeyChainMakeCipherProofError)?;
        let proof_key = safe_storage_save(&cipher_proof, Arc::clone(&params.config.storage))?;
        drop(cipher_proof);
        let cipher_entropy_key =
            safe_storage_save(&cipher_entropy, Arc::clone(&params.config.storage))?;

        combined[..N_BYTES_HASH].copy_from_slice(&mnemonic_seed[..N_BYTES_HASH]);
        combined[N_BYTES_HASH..].copy_from_slice(&N_SALT);

        let mut hasher = Sha256::new();
        hasher.update(combined);

        let wallet_address: [u8; SHA256_SIZE] = hasher.finalize().into();
        let wallet_address = hex::encode(wallet_address);
        let mut accounts: Vec<account::Account> = Vec::with_capacity(params.indexes.len());

        for index in params.indexes {
            let (bip49, name) = index;
            let hd_account = account::Account::from_hd(&mnemonic_seed, name.to_owned(), bip49)
                .or(Err(WalletErrors::InvalidBip39Account))?;

            accounts.push(hd_account);
        }

        let ftokens = match accounts[0].pub_key {
            PubKey::Secp256k1Sha256Zilliqa(_) => {
                vec![FToken::zil()]
            }
            PubKey::Secp256k1Keccak256Ethereum(_) => {
                vec![FToken::eth()]
            }
            _ => unreachable!(),
        };
        let data = WalletData {
            network: params.network,
            wallet_name: params.wallet_name,
            biometric_type: params.biometric_type,
            proof_key,
            settings: params.config.settings,
            wallet_address,
            accounts,
            wallet_type: WalletTypes::SecretPhrase((
                cipher_entropy_key,
                !params.passphrase.is_empty(),
            )),
            selected_account: 0,
        };

        Ok(Self {
            storage: params.config.storage,
            data,
            ftokens,
        })
    }

    pub fn reveal_keypair(
        &self,
        account_index: usize,
        seed_bytes: &[u8; KEY_SIZE],
        passphrase: Option<&str>,
    ) -> Result<KeyPair, WalletErrors> {
        let keychain = KeyChain::from_seed(seed_bytes).map_err(WalletErrors::KeyChainError)?;

        match self.data.wallet_type {
            WalletTypes::SecretKey => {
                let account = self
                    .data
                    .accounts
                    .get(account_index)
                    .ok_or(WalletErrors::FailToGetAccount(account_index))?;
                let storage_key = usize::to_le_bytes(account.account_type.value());
                let cipher_sk = self
                    .storage
                    .get(&storage_key)
                    .map_err(WalletErrors::FailToGetContent)?;
                let sk_bytes = keychain
                    .decrypt(cipher_sk, &self.data.settings.crypto.cipher_orders)
                    .map_err(WalletErrors::DecryptKeyChainErrors)?;
                let sk = SecretKey::from_bytes(sk_bytes.into())
                    .map_err(WalletErrors::FailParseSKBytes)?;
                let keypair =
                    KeyPair::from_secret_key(&sk).map_err(WalletErrors::FailToCreateKeyPair)?;

                Ok(keypair)
            }
            WalletTypes::SecretPhrase((_key, is_phr)) => {
                if is_phr && passphrase.is_none() {
                    return Err(WalletErrors::PassphraseIsNone);
                }

                let account = self
                    .data
                    .accounts
                    .get(account_index)
                    .ok_or(WalletErrors::FailToGetAccount(account_index))?;
                let m = self.reveal_mnemonic(seed_bytes)?;
                let seed = m.to_seed(passphrase.unwrap_or(""));
                let bip49 = account.get_bip49().map_err(WalletErrors::InvalidBip49)?;
                let keypair = KeyPair::from_bip39_seed(&seed, &bip49)
                    .map_err(WalletErrors::FailToCreateKeyPair)?;

                Ok(keypair)
            }
            _ => Err(WalletErrors::InvalidAccountType),
        }
    }

    pub fn reveal_mnemonic(&self, seed_bytes: &[u8; KEY_SIZE]) -> Result<Mnemonic, WalletErrors> {
        match self.data.wallet_type {
            WalletTypes::SecretPhrase((key, _)) => {
                let keychain =
                    KeyChain::from_seed(seed_bytes).map_err(WalletErrors::KeyChainError)?;
                let storage_key = usize::to_le_bytes(key);
                let cipher_entropy = self
                    .storage
                    .get(&storage_key)
                    .map_err(WalletErrors::FailToGetContent)?;
                let entropy = keychain
                    .decrypt(cipher_entropy, &self.data.settings.crypto.cipher_orders)
                    .map_err(WalletErrors::DecryptKeyChainErrors)?;
                // TODO: add more Languages
                let m = Mnemonic::from_entropy_in(bip39::Language::English, &entropy)
                    .map_err(|e| WalletErrors::MnemonicError(e.to_string()))?;

                Ok(m)
            }
            _ => Err(WalletErrors::InvalidAccountType),
        }
    }

    pub fn sign_message(
        &self,
        msg: &[u8],
        account_index: usize,
        seed_bytes: &[u8; KEY_SIZE],
        passphrase: Option<&str>,
    ) -> Result<Signature, WalletErrors> {
        let keypair = self.reveal_keypair(account_index, seed_bytes, passphrase)?;
        let sig = keypair
            .sign_message(msg)
            .map_err(WalletErrors::FailSignMessage)?;
        let vrify = keypair
            .verify_sig(msg, &sig)
            .map_err(WalletErrors::FailVerifySig)?;

        if !vrify {
            return Err(WalletErrors::InvalidVerifySig);
        }

        Ok(sig)
    }

    pub async fn sign_transaction(
        &self,
        tx: &TransactionRequest,
        account_index: usize,
        seed_bytes: &[u8; KEY_SIZE],
        passphrase: Option<&str>,
    ) -> Result<TransactionReceipt, WalletErrors> {
        let keypair = self.reveal_keypair(account_index, seed_bytes, passphrase)?;

        keypair
            .sign_tx(tx)
            .await
            .map_err(WalletErrors::FailToSignTransaction)
    }

    pub fn unlock(&mut self, seed_bytes: &[u8; KEY_SIZE]) -> Result<(), WalletErrors> {
        self.unlock_iternel(seed_bytes)?;

        let bytes = self.storage.get(FTOKENS_DB_KEY).unwrap_or_default();
        let ftokens: Vec<FToken> = serde_json::from_slice(&bytes).unwrap_or_default();
        let selected = self
            .data
            .accounts
            .get(self.data.selected_account)
            .ok_or(WalletErrors::FailToGetAccount(self.data.selected_account))?;

        match selected.pub_key {
            PubKey::Secp256k1Sha256Zilliqa(_) => self.ftokens = vec![FToken::zil()],
            PubKey::Secp256k1Keccak256Ethereum(_) => self.ftokens = vec![FToken::eth()],
            _ => unreachable!(),
        }

        self.ftokens.extend_from_slice(&ftokens);

        Ok(())
    }

    fn unlock_iternel(&mut self, seed_bytes: &[u8; KEY_SIZE]) -> Result<KeyChain, WalletErrors> {
        let keychain = KeyChain::from_seed(seed_bytes).map_err(WalletErrors::KeyChainError)?;

        let proof_key = usize::to_le_bytes(self.data.proof_key);
        let cipher_proof = self
            .storage
            .get(&proof_key)
            .map_err(WalletErrors::FailToGetProofFromStorage)?;

        let origin_proof = keychain
            .get_proof(&cipher_proof, &self.data.settings.crypto.cipher_orders)
            .or(Err(WalletErrors::KeyChainFailToGetProof))?;

        let proof = derive_key(&seed_bytes[..PROOF_SIZE], PROOF_SALT)
            .map_err(WalletErrors::ArgonCipherErrors)?;

        if proof != origin_proof {
            return Err(WalletErrors::ProofNotMatch);
        }

        Ok(keychain)
    }

    pub fn add_ftoken(&mut self, token: FToken) -> Result<(), WalletErrors> {
        self.ftokens.push(token);

        let ftokens: Vec<&FToken> = self.ftokens.iter().filter(|token| !token.default).collect();
        let bytes = serde_json::to_vec(&ftokens).or(Err(WalletErrors::FailToSerializeToken))?;

        self.storage
            .set(FTOKENS_DB_KEY, &bytes)
            .map_err(WalletErrors::FailtoSaveFTokensToStorage)?;
        self.storage
            .flush()
            .map_err(WalletErrors::StorageFailFlush)?;

        Ok(())
    }

    pub fn remove_ftoken(&mut self, index: usize) -> Result<(), WalletErrors> {
        if self.ftokens.get(index).is_none() {
            return Err(WalletErrors::TokenNotExists(index));
        }

        self.ftokens.remove(index);

        let ftokens: Vec<&FToken> = self.ftokens.iter().filter(|token| !token.default).collect();
        let bytes = serde_json::to_vec(&ftokens).or(Err(WalletErrors::FailToSerializeToken))?;

        self.storage
            .set(FTOKENS_DB_KEY, &bytes)
            .map_err(WalletErrors::FailtoSaveFTokensToStorage)?;
        self.storage
            .flush()
            .map_err(WalletErrors::StorageFailFlush)?;

        Ok(())
    }

    pub fn save_to_storage(&self) -> Result<(), WalletErrors> {
        let json_bytes =
            serde_json::to_vec(&self.data).or(Err(WalletErrors::FailToSerializeWalletData))?;
        let key = self.key()?;

        self.storage
            .set(&key, &json_bytes)
            .map_err(WalletErrors::FailtoSaveWalletDataToStorage)?;
        self.storage
            .flush()
            .map_err(WalletErrors::StorageFailFlush)?;

        Ok(())
    }

    #[inline]
    pub fn key(&self) -> Result<[u8; SHA256_SIZE], WalletErrors> {
        hex::decode(&self.data.wallet_address)
            .or(Err(WalletErrors::InvalidWalletAddressHex))?
            .try_into()
            .or(Err(WalletErrors::InvalidWalletAddressSize))
    }
}

#[cfg(test)]
mod tests {
    use core::panic;
    use std::{collections::HashMap, sync::Arc};

    use bip39::Mnemonic;
    use cipher::{argon2::derive_key, keychain::KeyChain};
    use config::{
        argon::KEY_SIZE,
        cipher::{PROOF_SALT, PROOF_SIZE},
        sha::SHA256_SIZE,
    };
    use crypto::bip49::Bip49DerivationPath;
    use proto::{address::Address, keypair::KeyPair};
    use rand::Rng;
    use storage::LocalStorage;
    use zil_errors::wallet::WalletErrors;

    use crate::{
        ft::FToken, wallet_data::AuthMethod, wallet_types::WalletTypes, Bip39Params, Wallet,
        WalletConfig,
    };

    const MNEMONIC_STR: &str =
        "green process gate doctor slide whip priority shrug diamond crumble average help";
    const PASSWORD: &[u8] = b"Test_password";
    const PASSPHRASE: &str = "";

    #[test]
    fn test_init_from_bip39_zil() {
        let argon_seed = derive_key(PASSWORD, "").unwrap();
        let storage = LocalStorage::new(
            "com.test_write_wallet",
            "WriteTest Wallet Corp",
            "WalletWriteTest App",
        )
        .unwrap();
        let storage = Arc::new(storage);
        let keychain = KeyChain::from_seed(&argon_seed).unwrap();
        let mnemonic =
            Mnemonic::parse_in_normalized(bip39::Language::English, MNEMONIC_STR).unwrap();
        let indexes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
            .map(|i| (Bip49DerivationPath::Zilliqa(i), format!("account {i}")));
        let proof = derive_key(&argon_seed[..PROOF_SIZE], "").unwrap();
        let wallet_config = WalletConfig {
            keychain,
            storage: Arc::clone(&storage),
            settings: Default::default(),
        };
        let wallet = Wallet::from_bip39_words(Bip39Params {
            proof: &proof,
            mnemonic: &mnemonic,
            passphrase: PASSPHRASE,
            indexes: &indexes,
            config: wallet_config,
            wallet_name: "Wllaet name".to_string(),
            biometric_type: AuthMethod::Biometric,
            network: vec![0],
        })
        .unwrap();

        wallet.save_to_storage().unwrap();

        match wallet.data.wallet_type {
            WalletTypes::SecretPhrase((_, is_phr)) => {
                assert!(!is_phr);
            }
            _ => panic!("invalid type"),
        }

        assert_eq!(wallet.data.accounts.len(), indexes.len());

        let wallet_addr: [u8; SHA256_SIZE] = hex::decode(wallet.data.wallet_address.clone())
            .unwrap()
            .try_into()
            .unwrap();

        drop(wallet);

        let res_wallet = Wallet::load_from_storage(&wallet_addr, Arc::clone(&storage)).unwrap();

        assert!(res_wallet.reveal_mnemonic(&[0u8; KEY_SIZE]).is_err());
        assert!(res_wallet.reveal_mnemonic(&argon_seed).is_ok());
    }

    #[test]
    fn test_init_from_sk() {
        let argon_seed = derive_key(PASSWORD, "").unwrap();
        let proof = derive_key(&argon_seed[..PROOF_SIZE], "").unwrap();
        let mut rng = rand::thread_rng();
        let dir = format!("/tmp/{}", rng.gen::<usize>());
        let storage = LocalStorage::from(&dir).unwrap();

        let storage = Arc::new(storage);
        let keychain = KeyChain::from_seed(&argon_seed).unwrap();
        let keypair = KeyPair::gen_keccak256().unwrap();
        let sk = keypair.get_secretkey().unwrap();
        let name = "SK Account 0";
        let wallet_config = WalletConfig {
            keychain,
            storage: Arc::clone(&storage),
            settings: Default::default(),
        };
        let wallet = Wallet::from_sk(
            &sk,
            name.to_string(),
            &proof,
            wallet_config,
            "test Name".to_string(),
            Default::default(),
            vec![0],
        )
        .unwrap();

        assert_eq!(wallet.data.accounts.len(), 1);
        assert_eq!(
            wallet.reveal_mnemonic(&argon_seed),
            Err(WalletErrors::InvalidAccountType)
        );

        let wallet_addr: [u8; SHA256_SIZE] = hex::decode(wallet.data.wallet_address.clone())
            .unwrap()
            .try_into()
            .unwrap();
        wallet.save_to_storage().unwrap();

        let w = Wallet::load_from_storage(&wallet_addr, Arc::clone(&storage)).unwrap();

        assert_eq!(w.data, wallet.data);
    }

    #[test]
    fn test_add_and_load_tokens() {
        // Setup initial wallet with secret key
        let argon_seed = derive_key(PASSWORD, PROOF_SALT).unwrap();
        let proof = derive_key(&argon_seed[..PROOF_SIZE], PROOF_SALT).unwrap();
        let mut rng = rand::thread_rng();
        let dir = format!("/tmp/{}", rng.gen::<usize>());
        let storage = LocalStorage::from(&dir).unwrap();
        let storage = Arc::new(storage);
        let keychain = KeyChain::from_seed(&argon_seed).unwrap();

        // Generate ETH keypair for test wallet
        let keypair = KeyPair::gen_keccak256().unwrap();
        let sk = keypair.get_secretkey().unwrap();

        let wallet_config = WalletConfig {
            keychain,
            storage: Arc::clone(&storage),
            settings: Default::default(),
        };

        // Create wallet
        let mut wallet = Wallet::from_sk(
            &sk,
            "Test Token Account".to_string(),
            &proof,
            wallet_config,
            "Token Test Wallet".to_string(),
            Default::default(),
            vec![0],
        )
        .unwrap();

        // Verify initial state - should only have default ETH token
        assert_eq!(wallet.ftokens.len(), 1);
        assert!(wallet.ftokens[0].default);
        assert_eq!(wallet.ftokens[0].symbol, "ETH");

        // Create custom token
        let custom_token = FToken {
            name: "Test Token".to_string(),
            symbol: "TST".to_string(),
            decimals: 18,
            addr: Address::from_zil_base16("e876b112a62f945484ede1f3ccdd6b0ac6f39382").unwrap(),
            logo: None,
            default: false,
            native: false,
            balances: HashMap::new(),
        };

        // Add custom token
        wallet.add_ftoken(custom_token.clone()).unwrap();

        // Verify token was added
        assert_eq!(wallet.ftokens.len(), 2);
        assert_eq!(wallet.ftokens[1].symbol, "TST");
        assert!(!wallet.ftokens[1].default);

        // Save wallet state
        let wallet_addr = wallet.key().unwrap();
        wallet.save_to_storage().unwrap();

        // Create new wallet instance from storage
        let mut loaded_wallet =
            Wallet::load_from_storage(&wallet_addr, Arc::clone(&storage)).unwrap();

        // Before unlock - should have empty token list
        assert_eq!(loaded_wallet.ftokens.len(), 0);

        // Unlock wallet - should restore tokens
        loaded_wallet.unlock(&argon_seed).unwrap();

        // Verify tokens were restored correctly
        assert_eq!(loaded_wallet.ftokens.len(), 2);

        // Verify default token
        assert!(loaded_wallet.ftokens[0].default);
        assert_eq!(loaded_wallet.ftokens[0].symbol, "ETH");

        // Verify custom token
        assert!(!loaded_wallet.ftokens[1].default);
        assert_eq!(loaded_wallet.ftokens[1].symbol, "TST");
        assert_eq!(loaded_wallet.ftokens[1].addr, custom_token.addr);
        assert_eq!(loaded_wallet.ftokens[1].decimals, custom_token.decimals);
    }

    #[test]
    fn test_multiple_custom_tokens() {
        // Setup wallet similar to previous test
        let argon_seed = derive_key(PASSWORD, PROOF_SALT).unwrap();
        let proof = derive_key(&argon_seed[..PROOF_SIZE], PROOF_SALT).unwrap();
        let mut rng = rand::thread_rng();
        let dir = format!("/tmp/{}", rng.gen::<usize>());
        let storage = LocalStorage::from(&dir).unwrap();
        let storage = Arc::new(storage);
        let keychain = KeyChain::from_seed(&argon_seed).unwrap();
        let keypair = KeyPair::gen_keccak256().unwrap();
        let sk = keypair.get_secretkey().unwrap();

        let wallet_config = WalletConfig {
            keychain,
            storage: Arc::clone(&storage),
            settings: Default::default(),
        };

        let mut wallet = Wallet::from_sk(
            &sk,
            "Multi Token Account".to_string(),
            &proof,
            wallet_config,
            "Multi Token Test Wallet".to_string(),
            Default::default(),
            vec![0],
        )
        .unwrap();

        // Add multiple custom tokens
        let tokens = vec![
            FToken {
                name: "Token 1".to_string(),
                symbol: "TK1".to_string(),
                decimals: 18,
                addr: Address::from_zil_base16("1111111111111111111111111111111111111111").unwrap(),
                native: true,
                logo: None,
                default: false,
                balances: HashMap::new(),
            },
            FToken {
                name: "Token 2".to_string(),
                symbol: "TK2".to_string(),
                decimals: 6,
                addr: Address::from_zil_base16("2222222222222222222222222222222222222222").unwrap(),
                native: true,
                logo: None,
                default: false,
                balances: HashMap::new(),
            },
            FToken {
                name: "Token 3".to_string(),
                symbol: "TK3".to_string(),
                decimals: 8,
                native: true,
                addr: Address::from_zil_base16("3333333333333333333333333333333333333333").unwrap(),
                logo: None,
                default: false,
                balances: HashMap::new(),
            },
        ];

        // Add all tokens
        for token in tokens.iter() {
            wallet.add_ftoken(token.clone()).unwrap();
        }

        // Verify all tokens were added (1 default + 3 custom)
        assert_eq!(wallet.ftokens.len(), 4);

        // Save and reload wallet
        let wallet_addr = wallet.key().unwrap();
        wallet.save_to_storage().unwrap();

        let mut loaded_wallet =
            Wallet::load_from_storage(&wallet_addr, Arc::clone(&storage)).unwrap();
        loaded_wallet.unlock(&argon_seed).unwrap();

        // Verify all tokens were restored
        assert_eq!(loaded_wallet.ftokens.len(), 4);

        // Verify default token
        assert!(loaded_wallet.ftokens[0].default);
        assert_eq!(loaded_wallet.ftokens[0].symbol, "ETH");

        // Verify custom tokens
        for (i, token) in tokens.iter().enumerate() {
            assert_eq!(loaded_wallet.ftokens[i + 1].name, token.name);
            assert_eq!(loaded_wallet.ftokens[i + 1].symbol, token.symbol);
            assert_eq!(loaded_wallet.ftokens[i + 1].decimals, token.decimals);
            assert_eq!(loaded_wallet.ftokens[i + 1].addr, token.addr);
            assert!(!loaded_wallet.ftokens[i + 1].default);
        }
    }

    #[test]
    fn test_remove_tokens() {
        // Setup wallet
        let argon_seed = derive_key(PASSWORD, PROOF_SALT).unwrap();
        let proof = derive_key(&argon_seed[..PROOF_SIZE], PROOF_SALT).unwrap();
        let mut rng = rand::thread_rng();
        let dir = format!("/tmp/{}", rng.gen::<usize>());
        let storage = LocalStorage::from(&dir).unwrap();
        let storage = Arc::new(storage);
        let keychain = KeyChain::from_seed(&argon_seed).unwrap();
        let keypair = KeyPair::gen_keccak256().unwrap();
        let sk = keypair.get_secretkey().unwrap();

        let wallet_config = WalletConfig {
            keychain,
            storage: Arc::clone(&storage),
            settings: Default::default(),
        };

        let mut wallet = Wallet::from_sk(
            &sk,
            "Remove Token Test Account".to_string(),
            &proof,
            wallet_config,
            "Remove Token Test Wallet".to_string(),
            Default::default(),
            vec![0],
        )
        .unwrap();

        // Add multiple custom tokens
        let tokens = vec![
            FToken {
                name: "Token 1".to_string(),
                symbol: "TK1".to_string(),
                decimals: 18,
                addr: Address::from_zil_base16("1111111111111111111111111111111111111111").unwrap(),
                logo: None,
                default: false,
                native: true,
                balances: HashMap::new(),
            },
            FToken {
                name: "Token 2".to_string(),
                symbol: "TK2".to_string(),
                decimals: 6,
                addr: Address::from_zil_base16("2222222222222222222222222222222222222222").unwrap(),
                logo: None,
                default: false,
                native: true,
                balances: HashMap::new(),
            },
            FToken {
                name: "Token 3".to_string(),
                symbol: "TK3".to_string(),
                decimals: 8,
                addr: Address::from_zil_base16("3333333333333333333333333333333333333333").unwrap(),
                logo: None,
                native: true,
                default: false,
                balances: HashMap::new(),
            },
        ];

        // Add all tokens
        for token in tokens.iter() {
            wallet.add_ftoken(token.clone()).unwrap();
        }

        // Initial state should have 4 tokens (1 default + 3 custom)
        assert_eq!(wallet.ftokens.len(), 4);
        assert!(wallet.ftokens[0].default); // Default ETH token
        assert_eq!(wallet.ftokens[1].symbol, "TK1");
        assert_eq!(wallet.ftokens[2].symbol, "TK2");
        assert_eq!(wallet.ftokens[3].symbol, "TK3");

        // Try to remove a custom token (Token 2)
        wallet.remove_ftoken(2).unwrap();

        // Should now have 3 tokens (1 default + 2 custom)
        assert_eq!(wallet.ftokens.len(), 3);
        assert!(wallet.ftokens[0].default); // Default ETH token should still be first
        assert_eq!(wallet.ftokens[1].symbol, "TK1");
        assert_eq!(wallet.ftokens[2].symbol, "TK3"); // TK2 should be gone

        // Save and reload wallet to verify persistence
        let wallet_addr = wallet.key().unwrap();
        wallet.save_to_storage().unwrap();

        let mut loaded_wallet =
            Wallet::load_from_storage(&wallet_addr, Arc::clone(&storage)).unwrap();
        loaded_wallet.unlock(&argon_seed).unwrap();

        // Verify state after reload
        assert_eq!(loaded_wallet.ftokens.len(), 3);
        assert!(loaded_wallet.ftokens[0].default);
        assert_eq!(loaded_wallet.ftokens[1].symbol, "TK1");
        assert_eq!(loaded_wallet.ftokens[2].symbol, "TK3");

        // Try to remove default token (should still work but token will be restored on reload)
        wallet.remove_ftoken(0).unwrap();
        assert_eq!(wallet.ftokens.len(), 2);
        assert_eq!(wallet.ftokens[0].symbol, "TK1");
        assert_eq!(wallet.ftokens[1].symbol, "TK3");

        // Save and reload again
        wallet.save_to_storage().unwrap();
        let mut loaded_wallet2 =
            Wallet::load_from_storage(&wallet_addr, Arc::clone(&storage)).unwrap();
        loaded_wallet2.unlock(&argon_seed).unwrap();

        // Default token should be restored
        assert_eq!(loaded_wallet2.ftokens.len(), 3);
        assert!(loaded_wallet2.ftokens[0].default);
        assert_eq!(loaded_wallet2.ftokens[0].symbol, "ETH");
        assert_eq!(loaded_wallet2.ftokens[1].symbol, "TK1");
        assert_eq!(loaded_wallet2.ftokens[2].symbol, "TK3");
    }
}

================
File: wallet/src/wallet_data.rs
================
use crate::{account::Account, wallet_types::WalletTypes};
use serde::{Deserialize, Serialize};
use settings::wallet_settings::WalletSettings;

#[derive(Debug, Default, Serialize, Deserialize, PartialEq, Eq, Clone, Copy)]
pub enum AuthMethod {
    FaceId,
    Fingerprint,
    Biometric,
    PinCode,
    #[default]
    None,
}

impl From<AuthMethod> for String {
    fn from(method: AuthMethod) -> Self {
        match method {
            AuthMethod::FaceId => "faceId".to_string(),
            AuthMethod::Fingerprint => "fingerprint".to_string(),
            AuthMethod::Biometric => "biometric".to_string(),
            AuthMethod::PinCode => "pinCode".to_string(),
            AuthMethod::None => "none".to_string(),
        }
    }
}

impl From<String> for AuthMethod {
    fn from(s: String) -> Self {
        match s.as_str() {
            "faceId" => AuthMethod::FaceId,
            "fingerprint" => AuthMethod::Fingerprint,
            "biometric" => AuthMethod::Biometric,
            "pinCode" => AuthMethod::PinCode,
            _ => AuthMethod::None,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct WalletData {
    pub proof_key: usize,
    pub wallet_type: WalletTypes,
    pub settings: WalletSettings,
    pub wallet_name: String,
    pub wallet_address: String,
    pub accounts: Vec<Account>,
    pub selected_account: usize,
    pub biometric_type: AuthMethod,
    pub network: Vec<usize>,
}

================
File: wallet/src/wallet_types.rs
================
use std::str::FromStr;

use bincode::{FromBytes, ToVecBytes};
use config::SYS_SIZE;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use zil_errors::wallet::WalletErrors;

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum WalletTypes {
    Ledger(Vec<u8>), // Ledger product_id or uuid
    // Cipher for entropy secret words storage_key / passphrase
    SecretPhrase((usize, bool)),
    SecretKey,
}

impl WalletTypes {
    pub fn code(&self) -> u8 {
        match self {
            Self::Ledger(_) => 0,
            Self::SecretPhrase(_) => 1,
            Self::SecretKey => 2,
        }
    }
}

impl std::fmt::Display for WalletTypes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let hex_str = hex::encode(self.to_bytes());
        write!(f, "{}", hex_str)
    }
}

impl FromStr for WalletTypes {
    type Err = WalletErrors;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let bytes = hex::decode(s).map_err(|_| WalletErrors::InvalidHexToWalletType)?;

        WalletTypes::from_bytes(bytes.into())
    }
}

impl ToVecBytes for WalletTypes {
    fn to_bytes(&self) -> Vec<u8> {
        let code = self.code();

        match self {
            Self::Ledger(value) => {
                let mut bytes = vec![];

                bytes.push(code);
                bytes.extend_from_slice(value);

                bytes
            }
            Self::SecretPhrase((storage_key, passphrase)) => {
                let mut bytes = vec![0u8; SYS_SIZE + 2];

                bytes[0] = code;

                if *passphrase {
                    bytes[1] = 1;
                } else {
                    bytes[1] = 0;
                }

                bytes[2..].copy_from_slice(&storage_key.to_ne_bytes());

                bytes
            }
            Self::SecretKey => {
                vec![code]
            }
        }
    }
}

impl Serialize for WalletTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'de> Deserialize<'de> for WalletTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        WalletTypes::from_str(&s).map_err(serde::de::Error::custom)
    }
}

impl FromBytes for WalletTypes {
    type Error = WalletErrors;

    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Result<Self, Self::Error> {
        match bytes[0] {
            0 => Ok(Self::Ledger(bytes[1..].to_vec())),
            1 => {
                let passphrase = if bytes[1] == 1 {
                    true
                } else if bytes[1] == 0 {
                    false
                } else {
                    return Err(WalletErrors::InvalidWalletTypeValue);
                };
                let bytes_value: [u8; SYS_SIZE] = bytes[2..]
                    .try_into()
                    .or(Err(WalletErrors::InvalidWalletTypeValue))?;
                let value: usize = usize::from_ne_bytes(bytes_value);

                Ok(Self::SecretPhrase((value, passphrase)))
            }
            2 => Ok(Self::SecretKey),
            _ => Err(WalletErrors::UnknownWalletType(bytes[0])),
        }
    }
}

#[cfg(test)]
mod tests_wallet_type {
    use rand::RngCore;

    use super::*;

    #[test]
    fn tests_wallet_type_convert() {
        let mut rng = rand::thread_rng();
        let mut ledger_uuid = vec![0u8; 128];

        rng.fill_bytes(&mut ledger_uuid);

        let ledger_type = WalletTypes::Ledger(ledger_uuid);
        let secret_phrase_type = WalletTypes::SecretPhrase((69, true));
        let secret_key_type = WalletTypes::SecretKey;

        let ledger_type_bytes = ledger_type.to_bytes();
        let secret_phrase_type_bytes = secret_phrase_type.to_bytes();
        let secret_key_type_bytes = secret_key_type.to_bytes();

        let res_ledger_type = WalletTypes::from_bytes(ledger_type_bytes.into()).unwrap();
        let res_secret_phrase_type =
            WalletTypes::from_bytes(secret_phrase_type_bytes.into()).unwrap();
        let res_secret_key_type = WalletTypes::from_bytes(secret_key_type_bytes.into()).unwrap();

        assert_eq!(res_ledger_type, ledger_type);
        assert_eq!(res_secret_phrase_type, secret_phrase_type);
        assert_eq!(res_secret_key_type, res_secret_key_type);

        let ledger_type_hex = ledger_type.to_string();
        let secret_phrase_type_hex = secret_phrase_type.to_string();
        let secret_key_type_hex = secret_key_type.to_string();

        let res_ledger_type = WalletTypes::from_str(&ledger_type_hex).unwrap();
        let res_secret_phrase_type = WalletTypes::from_str(&secret_phrase_type_hex).unwrap();
        let res_secret_key_type = WalletTypes::from_str(&secret_key_type_hex).unwrap();

        assert_eq!(res_ledger_type, ledger_type);
        assert_eq!(res_secret_phrase_type, secret_phrase_type);
        assert_eq!(res_secret_key_type, res_secret_key_type);
    }
}

================
File: wallet/Cargo.toml
================
[package]
name = "wallet"
version = "0.1.0"
edition = "2021"

[dependencies]
zil_errors = { path = "../zil_errors" }
config = { path = "../config" }
crypto = { path = "../crypto" }
proto = { path = "../proto" }
session = { path = "../session" }
cipher = { path = "../cipher" }
storage = { path = "../storage" }
settings = { path = "../settings" }
bincode = { path = "../bincode" }
serde = { version = "1.0.204", features = ["derive"] }
bip39 = "2.0.0"
sha2 = "0.10.8"
hex = "0.4.3"
rand_chacha = "0.3.1"
rand = "0.8.5"
serde_json = "1.0.124"
alloy = { version = "0.4.2", features = ["signer-local", "network", "consensus", "rpc", "rpc-types"] }

================
File: zil_errors/src/account.rs
================
use crate::{
    address::AddressError,
    keypair::{KeyPairError, PubKeyError},
    LocalStorageError,
};
use thiserror::Error;

#[derive(Debug, Error, PartialEq, Eq)]
pub enum AccountErrors {
    #[error("Fail to get address form pub_key: {0}")]
    PubKeyError(PubKeyError),
    #[error("Invalid PubKey type")]
    InvalidPubKeyType,
    #[error("Invalid Account type: {0}")]
    InvalidAccountType(String),
    #[error("Fail to deserialize json")]
    FailToDeserialize,
    #[error("Fail to serialize json")]
    FailToSerialize,
    #[error("Invalid secret key bytes: {0}")]
    InvalidSecretKeyBytes(KeyPairError),
    #[error("Invalid secret key: {0}")]
    InvalidSecretKey(KeyPairError),
    #[error("Invalid public key: {0}")]
    InvalidPubKey(KeyPairError),
    #[error("Invalid address: {0}")]
    InvalidAddress(KeyPairError),
    #[error("Error converting address from public key: {0}")]
    AddrFromPubKeyError(#[from] AddressError),
    #[error("Failed to save cipher: {0}")]
    FailToSaveCipher(#[from] LocalStorageError),
    #[error("Invalid seed: {0}")]
    InvalidSeed(KeyPairError),
    #[error("Invalid secret bytes")]
    InvalidSecretBytes,
    #[error("Invalid account type code")]
    InvalidAccountTypeCode,
    #[error("Not enough bytes to create from bytes")]
    FromBytesErrorNotEnoughBytes,
    #[error("Invalide account type value")]
    InvalidAccountTypeValue,
}

================
File: zil_errors/src/address.rs
================
use thiserror::Error;

#[derive(Debug, Error, PartialEq, Eq)]
pub enum AddressError {
    #[error("invalid eth address: {0}")]
    InvalidETHAddress(String),

    #[error("Invalid VerifyingKey {0}")]
    InvalidVerifyingKey(String),

    #[error("Invalid hex Address")]
    InvalidHex,

    #[error("Invalid address length")]
    InvalidLength,

    #[error("Invalid key type")]
    InvalidKeyType,

    #[error("Invalid public key")]
    InvalidPubKey,

    #[error("Invalid Secp256k1Sha256 type")]
    InvalidSecp256k1Sha256Type,

    #[error("Invalid address bytes for Bech32")]
    InvalidAddressBytesForBech32,

    #[error("Invalid Base16 address")]
    InvalidBase16Address,

    #[error("Invalid address size")]
    InvalidAddressSize,

    #[error("Invalid HRP (Human-Readable Part)")]
    InvalidHRP,

    #[error("Invalid Bech32 length")]
    InvalidBech32Len,

    #[error("Not implemented")]
    NotImpl,
}

================
File: zil_errors/src/background.rs
================
use thiserror::Error;

use crate::{
    cipher::CipherErrors, keychain::KeyChainErrors, keypair::KeyPairError, network::NetworkErrors,
    session::SessionErrors, storage::LocalStorageError, wallet::WalletErrors,
};

#[derive(Debug, Error, PartialEq, Eq)]
pub enum BackgroundError {
    #[error("Fail, network error: {0}")]
    NetworkErrors(NetworkErrors),

    #[error("Network provider does not exist with ID: {0}")]
    NetworkProviderNotExists(usize),

    #[error("Failed to serialize networks")]
    FailToSerializeNetworks,

    #[error("Ledger ID already exists")]
    LedgerIdExists(String),

    #[error("Failed to decrypt session: {0}")]
    DecryptSessionError(SessionErrors),

    #[error("Failed to unlock wallet: {0}")]
    FailUnlockWallet(WalletErrors),

    #[error("Wallet not found with index: {0}")]
    WalletNotExists(usize),

    #[error("Storage flush error: {0}")]
    LocalStorageFlushError(LocalStorageError),

    #[error("Failed to generate key pair: {0}")]
    FailToGenKeyPair(KeyPairError),

    #[error("Invalid BIP39 word count: {0}")]
    InvalidWordCount(u8),

    #[error("Failed to generate BIP39 words from entropy: {0}")]
    FailToGenBip39FromEntropy(String),

    #[error("Failed to initialize storage: {0}")]
    TryInitLocalStorageError(LocalStorageError),

    #[error("Failed to write wallet indicators to DB: {0}")]
    FailToWriteIndicatorsWallet(LocalStorageError),

    #[error("Failed to load wallet from storage: {0}")]
    TryLoadWalletError(WalletErrors),

    #[error("Failed to write selected wallet: {0}")]
    FailWriteSelectedWallet(LocalStorageError),

    #[error("Argon2 password hashing error: {0}")]
    ArgonPasswordHashError(CipherErrors),

    #[error("Argon2 proof creation error: {0}")]
    ArgonCreateProofError(CipherErrors),

    #[error("Failed to create session: {0}")]
    CreateSessionError(SessionErrors),

    #[error("Failed to create keychain from Argon2 seed: {0}")]
    FailCreateKeychain(KeyChainErrors),

    #[error("Failed to parse mnemonic words: {0}")]
    FailParseMnemonicWords(String),

    #[error("Failed to initialize wallet: {0}")]
    FailToInitWallet(WalletErrors),

    #[error("Failed to save wallet data: {0}")]
    FailToSaveWallet(WalletErrors),
}

================
File: zil_errors/src/cipher.rs
================
use thiserror::Error;

#[derive(Debug, Error, PartialEq, Eq)]
pub enum CipherErrors {
    #[error("Argon key derivation error: {0}")]
    ArgonKeyDerivingError(String),
    #[error("Invalid enum code")]
    InvalidTypeCode,
}

#[derive(Debug, Error, PartialEq, Eq)]
pub enum AesGCMErrors {
    #[error("Encryption error: {0}")]
    EncryptError(String),
    #[error("Decryption error: {0}")]
    DecryptError(String),
}

================
File: zil_errors/src/crypto.rs
================
use crate::keypair::PubKeyError;
use thiserror::Error;

#[derive(Debug, Error, PartialEq, Eq)]
pub enum SignatureError {
    #[error("Invalid signature length")]
    InvalidLength,
    #[error("Failed to parse signature")]
    FailParseSignature,
    #[error("Failed to convert into public key: {0}")]
    FailIntoPubKey(#[from] PubKeyError),
    #[error("Failed to parse recovery information: {0}")]
    FailParseRecover(String),
}

#[derive(Debug, Error, PartialEq, Eq)]
pub enum SchorrError {
    #[error("Invalid signature try")]
    InvalidSignTry,
}

================
File: zil_errors/src/keychain.rs
================
use crate::cipher::CipherErrors;
use crate::{cipher::AesGCMErrors, ntru::NTRULPCipherErrors};
use ntrulp::key::kem_error::KemErrors;
use thiserror::Error;

#[derive(Debug, Error, PartialEq, Eq)]
pub enum KeyChainErrors {
    #[error("NTRU Prime cipher error")]
    NTRUPrimeCipherError(NTRULPCipherErrors),
    #[error("NTRU Prime public key import error")]
    NTRUPrimePubKeyImportError(KemErrors),
    #[error("Argon2 cipher error")]
    Argon2CipherErrors(CipherErrors),
    #[error("AES key slice error")]
    AESKeySliceError,
    #[error("AES encrypt error: {0}")]
    AESEncryptError(#[from] AesGCMErrors),
    #[error("NTRU Prime encrypt error")]
    NTRUPrimeEncryptError(NTRULPCipherErrors),
    #[error("AES decrypt error: {0}")]
    AESDecryptError(AesGCMErrors),
    #[error("NTRU Prime decrypt error")]
    NTRUPrimeDecryptError(NTRULPCipherErrors),
    #[error("Failed to slice proof cipher")]
    FailSlicedProofCipher,
}

================
File: zil_errors/src/keypair.rs
================
use crate::{
    address::AddressError,
    crypto::{SchorrError, SignatureError},
};
use thiserror::Error;

#[derive(Debug, Error, PartialEq, Eq)]
pub enum KeyPairError {
    #[error("Fail to sign transaction: {0}")]
    FailToSignTx(String),
    #[error("Extended private key derivation error")]
    ExtendedPrivKeyDeriveError,
    #[error("Schorr error: {0}")]
    SchorrError(#[from] SchorrError),
    #[error("Invalid length")]
    InvalidLength,
    #[error("Invalid secret key")]
    InvalidSecretKey,
    #[error("Invalid entropy")]
    InvalidEntropy,
    #[error("Invalid public key")]
    InvalidPublicKey,
    #[error("Invalid key type")]
    InvalidKeyType,
    #[error("Address parse error: {0}")]
    AddressParseError(#[from] AddressError),
    #[error("Ethers invalid secret key: {0}")]
    EthersInvalidSecretKey(String),
    #[error("Ethers invalid sign: {0}")]
    EthersInvalidSign(String),
    #[error("Invalid signature: {0}")]
    InvalidSignature(SignatureError),
}

#[derive(Debug, Error, PartialEq, Eq)]
pub enum SecretKeyError {
    #[error("Secret key slice error")]
    SecretKeySliceError,
    #[error("Invalid hex")]
    InvalidHex,
    #[error("Invalid length")]
    InvalidLength,
    #[error("Invalid key type")]
    InvalidKeyType,
}

#[derive(Debug, Error, PartialEq, Eq)]
pub enum PubKeyError {
    #[error("Invalid VerifyingKey {0}")]
    InvalidVerifyingKey(String),
    #[error("Invalid length")]
    InvalidLength,
    #[error("Invalid key type")]
    InvalidKeyType,
    #[error("Invalid hex")]
    InvalidHex,
    #[error("Invalid verifying key")]
    InvalidPubKey,
    #[error("Failed to convert into public key")]
    FailIntoPubKey,
    #[error("Not implemented")]
    NotImpl,
}

================
File: zil_errors/src/lib.rs
================
use storage::LocalStorageError;

pub mod account;
pub mod address;
pub mod background;
pub mod cipher;
pub mod crypto;
pub mod keychain;
pub mod keypair;
pub mod network;
pub mod ntru;
pub mod session;
pub mod storage;
pub mod token;
pub mod wallet;
pub mod zilliqa;

================
File: zil_errors/src/network.rs
================
use crate::{address::AddressError, token::TokenError, zilliqa::ZilliqaNetErrors};
use thiserror::Error;

#[derive(Debug, Error, PartialEq, Eq)]
pub enum NetworkErrors {
    #[error("Network {0}")]
    RPCError(String),

    #[error("Fail to crate function from ABI, Error: {0}")]
    ABIError(String),

    #[error("Failed to fetch nodes: {0}")]
    FetchNodes(ZilliqaNetErrors),

    #[error("Failed to make request: {0}")]
    Request(ZilliqaNetErrors),

    #[error("Token parse error: {0}")]
    TokenParseError(TokenError),

    #[error("Invalid response: {0}")]
    InvalidResponse(ZilliqaNetErrors),

    #[error("invalid contract data (init)")]
    InvalidContractInit,

    #[error("Parse response error")]
    ResponseParseError,

    #[error("Invalid EVM address: {0}")]
    InvalidETHAddress(AddressError),

    #[error("Invalid Zilliqa address: {0}")]
    InvalidZilAddress(AddressError),
}

================
File: zil_errors/src/ntru.rs
================
use ntrulp::key::kem_error::KemErrors as NTRUKemError;
use ntrulp::ntru::std_error::CipherError as NTRUCipherError;
use ntrulp::rng::RandomErrors as NTRURandomErrors;

#[derive(Debug, PartialEq, Eq)]
pub enum NTRULPCipherErrors {
    InvalidSeedPQBytesSize,
    FailToInitF(NTRURandomErrors),
    ComputePubKeyError(NTRUKemError),
    EncryptError(NTRUCipherError),
    DecryptError(NTRUCipherError),
}

================
File: zil_errors/src/session.rs
================
use crate::{cipher::CipherErrors, keychain::KeyChainErrors};
use thiserror::Error;

#[derive(Debug, Error, PartialEq, Eq)]
pub enum SessionErrors {
    #[error("Fail hashing with argon: {0}")]
    ArgonError(CipherErrors),
    #[error("fail crate keychain: {0}")]
    KeychainError(KeyChainErrors),
    #[error("Invalid seed decryption")]
    InvalidDecryptSession,
}

================
File: zil_errors/src/storage.rs
================
use thiserror::Error;

#[derive(Debug, Error, PartialEq, Eq)]
pub enum LocalStorageError {
    #[error("Storage path error")]
    StoragePathError,
    #[error("Storage access error: {0}")]
    StorageAccessError(String),
    #[error("Failed to load bytes tree")]
    FailToloadBytesTree,
    #[error("Failed to create file")]
    FailToCreateFile,
    #[error("Failed to write file")]
    FailToWriteFile,
    #[error("Storage data not found")]
    StorageDataNotFound,
    #[error("Storage write error: {0}")]
    StorageWriteError(String),
    #[error("Storage time went backwards")]
    StorageTimeWentBackwards,
    #[error("Payload version parse error")]
    PayloadVersionParseError,
    #[error("Payload parse error")]
    PayloadParseError,
    #[error("Insufficient bytes")]
    InsufficientBytes,
    #[error("Payload length error")]
    PayloadLengthError,
    #[error("Invalid bytes size overflow")]
    InvalidBytesSizeOverflow,
}

================
File: zil_errors/src/token.rs
================
use thiserror::Error;

#[derive(Debug, Error, PartialEq, Eq)]
pub enum TokenError {
    #[error("Invalid token contract data")]
    InvalidContractData,

    #[error("Missing required field: {0}")]
    MissingField(String),

    #[error("Invalid field value for {field}: {value}")]
    InvalidFieldValue { field: String, value: String },
}

================
File: zil_errors/src/wallet.rs
================
use crate::{
    account::AccountErrors,
    cipher::CipherErrors,
    keychain::KeyChainErrors,
    keypair::{KeyPairError, SecretKeyError},
    storage::LocalStorageError,
};
use thiserror::Error;

#[derive(Debug, Error, PartialEq, Eq)]
pub enum WalletErrors {
    #[error("fail create argon2: {0}")]
    ArgonCipherErrors(CipherErrors),

    #[error("Token doesn't extistsL {0}")]
    TokenNotExists(usize),

    #[error("Fail to flush and save data, error: {0}")]
    StorageFailFlush(LocalStorageError),

    #[error("Try encrypt secret key error")]
    TryEncryptSecretKeyError,

    #[error("fail create keychain: {0}")]
    KeyChainError(KeyChainErrors),

    #[error("Decrypt keychain error: {0}")]
    DecryptKeyChainErrors(#[from] KeyChainErrors),

    #[error("Encrypt keychain error: {0}")]
    EncryptKeyChainErrors(KeyChainErrors),

    #[error("Keychain make cipher proof error: {0}")]
    KeyChainMakeCipherProofError(KeyChainErrors),

    #[error("Keychain failed to get proof")]
    KeyChainFailToGetProof,

    #[error("Invalid signature verify")]
    InvalidVerifySig,

    #[error("Fail to verify sig error: {0}")]
    FailVerifySig(KeyPairError),

    #[error("Failt to sign transaction: {0}")]
    FailToSignTransaction(KeyPairError),

    #[error("Fail to sign mesage: {0}")]
    FailSignMessage(KeyPairError),

    #[error("Fail to load key pair form seed: {0}")]
    FailToCreateKeyPair(KeyPairError),

    // Secret key related errors
    #[error("Fail convert bytes to sk: {0}")]
    FailParseSKBytes(SecretKeyError),

    #[error("Fail to get SK bytes: {0}")]
    FailToGetSKBytes(SecretKeyError),

    #[error("Invalid secret key account")]
    InvalidSecretKeyAccount,

    #[error("Invalid bip49: {0}")]
    InvalidBip49(AccountErrors),

    #[error("BIP39 not valid: {0}")]
    Bip39NotValid(String),

    #[error("Invalid BIP39 account")]
    InvalidBip39Account,

    #[error("passphrase is None")]
    PassphraseIsNone,

    #[error("fail to load mnemonic from entropy: {0}")]
    FailLoadMnemonicFromEntropy(String),

    #[error("Fail to get account by index: {0}")]
    FailToGetAccount(usize),

    #[error("Mnemonic error: {0}")]
    MnemonicError(String),

    #[error("Invalid account type")]
    InvalidAccountType,

    #[error("Fail to deserialize wallet data")]
    FailToDeserializeWalletData,

    #[error("Fail to serialize wallet data")]
    FailToSerializeWalletData,

    #[error("Failed to serialize token data")]
    FailToSerializeToken,

    #[error("Fail to save wallet data to storage: {0}")]
    FailtoSaveWalletDataToStorage(LocalStorageError),

    #[error("Fail to save FT tokens to storage, error: {0}")]
    FailtoSaveFTokensToStorage(LocalStorageError),

    #[error("Fail to load data from storage: {0}")]
    FailToLoadWalletData(LocalStorageError),

    #[error("Failed to save cipher: {0}")]
    FailToSaveCipher(#[from] LocalStorageError),

    #[error("Failed to get content: {0}")]
    FailToGetContent(LocalStorageError),

    #[error("Failed to get proof from storage: {0}")]
    FailToGetProofFromStorage(LocalStorageError),

    #[error("Invalid size str of wallet address")]
    InvalidWalletAddressSize,

    #[error("Invalid hex str of wallet address")]
    InvalidWalletAddressHex,

    #[error("invalid hex wallet type")]
    InvalidHexToWalletType,

    #[error("Invalid Wallet type value")]
    InvalidWalletTypeValue,

    #[error("Unknown type: {0}")]
    UnknownWalletType(u8),

    #[error("Proof does not match")]
    ProofNotMatch,
}

================
File: zil_errors/src/zilliqa.rs
================
use thiserror::Error;

#[derive(Debug, Error, PartialEq, Eq)]
pub enum ZilliqaNetErrors {
    #[error("Bad request")]
    BadRequest,

    #[error("Failed to parse response")]
    FailToParseResponse,

    #[error("Network is down")]
    NetowrkIsDown,

    #[error("Invalid payload")]
    InvalidPayload,

    #[error("Invalid RPC request: {0}")]
    InvalidRPCReq(String),

    #[error("Invalid JSON: {0}")]
    InvalidJson(String),

    #[error("Fail to fetch nodes")]
    FetchNodesError,

    #[error("invalid network index: {0}")]
    NetIndexWrong(usize),

    #[error("Connection error: {0}")]
    ConnectionError(String),

    #[error("Invalid URL provided: {0}")]
    InvalidUrl(String),

    #[error("Request failed: {0}")]
    RequestFailed(String),

    #[error("Response parsing failed: {0}")]
    ParseError(String),

    #[error("Invalid response received")]
    InvalidResponse,
}

================
File: zil_errors/Cargo.toml
================
[package]
name = "zil_errors"
version = "0.1.0"
edition = "2021"

[dependencies]
ntrulp = { version = "0.2.3", features = ["ntrup761", "std"] }
thiserror = "1.0.63"

================
File: zilliqa/src/json_rpc/mod.rs
================
pub mod evm;
pub mod zil;
pub mod zil_interfaces;
pub mod zil_methods;

================
File: zilliqa/src/json_rpc/zil_interfaces.rs
================
use serde::{Deserialize, Serialize};
use serde_json::Value;
use zil_errors::token::TokenError;

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct ResultRes<T> {
    pub id: u64,
    pub jsonrpc: String,
    pub result: Option<T>,
    pub error: Option<ErrorRes>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct ErrorRes {
    pub code: i16,
    pub message: String,
    pub data: Option<Value>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct GetBalanceRes {
    pub balance: String,
    pub nonce: u64,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct CreateTransactionRes {
    #[serde(rename = "Info")]
    pub info: String,
    #[serde(rename = "TranID")]
    pub tranid: String,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct GetTokenInitItem {
    #[serde(rename = "type")]
    pub item_type: String,
    pub value: String,
    pub vname: String,
}

impl TryFrom<&Value> for GetTokenInitItem {
    type Error = TokenError;

    fn try_from(value: &Value) -> Result<Self, Self::Error> {
        Ok(GetTokenInitItem {
            item_type: value
                .get("type")
                .and_then(Value::as_str)
                .ok_or(TokenError::MissingField("type".to_string()))?
                .to_string(),
            value: value
                .get("value")
                .and_then(Value::as_str)
                .ok_or(TokenError::MissingField("value".to_string()))?
                .to_string(),
            vname: value
                .get("vname")
                .and_then(Value::as_str)
                .ok_or(TokenError::MissingField("vname".to_string()))?
                .to_string(),
        })
    }
}

================
File: zilliqa/src/json_rpc/zil_methods.rs
================
pub enum ZilMethods {
    GetSmartContractInit,
    GetBalance,
    GetSmartContractSubState,
    GetNetworkId,
    GetPendingTxn,
    GetTransaction,
    CreateTransaction,
    GetTransactionStatus,
    GetLatestTxBlock,
    GetRecentTransactions,
    GetMinimumGasPrice,

    // EMV methods>>
    ETHgetBalance,
    ETHCall,
}

impl std::fmt::Display for ZilMethods {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ZilMethods::GetSmartContractInit => write!(f, "GetSmartContractInit"),
            ZilMethods::GetBalance => write!(f, "GetBalance"),
            ZilMethods::GetSmartContractSubState => write!(f, "GetSmartContractSubState"),
            ZilMethods::GetNetworkId => write!(f, "GetNetworkId"),
            ZilMethods::GetPendingTxn => write!(f, "GetPendingTxn"),
            ZilMethods::GetTransaction => write!(f, "GetTransaction"),
            ZilMethods::CreateTransaction => write!(f, "CreateTransaction"),
            ZilMethods::GetTransactionStatus => write!(f, "GetTransactionStatus"),
            ZilMethods::GetLatestTxBlock => write!(f, "GetLatestTxBlock"),
            ZilMethods::GetRecentTransactions => write!(f, "GetRecentTransactions"),
            ZilMethods::GetMinimumGasPrice => write!(f, "GetMinimumGasPrice"),
            ZilMethods::ETHgetBalance => write!(f, "eth_getBalance"),
            ZilMethods::ETHCall => write!(f, "eth_call"),
        }
    }
}

================
File: zilliqa/src/json_rpc/zil.rs
================
use crate::json_rpc::zil_methods::ZilMethods;
use config::{contracts::STAKEING, PROTO_TESTNET, ZIL_MAIN_SCILLA_URL};
use reqwest;
use serde::{de::DeserializeOwned, Deserialize, Serialize};
use serde_json::{json, Value};
use zil_errors::zilliqa::ZilliqaNetErrors;

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct ZilliqaJsonRPC {
    pub nodes: [Vec<String>; 3], // mainnet, testnet, custom
    pub selected: usize,
}

impl Default for ZilliqaJsonRPC {
    fn default() -> Self {
        Self::new()
    }
}

impl ZilliqaJsonRPC {
    pub fn new() -> Self {
        let nodes = [
            vec![ZIL_MAIN_SCILLA_URL.to_string()],
            vec![PROTO_TESTNET.to_string()],
            vec![],
        ];
        let selected = 0;

        ZilliqaJsonRPC { nodes, selected }
    }

    pub fn from_vec(nodes: Vec<String>, id: usize) -> Self {
        let mainnet = vec![ZIL_MAIN_SCILLA_URL.to_string()];
        let testnet = vec![PROTO_TESTNET.to_string()];
        let mut node_list = [mainnet, testnet, vec![]];

        if let Some(list) = node_list.get_mut(id) {
            list.extend_from_slice(&nodes);
        };

        ZilliqaJsonRPC {
            nodes: node_list,
            selected: id,
        }
    }

    pub fn get_node(&self) -> String {
        self.nodes
            .get(self.selected)
            .and_then(|nodes| nodes.first().cloned())
            .unwrap_or(ZIL_MAIN_SCILLA_URL.to_string())
    }

    pub async fn update_scilla_nodes(&mut self) -> Result<(), ZilliqaNetErrors> {
        let node_url = self.get_node();
        let client = reqwest::Client::new();
        let payload = json!({
            "id": "1",
            "jsonrpc": "2.0",
            "method": ZilMethods::GetSmartContractSubState.to_string(),
            "params": [STAKEING, "ssnlist", []]
        });

        let response: Value = client
            .post(node_url)
            .json(&payload)
            .send()
            .await
            .map_err(|_| ZilliqaNetErrors::BadRequest)?
            .json()
            .await
            .map_err(|_| ZilliqaNetErrors::FailToParseResponse)?;
        let result = response
            .get("result")
            .ok_or(ZilliqaNetErrors::FailToParseResponse)?
            .get("ssnlist")
            .ok_or(ZilliqaNetErrors::FailToParseResponse)?;
        let nodes: Vec<String> = result
            .as_object()
            .ok_or(ZilliqaNetErrors::FailToParseResponse)?
            .keys()
            .filter_map(|addr| {
                result
                    .get(addr)
                    .and_then(|obj| obj.get("arguments"))
                    .and_then(|arr| arr.as_array())
                    .and_then(|arr| arr.get(5))
                    .and_then(|v| v.as_str())
                    .map(|url| url.to_string())
            })
            .collect();

        if let Some(self_nodes) = self.nodes.get_mut(self.selected) {
            self_nodes.extend_from_slice(&nodes);
        }

        Ok(())
    }

    pub async fn req<SR>(&self, payloads: &[Value]) -> Result<SR, ZilliqaNetErrors>
    where
        SR: DeserializeOwned + std::fmt::Debug,
    {
        const MAX_ERROR: usize = 5;
        let client = reqwest::Client::new();
        let mut error: ZilliqaNetErrors = ZilliqaNetErrors::NetowrkIsDown;
        let mut k = 0;
        let mut handle_error = |e: String, zil_err: fn(String) -> ZilliqaNetErrors| -> bool {
            let new_error = zil_err(e.to_string());
            if new_error == error && k == MAX_ERROR {
                false
            } else if new_error == error && k != MAX_ERROR {
                error = new_error;
                k += 1;
                true
            } else {
                error = new_error;
                k = 1;
                true
            }
        };

        if let Some(nodes) = self.nodes.get(self.selected) {
            for url in nodes.iter() {
                let res = match client.post::<&str>(url).json(&payloads).send().await {
                    Ok(response) => response,
                    Err(e) => {
                        if handle_error(e.to_string(), ZilliqaNetErrors::InvalidRPCReq) {
                            break;
                        }

                        continue;
                    }
                };
                let res: SR = match res.json().await {
                    Ok(json) => json,
                    Err(e) => {
                        if handle_error(e.to_string(), ZilliqaNetErrors::InvalidJson) {
                            break;
                        }

                        continue;
                    }
                };

                return Ok(res);
            }
        } else {
            return Err(ZilliqaNetErrors::NetIndexWrong(self.selected));
        }

        Err(error)
    }

    pub fn build_payload(params: Value, method: ZilMethods) -> Value {
        json!({
            "id": 1,
            "jsonrpc": "2.0",
            "method": method.to_string(),
            "params": params
        })
    }
}

#[cfg(test)]
mod tests {
    use core::panic;

    use super::ZilliqaJsonRPC;
    use crate::json_rpc::{
        zil_interfaces::{CreateTransactionRes, GetBalanceRes, ResultRes},
        zil_methods::ZilMethods,
    };
    use config::PROTO_TESTNET;
    use proto::{
        keypair::KeyPair,
        secret_key::SecretKey,
        tx::{TransactionReceipt, TransactionRequest},
        zil_tx::{ScillaGas, ZILTransactionRequest, ZilAmount},
    };
    use serde_json::json;
    use tokio;

    #[tokio::test]
    async fn test_bootstrap() {
        let mut zil = ZilliqaJsonRPC::new();

        zil.update_scilla_nodes().await.unwrap();

        assert!(zil.nodes.len() > 1);
    }

    #[tokio::test]
    async fn test_transaction() {
        const CHAIN_ID: u16 = 333;

        let zil = ZilliqaJsonRPC::from_vec(vec![PROTO_TESTNET.to_string()], 1);
        let secret_key_1_bytes: [u8; 32] = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 1,
        ];
        let secret_key_2_bytes: [u8; 32] = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 2,
        ];
        let secret_keys = [
            SecretKey::Secp256k1Sha256Zilliqa(secret_key_1_bytes),
            SecretKey::Secp256k1Sha256Zilliqa(secret_key_2_bytes),
        ];
        let keypairs = secret_keys
            .iter()
            .map(|x| KeyPair::from_secret_key(x).unwrap())
            .collect::<Vec<KeyPair>>();
        println!("Got a keypair!");

        const ONE_ZIL: u128 = 1_000_000_000_000u128;

        println!(
            "Sending 1 ZIL from {0} to {1}",
            keypairs[0].get_addr().unwrap(),
            keypairs[1].get_addr().unwrap()
        );
        let nonce = {
            let bal_addr = keypairs[0]
                .get_addr()
                .unwrap()
                .to_eth_checksummed()
                .unwrap();
            let bal_payload = vec![ZilliqaJsonRPC::build_payload(
                json!([bal_addr]),
                ZilMethods::GetBalance,
            )];
            let resvec: Vec<ResultRes<GetBalanceRes>> = zil.req(&bal_payload).await.unwrap();
            println!("Bal {0:?}", resvec[0]);
            resvec[0].result.as_ref().map_or(0, |v| v.nonce)
        };
        let txn = TransactionRequest::Zilliqa(ZILTransactionRequest {
            nonce: nonce + 1,
            chain_id: CHAIN_ID,
            gas_price: ZilAmount::from_raw(2000000000),
            gas_limit: ScillaGas(1000),
            to_addr: keypairs[1].get_addr().unwrap(),
            amount: ZilAmount::from_raw(ONE_ZIL),
            code: String::new(),
            data: String::new(),
        });

        let signed = txn.sign(&keypairs[0]).await.unwrap();

        match signed {
            TransactionReceipt::Zilliqa(tx) => {
                dbg!(serde_json::to_string(&tx).unwrap());
                let payloads = vec![ZilliqaJsonRPC::build_payload(
                    json!([tx]),
                    ZilMethods::CreateTransaction,
                )];
                let res: Vec<ResultRes<CreateTransactionRes>> = zil.req(&payloads).await.unwrap();
                println!("{res:?}");
            }
            _ => panic!("fail test"),
        }
    }

    #[tokio::test]
    async fn test_get_balance() {
        let zil = ZilliqaJsonRPC::new();
        let addr = "7793a8e8c09d189d4d421ce5bc5b3674656c5ac1";
        let payloads = vec![ZilliqaJsonRPC::build_payload(
            json!([addr]),
            ZilMethods::GetBalance,
        )];

        let res: Vec<ResultRes<GetBalanceRes>> = zil.req(&payloads).await.unwrap();

        assert!(res.len() == 1);
        assert!(res[0].result.is_some());
        assert!(res[0].error.is_none());
    }
}

================
File: zilliqa/src/lib.rs
================
pub mod json_rpc;

================
File: zilliqa/Cargo.toml
================
[package]
name = "zilliqa"
version = "0.1.0"
edition = "2021"

[dependencies]
zil_errors = { path = "../zil_errors" }
crypto = { path = "../crypto" }
config = { path = "../config" }
proto = { path = "../proto" }
hex = "0.4.3"
serde_json = "1.0.124"
serde = { version = "1.0.204", features = ["derive", "rc"] }
reqwest = { version = "0.11", features = ["json"] }
tokio = { version = "1.39.2", features = ["full", "test-util"] }

[dev-dependencies]
mockito = "1.5.0"

================
File: zilpay/src/lib.rs
================
pub use background;
pub use config;
pub use crypto;
pub use proto;
pub use settings;
pub use wallet;
pub use zil_errors;

================
File: zilpay/Cargo.toml
================
[package]
name = "zilpay"
version = "0.1.0"
edition = "2021"

[dependencies]
zil_errors = { path = "../zil_errors" }
background = { path = "../background" }
crypto = { path = "../crypto" }
wallet = { path = "../wallet" }
settings = { path = "../settings" }
config = { path = "../config" }
proto = { path = "../proto" }

================
File: .gitignore
================
# Generated by Cargo
# will have compiled files and executables
/target/

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
#Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# Emacs backups
*~
\.#*
\#*

# Default development datadir
zq2data
# Default z2 config and datadir paths
z2_node_*

# Profiling
*.svg
perf.*
!perf.rs

# RustRover
.idea


# Added by cargo

/target

================
File: Cargo.lock
================
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "addr2line"
version = "0.24.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1"
dependencies = [
 "gimli",
]

[[package]]
name = "adler2"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "512761e0bb2578dd7380c6baaa0f4ce03e84f95e960231d1dec8bf4d7d6e2627"

[[package]]
name = "aead"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d122413f284cf2d62fb1b7db97e02edb8cda96d769b16e443a4f6195e35662b0"
dependencies = [
 "crypto-common",
 "generic-array 0.14.7",
]

[[package]]
name = "aes"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b169f7a6d4742236a0a00c541b845991d0ac43e546831af1249753ab4c3aa3a0"
dependencies = [
 "cfg-if",
 "cipher 0.4.4",
 "cpufeatures",
]

[[package]]
name = "aes-gcm"
version = "0.10.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "831010a0f742e1209b3bcea8fab6a8e149051ba6099432c8cb2cc117dec3ead1"
dependencies = [
 "aead",
 "aes",
 "cipher 0.4.4",
 "ctr",
 "ghash",
 "subtle 2.6.1",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "allocator-api2"
version = "0.2.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c6cb57a04249c6480766f7f7cef5467412af1490f8d1e243141daddada3264f"

[[package]]
name = "alloy"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "056f2c01b2aed86e15b43c47d109bfc8b82553dc34e66452875e51247ec31ab2"
dependencies = [
 "alloy-consensus",
 "alloy-contract",
 "alloy-core",
 "alloy-eips",
 "alloy-genesis",
 "alloy-network",
 "alloy-provider",
 "alloy-pubsub",
 "alloy-rpc-client",
 "alloy-rpc-types",
 "alloy-serde",
 "alloy-signer",
 "alloy-signer-local",
 "alloy-transport",
 "alloy-transport-http",
 "alloy-transport-ipc",
 "alloy-transport-ws",
]

[[package]]
name = "alloy-chains"
version = "0.1.42"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dca4a1469a3e572e9ba362920ff145f5d0a00a3e71a64ddcb4a3659cf64c76a7"
dependencies = [
 "alloy-primitives",
 "num_enum",
 "strum",
]

[[package]]
name = "alloy-consensus"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "705687d5bfd019fee57cf9e206b27b30a9a9617535d5590a02b171e813208f8e"
dependencies = [
 "alloy-eips",
 "alloy-primitives",
 "alloy-rlp",
 "alloy-serde",
 "auto_impl",
 "c-kzg",
 "derive_more",
 "serde",
]

[[package]]
name = "alloy-contract"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "917f7d12cf3971dc8c11c9972f732b35ccb9aaaf5f28f2f87e9e6523bee3a8ad"
dependencies = [
 "alloy-dyn-abi",
 "alloy-json-abi",
 "alloy-network",
 "alloy-network-primitives",
 "alloy-primitives",
 "alloy-provider",
 "alloy-pubsub",
 "alloy-rpc-types-eth",
 "alloy-sol-types",
 "alloy-transport",
 "futures",
 "futures-util",
 "thiserror",
]

[[package]]
name = "alloy-core"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5cce174ca699ddee3bfb2ec1fbd99ad7efd05eca20c5c888d8320db41f7e8f04"
dependencies = [
 "alloy-dyn-abi",
 "alloy-json-abi",
 "alloy-primitives",
 "alloy-rlp",
 "alloy-sol-types",
]

[[package]]
name = "alloy-dyn-abi"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5647fce5a168f9630f935bf7821c4207b1755184edaeba783cb4e11d35058484"
dependencies = [
 "alloy-json-abi",
 "alloy-primitives",
 "alloy-sol-type-parser",
 "alloy-sol-types",
 "const-hex",
 "itoa",
 "serde",
 "serde_json",
 "winnow",
]

[[package]]
name = "alloy-eip2930"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0069cf0642457f87a01a014f6dc29d5d893cd4fd8fddf0c3cdfad1bb3ebafc41"
dependencies = [
 "alloy-primitives",
 "alloy-rlp",
 "serde",
]

[[package]]
name = "alloy-eip7702"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea59dc42102bc9a1905dc57901edc6dd48b9f38115df86c7d252acba70d71d04"
dependencies = [
 "alloy-primitives",
 "alloy-rlp",
 "k256",
 "serde",
]

[[package]]
name = "alloy-eips"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6ffb906284a1e1f63c4607da2068c8197458a352d0b3e9796e67353d72a9be85"
dependencies = [
 "alloy-eip2930",
 "alloy-eip7702",
 "alloy-primitives",
 "alloy-rlp",
 "alloy-serde",
 "c-kzg",
 "derive_more",
 "once_cell",
 "serde",
 "sha2 0.10.8",
]

[[package]]
name = "alloy-genesis"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8429cf4554eed9b40feec7f4451113e76596086447550275e3def933faf47ce3"
dependencies = [
 "alloy-primitives",
 "alloy-serde",
 "serde",
]

[[package]]
name = "alloy-json-abi"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4b5671117c38b1c2306891f97ad3828d85487087f54ebe2c7591a055ea5bcea7"
dependencies = [
 "alloy-primitives",
 "alloy-sol-type-parser",
 "serde",
 "serde_json",
]

[[package]]
name = "alloy-json-rpc"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8fa8a1a3c4cbd221f2b8e3693aeb328fca79a757fe556ed08e47bbbc2a70db7"
dependencies = [
 "alloy-primitives",
 "alloy-sol-types",
 "serde",
 "serde_json",
 "thiserror",
 "tracing",
]

[[package]]
name = "alloy-network"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85fa23a6a9d612b52e402c995f2d582c25165ec03ac6edf64c861a76bc5b87cd"
dependencies = [
 "alloy-consensus",
 "alloy-eips",
 "alloy-json-rpc",
 "alloy-network-primitives",
 "alloy-primitives",
 "alloy-rpc-types-eth",
 "alloy-serde",
 "alloy-signer",
 "alloy-sol-types",
 "async-trait",
 "auto_impl",
 "futures-utils-wasm",
 "thiserror",
]

[[package]]
name = "alloy-network-primitives"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "801492711d4392b2ccf5fc0bc69e299fa1aab15167d74dcaa9aab96a54f684bd"
dependencies = [
 "alloy-consensus",
 "alloy-eips",
 "alloy-primitives",
 "alloy-serde",
 "serde",
]

[[package]]
name = "alloy-primitives"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c71738eb20c42c5fb149571e76536a0f309d142f3957c28791662b96baf77a3d"
dependencies = [
 "alloy-rlp",
 "bytes",
 "cfg-if",
 "const-hex",
 "derive_more",
 "foldhash",
 "hashbrown 0.15.0",
 "hex-literal",
 "indexmap",
 "itoa",
 "k256",
 "keccak-asm",
 "paste",
 "proptest",
 "rand 0.8.5",
 "ruint",
 "rustc-hash",
 "serde",
 "sha3",
 "tiny-keccak",
]

[[package]]
name = "alloy-provider"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fcfaa4ffec0af04e3555686b8aacbcdf7d13638133a0672749209069750f78a6"
dependencies = [
 "alloy-chains",
 "alloy-consensus",
 "alloy-eips",
 "alloy-json-rpc",
 "alloy-network",
 "alloy-network-primitives",
 "alloy-primitives",
 "alloy-pubsub",
 "alloy-rpc-client",
 "alloy-rpc-types-eth",
 "alloy-transport",
 "alloy-transport-http",
 "alloy-transport-ipc",
 "alloy-transport-ws",
 "async-stream",
 "async-trait",
 "auto_impl",
 "dashmap",
 "futures",
 "futures-utils-wasm",
 "lru",
 "pin-project",
 "reqwest 0.12.8",
 "serde",
 "serde_json",
 "thiserror",
 "tokio",
 "tracing",
 "url",
]

[[package]]
name = "alloy-pubsub"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f32cef487122ae75c91eb50154c70801d71fabdb976fec6c49e0af5e6486ab15"
dependencies = [
 "alloy-json-rpc",
 "alloy-primitives",
 "alloy-transport",
 "bimap",
 "futures",
 "serde",
 "serde_json",
 "tokio",
 "tokio-stream",
 "tower",
 "tracing",
]

[[package]]
name = "alloy-rlp"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da0822426598f95e45dd1ea32a738dac057529a709ee645fcc516ffa4cbde08f"
dependencies = [
 "alloy-rlp-derive",
 "arrayvec",
 "bytes",
]

[[package]]
name = "alloy-rlp-derive"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b09cae092c27b6f1bde952653a22708691802e57bfef4a2973b80bea21efd3f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "alloy-rpc-client"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "370143ed581aace6e663342d21d209c6b2e34ee6142f7d6675adb518deeaf0dc"
dependencies = [
 "alloy-json-rpc",
 "alloy-primitives",
 "alloy-pubsub",
 "alloy-transport",
 "alloy-transport-http",
 "alloy-transport-ipc",
 "alloy-transport-ws",
 "futures",
 "pin-project",
 "reqwest 0.12.8",
 "serde",
 "serde_json",
 "tokio",
 "tokio-stream",
 "tower",
 "tracing",
 "url",
]

[[package]]
name = "alloy-rpc-types"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ffc534b7919e18f35e3aa1f507b6f3d9d92ec298463a9f6beaac112809d8d06"
dependencies = [
 "alloy-primitives",
 "alloy-rpc-types-engine",
 "alloy-rpc-types-eth",
 "alloy-serde",
 "serde",
]

[[package]]
name = "alloy-rpc-types-engine"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0285c4c09f838ab830048b780d7f4a4f460f309aa1194bb049843309524c64c"
dependencies = [
 "alloy-consensus",
 "alloy-eips",
 "alloy-primitives",
 "alloy-rlp",
 "derive_more",
 "strum",
]

[[package]]
name = "alloy-rpc-types-eth"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "413f4aa3ccf2c3e4234a047c5fa4727916d7daf25a89f9b765df0ba09784fd87"
dependencies = [
 "alloy-consensus",
 "alloy-eips",
 "alloy-network-primitives",
 "alloy-primitives",
 "alloy-rlp",
 "alloy-serde",
 "alloy-sol-types",
 "derive_more",
 "itertools 0.13.0",
 "serde",
 "serde_json",
]

[[package]]
name = "alloy-serde"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9dff0ab1cdd43ca001e324dc27ee0e8606bd2161d6623c63e0e0b8c4dfc13600"
dependencies = [
 "alloy-primitives",
 "serde",
 "serde_json",
]

[[package]]
name = "alloy-signer"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2fd4e0ad79c81a27ca659be5d176ca12399141659fef2bcbfdc848da478f4504"
dependencies = [
 "alloy-primitives",
 "async-trait",
 "auto_impl",
 "elliptic-curve",
 "k256",
 "thiserror",
]

[[package]]
name = "alloy-signer-local"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "494e0a256f3e99f2426f994bcd1be312c02cb8f88260088dacb33a8b8936475f"
dependencies = [
 "alloy-consensus",
 "alloy-network",
 "alloy-primitives",
 "alloy-signer",
 "async-trait",
 "k256",
 "rand 0.8.5",
 "thiserror",
]

[[package]]
name = "alloy-sol-macro"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0900b83f4ee1f45c640ceee596afbc118051921b9438fdb5a3175c1a7e05f8b"
dependencies = [
 "alloy-sol-macro-expander",
 "alloy-sol-macro-input",
 "proc-macro-error2",
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "alloy-sol-macro-expander"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a41b1e78dde06b5e12e6702fa8c1d30621bf07728ba75b801fb801c9c6a0ba10"
dependencies = [
 "alloy-json-abi",
 "alloy-sol-macro-input",
 "const-hex",
 "heck",
 "indexmap",
 "proc-macro-error2",
 "proc-macro2",
 "quote",
 "syn 2.0.85",
 "syn-solidity",
 "tiny-keccak",
]

[[package]]
name = "alloy-sol-macro-input"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91dc311a561a306664393407b88d3e53ae58581624128afd8a15faa5de3627dc"
dependencies = [
 "alloy-json-abi",
 "const-hex",
 "dunce",
 "heck",
 "proc-macro2",
 "quote",
 "serde_json",
 "syn 2.0.85",
 "syn-solidity",
]

[[package]]
name = "alloy-sol-type-parser"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "45d1fbee9e698f3ba176b6e7a145f4aefe6d2b746b611e8bb246fe11a0e9f6c4"
dependencies = [
 "serde",
 "winnow",
]

[[package]]
name = "alloy-sol-types"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "086f41bc6ebcd8cb15f38ba20e47be38dd03692149681ce8061c35d960dbf850"
dependencies = [
 "alloy-json-abi",
 "alloy-primitives",
 "alloy-sol-macro",
 "const-hex",
 "serde",
]

[[package]]
name = "alloy-transport"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2ac3e97dad3d31770db0fc89bd6a63b789fbae78963086733f960cf32c483904"
dependencies = [
 "alloy-json-rpc",
 "base64 0.22.1",
 "futures-util",
 "futures-utils-wasm",
 "serde",
 "serde_json",
 "thiserror",
 "tokio",
 "tower",
 "tracing",
 "url",
]

[[package]]
name = "alloy-transport-http"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b367dcccada5b28987c2296717ee04b9a5637aacd78eacb1726ef211678b5212"
dependencies = [
 "alloy-json-rpc",
 "alloy-transport",
 "reqwest 0.12.8",
 "serde_json",
 "tower",
 "tracing",
 "url",
]

[[package]]
name = "alloy-transport-ipc"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b90cf9cde7f2fce617da52768ee28f522264b282d148384a4ca0ea85af04fa3a"
dependencies = [
 "alloy-json-rpc",
 "alloy-pubsub",
 "alloy-transport",
 "bytes",
 "futures",
 "interprocess",
 "pin-project",
 "serde_json",
 "tokio",
 "tokio-util",
 "tracing",
]

[[package]]
name = "alloy-transport-ws"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7153b88690de6a50bba81c11e1d706bc41dbb90126d607404d60b763f6a3947f"
dependencies = [
 "alloy-pubsub",
 "alloy-transport",
 "futures",
 "http 1.1.0",
 "rustls",
 "serde_json",
 "tokio",
 "tokio-tungstenite",
 "tracing",
 "ws_stream_wasm",
]

[[package]]
name = "anyhow"
version = "1.0.91"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c042108f3ed77fd83760a5fd79b53be043192bb3b9dba91d8c574c0ada7850c8"

[[package]]
name = "argon2"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c3610892ee6e0cbce8ae2700349fcf8f98adb0dbfbee85aec3c9179d29cc072"
dependencies = [
 "base64ct",
 "blake2",
 "cpufeatures",
 "password-hash",
]

[[package]]
name = "ark-ff"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b3235cc41ee7a12aaaf2c575a2ad7b46713a8a50bda2fc3b003a04845c05dd6"
dependencies = [
 "ark-ff-asm 0.3.0",
 "ark-ff-macros 0.3.0",
 "ark-serialize 0.3.0",
 "ark-std 0.3.0",
 "derivative",
 "num-bigint",
 "num-traits",
 "paste",
 "rustc_version 0.3.3",
 "zeroize",
]

[[package]]
name = "ark-ff"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec847af850f44ad29048935519032c33da8aa03340876d351dfab5660d2966ba"
dependencies = [
 "ark-ff-asm 0.4.2",
 "ark-ff-macros 0.4.2",
 "ark-serialize 0.4.2",
 "ark-std 0.4.0",
 "derivative",
 "digest 0.10.7",
 "itertools 0.10.5",
 "num-bigint",
 "num-traits",
 "paste",
 "rustc_version 0.4.1",
 "zeroize",
]

[[package]]
name = "ark-ff-asm"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db02d390bf6643fb404d3d22d31aee1c4bc4459600aef9113833d17e786c6e44"
dependencies = [
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "ark-ff-asm"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ed4aa4fe255d0bc6d79373f7e31d2ea147bcf486cba1be5ba7ea85abdb92348"
dependencies = [
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "ark-ff-macros"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db2fd794a08ccb318058009eefdf15bcaaaaf6f8161eb3345f907222bac38b20"
dependencies = [
 "num-bigint",
 "num-traits",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "ark-ff-macros"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7abe79b0e4288889c4574159ab790824d0033b9fdcb2a112a3182fac2e514565"
dependencies = [
 "num-bigint",
 "num-traits",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "ark-serialize"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d6c2b318ee6e10f8c2853e73a83adc0ccb88995aa978d8a3408d492ab2ee671"
dependencies = [
 "ark-std 0.3.0",
 "digest 0.9.0",
]

[[package]]
name = "ark-serialize"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "adb7b85a02b83d2f22f89bd5cac66c9c89474240cb6207cb1efc16d098e822a5"
dependencies = [
 "ark-std 0.4.0",
 "digest 0.10.7",
 "num-bigint",
]

[[package]]
name = "ark-std"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1df2c09229cbc5a028b1d70e00fdb2acee28b1055dfb5ca73eea49c5a25c4e7c"
dependencies = [
 "num-traits",
 "rand 0.8.5",
]

[[package]]
name = "ark-std"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94893f1e0c6eeab764ade8dc4c0db24caf4fe7cbbaafc0eba0a9030f447b5185"
dependencies = [
 "num-traits",
 "rand 0.8.5",
]

[[package]]
name = "arrayref"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76a2e8124351fda1ef8aaaa3bbd7ebbcb486bbcd4225aca0aa0d84bb2db8fecb"

[[package]]
name = "arrayvec"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"

[[package]]
name = "assert-json-diff"
version = "2.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "47e4f2b81832e72834d7518d8487a0396a28cc408186a2e8854c0f98011faf12"
dependencies = [
 "serde",
 "serde_json",
]

[[package]]
name = "async-stream"
version = "0.3.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b5a71a6f37880a80d1d7f19efd781e4b5de42c88f0722cc13bcb6cc2cfe8476"
dependencies = [
 "async-stream-impl",
 "futures-core",
 "pin-project-lite",
]

[[package]]
name = "async-stream-impl"
version = "0.3.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7c24de15d275a1ecfd47a380fb4d5ec9bfe0933f309ed5e705b775596a3574d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "async-trait"
version = "0.1.83"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "721cae7de5c34fbb2acd27e21e6d2cf7b886dce0c27388d46c4e6c47ea4318dd"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "async_io_stream"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6d7b9decdf35d8908a7e3ef02f64c5e9b1695e230154c0e8de3969142d9b94c"
dependencies = [
 "futures",
 "pharos",
 "rustc_version 0.4.1",
]

[[package]]
name = "atomic-waker"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1505bd5d3d116872e7271a6d4e16d81d0c8570876c8de68093a09ac269d8aac0"

[[package]]
name = "auto_impl"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c87f3f15e7794432337fc718554eaa4dc8f04c9677a950ffe366f20a162ae42"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "autocfg"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"

[[package]]
name = "background"
version = "0.1.0"
dependencies = [
 "bip39",
 "cipher 0.1.0",
 "config",
 "crypto",
 "hex",
 "network",
 "proto",
 "rand 0.8.5",
 "rand_chacha 0.3.1",
 "serde",
 "serde_json",
 "session",
 "settings",
 "storage",
 "wallet",
 "zil_errors",
]

[[package]]
name = "backtrace"
version = "0.3.74"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d82cb332cdfaed17ae235a638438ac4d4839913cc2af585c3c6746e8f8bee1a"
dependencies = [
 "addr2line",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
 "windows-targets 0.52.6",
]

[[package]]
name = "base16ct"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c7f02d4ea65f2c1853089ffd8d2787bdbc63de2f0d29dedbcf8ccdfa0ccd4cf"

[[package]]
name = "base58"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5024ee8015f02155eee35c711107ddd9a9bf3cb689cf2a9089c97e79b6e1ae83"

[[package]]
name = "base64"
version = "0.21.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "base64ct"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c3c1a368f70d6cf7302d78f8f7093da241fb8e8807c05cc9e51a125895a6d5b"

[[package]]
name = "bech32"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d965446196e3b7decd44aa7ee49e31d630118f90ef12f97900f262eb915c951d"

[[package]]
name = "bimap"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "230c5f1ca6a325a32553f8640d31ac9b49f2411e901e427570154868b46da4f7"

[[package]]
name = "bincode"
version = "0.1.0"

[[package]]
name = "bip39"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33415e24172c1b7d6066f6d999545375ab8e1d95421d6784bdfff9496f292387"
dependencies = [
 "bitcoin_hashes",
 "serde",
 "unicode-normalization",
]

[[package]]
name = "bit-set"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0700ddab506f33b20a03b13996eccd309a48e5ff77d0d95926aa0210fb4e95f1"
dependencies = [
 "bit-vec",
]

[[package]]
name = "bit-vec"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "349f9b6a179ed607305526ca489b34ad0a41aed5f7980fa90eb03160b69598fb"

[[package]]
name = "bitcoin-internals"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9425c3bf7089c983facbae04de54513cce73b41c7f9ff8c845b54e7bc64ebbfb"

[[package]]
name = "bitcoin_hashes"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1930a4dabfebb8d7d9992db18ebe3ae2876f0a305fab206fd168df931ede293b"
dependencies = [
 "bitcoin-internals",
 "hex-conservative",
]

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de"

[[package]]
name = "bitvec"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bc2832c24239b0141d5674bb9174f9d68a8b5b3f2753311927c172ca46f7e9c"
dependencies = [
 "funty",
 "radium",
 "tap",
 "wyz",
]

[[package]]
name = "blake2"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46502ad458c9a52b69d4d4d32775c788b7a1b85e8bc9d482d92250fc0e3f8efe"
dependencies = [
 "digest 0.10.7",
]

[[package]]
name = "block-buffer"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0940dc441f31689269e10ac70eb1002a3a1d3ad1390e030043662eb7fe4688b"
dependencies = [
 "block-padding",
 "byte-tools",
 "byteorder",
 "generic-array 0.12.4",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array 0.14.7",
]

[[package]]
name = "block-padding"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa79dedbb091f449f1f39e53edf88d5dbe95f895dae6135a8d7b881fb5af73f5"
dependencies = [
 "byte-tools",
]

[[package]]
name = "blst"
version = "0.3.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4378725facc195f1a538864863f6de233b500a8862747e7f165078a419d5e874"
dependencies = [
 "cc",
 "glob",
 "threadpool",
 "zeroize",
]

[[package]]
name = "bumpalo"
version = "3.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c"

[[package]]
name = "byte-slice-cast"
version = "1.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3ac9f8b63eca6fd385229b3675f6cc0dc5c8a5c8a54a59d4f52ffd670d87b0c"

[[package]]
name = "byte-tools"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3b5ca7a04898ad4bcd41c90c5285445ff5b791899bb1b0abdd2a2aa791211d7"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ac0150caa2ae65ca5bd83f25c7de183dea78d4d366469f148435e2acfbad0da"
dependencies = [
 "serde",
]

[[package]]
name = "c-kzg"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0307f72feab3300336fb803a57134159f6e20139af1357f36c54cb90d8e8928"
dependencies = [
 "blst",
 "cc",
 "glob",
 "hex",
 "libc",
 "once_cell",
 "serde",
]

[[package]]
name = "cc"
version = "1.1.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2e7962b54006dcfcc61cb72735f4d89bb97061dd6a7ed882ec6b8ee53714c6f"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "cipher"
version = "0.1.0"
dependencies = [
 "aes-gcm",
 "argon2",
 "bincode",
 "config",
 "hex",
 "ntrulp",
 "rand 0.8.5",
 "rand_chacha 0.3.1",
 "serde",
 "tokio",
 "zil_errors",
]

[[package]]
name = "cipher"
version = "0.4.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773f3b9af64447d2ce9850330c473515014aa235e6a783b02db81ff39e4a3dad"
dependencies = [
 "crypto-common",
 "inout",
]

[[package]]
name = "colored"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbf2150cce219b664a8a70df7a1f933836724b503f8a413af9365b4dcc4d90b8"
dependencies = [
 "lazy_static",
 "windows-sys 0.48.0",
]

[[package]]
name = "config"
version = "0.1.0"

[[package]]
name = "const-hex"
version = "1.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0121754e84117e65f9d90648ee6aa4882a6e63110307ab73967a4c5e7e69e586"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "hex",
 "proptest",
 "serde",
]

[[package]]
name = "const-oid"
version = "0.9.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2459377285ad874054d797f3ccebf984978aa39129f6eafde5cdc8315b612f8"

[[package]]
name = "core-foundation"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cpufeatures"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "608697df725056feaccfa42cffdaeeec3fccc4ffc38358ecd19b243e716a78e0"
dependencies = [
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a97769d94ddab943e4510d138150169a2758b5ef3eb191a9ee688de3e23ef7b3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22ec99545bb0ed0ea7bb9b8e1e9122ea386ff8a48c0922e43f36d45ab09e0e80"

[[package]]
name = "crunchy"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a81dae078cea95a014a339291cec439d2f232ebe854a9d672b796c6afafa9b7"

[[package]]
name = "crypto"
version = "0.1.0"
dependencies = [
 "bip39",
 "config",
 "hex",
 "k256",
 "rand 0.8.5",
 "rand_chacha 0.3.1",
 "sha2 0.10.8",
 "zil_errors",
]

[[package]]
name = "crypto-bigint"
version = "0.5.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0dc92fb57ca44df6db8059111ab3af99a63d5d0f8375d9972e319a379c6bab76"
dependencies = [
 "generic-array 0.14.7",
 "rand_core 0.6.4",
 "subtle 2.6.1",
 "zeroize",
]

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array 0.14.7",
 "rand_core 0.6.4",
 "typenum",
]

[[package]]
name = "crypto-mac"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4434400df11d95d556bac068ddfedd482915eb18fe8bea89bc80b6e4b1c179e5"
dependencies = [
 "generic-array 0.12.4",
 "subtle 1.0.0",
]

[[package]]
name = "ctr"
version = "0.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0369ee1ad671834580515889b80f2ea915f23b8be8d0daa4bbaf2ac5c7590835"
dependencies = [
 "cipher 0.4.4",
]

[[package]]
name = "dashmap"
version = "6.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5041cc499144891f3790297212f32a74fb938e5136a14943f338ef9e0ae276cf"
dependencies = [
 "cfg-if",
 "crossbeam-utils",
 "hashbrown 0.14.5",
 "lock_api",
 "once_cell",
 "parking_lot_core 0.9.10",
]

[[package]]
name = "data-encoding"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8566979429cf69b49a5c740c60791108e86440e8be149bbea4fe54d2c32d6e2"

[[package]]
name = "der"
version = "0.7.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f55bf8e7b65898637379c1b74eb1551107c8294ed26d855ceb9fd1a09cfc9bc0"
dependencies = [
 "const-oid",
 "zeroize",
]

[[package]]
name = "derivative"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fcc3dd5e9e9c0b295d6e1e4d811fb6f157d5ffd784b8d202fc62eac8035a770b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "derive_more"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a9b99b9cbbe49445b21764dc0625032a89b145a2642e67603e1c936f5458d05"
dependencies = [
 "derive_more-impl",
]

[[package]]
name = "derive_more-impl"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb7330aeadfbe296029522e6c40f315320aba36fc43a5b3632f3795348f3bd22"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
 "unicode-xid",
]

[[package]]
name = "digest"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3d0c8c8752312f9713efd397ff63acb9f85585afbf179282e720e7704954dd5"
dependencies = [
 "generic-array 0.12.4",
]

[[package]]
name = "digest"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3dd60d1080a57a05ab032377049e0591415d2b31afd7028356dbf3cc6dcb066"
dependencies = [
 "generic-array 0.14.7",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer 0.10.4",
 "const-oid",
 "crypto-common",
 "subtle 2.6.1",
]

[[package]]
name = "directories"
version = "5.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a49173b84e034382284f27f1af4dcbbd231ffa358c0fe316541a7337f376a35"
dependencies = [
 "dirs-sys",
]

[[package]]
name = "dirs-sys"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "520f05a5cbd335fae5a99ff7a6ab8627577660ee5cfd6a94a6a929b52ff0321c"
dependencies = [
 "libc",
 "option-ext",
 "redox_users",
 "windows-sys 0.48.0",
]

[[package]]
name = "doctest-file"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aac81fa3e28d21450aa4d2ac065992ba96a1d7303efbce51a95f4fd175b67562"

[[package]]
name = "dunce"
version = "1.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "92773504d58c093f6de2459af4af33faa518c13451eb8f2b5698ed3d36e7c813"

[[package]]
name = "ecdsa"
version = "0.16.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee27f32b5c5292967d2d4a9d7f1e0b0aed2c15daded5a60300e4abb9d8020bca"
dependencies = [
 "der",
 "digest 0.10.7",
 "elliptic-curve",
 "rfc6979",
 "signature",
 "spki",
]

[[package]]
name = "either"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60b1af1c220855b6ceac025d3f6ecdd2b7c4894bfe9cd9bda4fbb4bc7c0d4cf0"

[[package]]
name = "elliptic-curve"
version = "0.13.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5e6043086bf7973472e0c7dff2142ea0b680d30e18d9cc40f267efbf222bd47"
dependencies = [
 "base16ct",
 "crypto-bigint",
 "digest 0.10.7",
 "ff",
 "generic-array 0.14.7",
 "group",
 "pkcs8",
 "rand_core 0.6.4",
 "sec1",
 "subtle 2.6.1",
 "zeroize",
]

[[package]]
name = "encoding_rs"
version = "0.8.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "equivalent"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"

[[package]]
name = "errno"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "534c5cf6194dfab3db3242765c03bbe257cf92f22b38f6bc0c58d59108a820ba"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "fake-simd"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed"

[[package]]
name = "fastrand"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8c02a5121d4ea3eb16a80748c74f5549a5665e4c21333c6098f283870fbdea6"

[[package]]
name = "fastrlp"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "139834ddba373bbdd213dffe02c8d110508dcf1726c2be27e8d1f7d7e1856418"
dependencies = [
 "arrayvec",
 "auto_impl",
 "bytes",
]

[[package]]
name = "ff"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ded41244b729663b1e574f1b4fb731469f69f79c17667b5d776b16cda0479449"
dependencies = [
 "rand_core 0.6.4",
 "subtle 2.6.1",
]

[[package]]
name = "fixed-hash"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "835c052cb0c08c1acf6ffd71c022172e18723949c8282f2b9f27efbc51e64534"
dependencies = [
 "byteorder",
 "rand 0.8.5",
 "rustc-hex",
 "static_assertions",
]

[[package]]
name = "fixedbitset"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ce7134b9999ecaf8bcd65542e436736ef32ddca1b3e06094cb6ec5755203b80"

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foldhash"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f81ec6369c545a7d40e4589b5597581fa1c441fe1cce96dd1de43159910a36a2"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "form_urlencoded"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "fs2"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9564fc758e15025b46aa6643b1b77d047d1a56a1aea6e01002ac0c7026876213"
dependencies = [
 "libc",
 "winapi",
]

[[package]]
name = "funty"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6d5a32815ae3f33302d95fdcb2ce17862f8c65363dcfd29360480ba1001fc9c"

[[package]]
name = "futures"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-executor"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-macro"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "futures-utils-wasm"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42012b0f064e01aa58b545fe3727f90f7dd4020f4a3ea735b50344965f5a57e9"

[[package]]
name = "fxhash"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c31b6d751ae2c7f11320402d34e41349dd1016f8d5d45e48c4312bc8625af50c"
dependencies = [
 "byteorder",
]

[[package]]
name = "generic-array"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ffdf9f34f1447443d37393cc6c2b8313aebddcd96906caf34e54c68d8e57d7bd"
dependencies = [
 "typenum",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
 "zeroize",
]

[[package]]
name = "getrandom"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fc3cb4d91f53b50155bdcfd23f6a4c39ae1969c2ae85982b135750cccaf5fce"
dependencies = [
 "cfg-if",
 "libc",
 "wasi 0.9.0+wasi-snapshot-preview1",
]

[[package]]
name = "getrandom"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
dependencies = [
 "cfg-if",
 "libc",
 "wasi 0.11.0+wasi-snapshot-preview1",
]

[[package]]
name = "ghash"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0d8a4362ccb29cb0b265253fb0a2728f592895ee6854fd9bc13f2ffda266ff1"
dependencies = [
 "opaque-debug 0.3.1",
 "polyval",
]

[[package]]
name = "gimli"
version = "0.31.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"

[[package]]
name = "glob"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2fabcfbdc87f4758337ca535fb41a6d701b65693ce38287d856d1674551ec9b"

[[package]]
name = "group"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0f9ef7462f7c099f518d754361858f86d8a07af53ba9af0fe635bbccb151a63"
dependencies = [
 "ff",
 "rand_core 0.6.4",
 "subtle 2.6.1",
]

[[package]]
name = "h2"
version = "0.3.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81fe527a889e1532da5c525686d96d4c2e74cdd345badf8dfef9f6b39dd5f5e8"
dependencies = [
 "bytes",
 "fnv",
 "futures-core",
 "futures-sink",
 "futures-util",
 "http 0.2.12",
 "indexmap",
 "slab",
 "tokio",
 "tokio-util",
 "tracing",
]

[[package]]
name = "h2"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "524e8ac6999421f49a846c2d4411f337e53497d8ec55d67753beffa43c5d9205"
dependencies = [
 "atomic-waker",
 "bytes",
 "fnv",
 "futures-core",
 "futures-sink",
 "http 1.1.0",
 "indexmap",
 "slab",
 "tokio",
 "tokio-util",
 "tracing",
]

[[package]]
name = "hashbrown"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"

[[package]]
name = "hashbrown"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e087f84d4f86bf4b218b927129862374b72199ae7d8657835f1e89000eea4fb"
dependencies = [
 "allocator-api2",
 "equivalent",
 "foldhash",
 "serde",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hermit-abi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231dfb89cfffdbc30e7fc41579ed6066ad03abda9e567ccafae602b97ec5024"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"
dependencies = [
 "serde",
]

[[package]]
name = "hex-conservative"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "212ab92002354b4819390025006c897e8140934349e8635c9b077f47b4dcbd20"

[[package]]
name = "hex-literal"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fe2267d4ed49bc07b63801559be28c718ea06c4738b7a03c94df7386d2cde46"

[[package]]
name = "hmac"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5dcb5e64cda4c23119ab41ba960d1e170a774c8e4b9d9e6a9bc18aabf5e59695"
dependencies = [
 "crypto-mac",
 "digest 0.8.1",
]

[[package]]
name = "hmac"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e"
dependencies = [
 "digest 0.10.7",
]

[[package]]
name = "hmac-drbg"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c6e570451493f10f6581b48cdd530413b63ea9e780f544bfd3bdcaa0d89d1a7b"
dependencies = [
 "digest 0.8.1",
 "generic-array 0.12.4",
 "hmac 0.7.1",
]

[[package]]
name = "http"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "601cbb57e577e2f5ef5be8e7b83f0f63994f25aa94d673e54a92d5c516d101f1"
dependencies = [
 "bytes",
 "fnv",
 "itoa",
]

[[package]]
name = "http"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "21b9ddb458710bc376481b842f5da65cdf31522de232c1ca8146abce2a358258"
dependencies = [
 "bytes",
 "fnv",
 "itoa",
]

[[package]]
name = "http-body"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7ceab25649e9960c0311ea418d17bee82c0dcec1bd053b5f9a66e265a693bed2"
dependencies = [
 "bytes",
 "http 0.2.12",
 "pin-project-lite",
]

[[package]]
name = "http-body"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1efedce1fb8e6913f23e0c92de8e62cd5b772a67e7b3946df930a62566c93184"
dependencies = [
 "bytes",
 "http 1.1.0",
]

[[package]]
name = "http-body-util"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793429d76616a256bcb62c2a2ec2bed781c8307e797e2598c50010f2bee2544f"
dependencies = [
 "bytes",
 "futures-util",
 "http 1.1.0",
 "http-body 1.0.1",
 "pin-project-lite",
]

[[package]]
name = "httparse"
version = "1.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d71d3574edd2771538b901e6549113b4006ece66150fb69c0fb6d9a2adae946"

[[package]]
name = "httpdate"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df3b46402a9d5adb4c86a0cf463f42e19994e3ee891101b1841f30a545cb49a9"

[[package]]
name = "hyper"
version = "0.14.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c08302e8fa335b151b788c775ff56e7a03ae64ff85c548ee820fecb70356e85"
dependencies = [
 "bytes",
 "futures-channel",
 "futures-core",
 "futures-util",
 "h2 0.3.26",
 "http 0.2.12",
 "http-body 0.4.6",
 "httparse",
 "httpdate",
 "itoa",
 "pin-project-lite",
 "socket2",
 "tokio",
 "tower-service",
 "tracing",
 "want",
]

[[package]]
name = "hyper"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbbff0a806a4728c99295b254c8838933b5b082d75e3cb70c8dab21fdfbcfa9a"
dependencies = [
 "bytes",
 "futures-channel",
 "futures-util",
 "h2 0.4.6",
 "http 1.1.0",
 "http-body 1.0.1",
 "httparse",
 "httpdate",
 "itoa",
 "pin-project-lite",
 "smallvec",
 "tokio",
 "want",
]

[[package]]
name = "hyper-tls"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d6183ddfa99b85da61a140bea0efc93fdf56ceaa041b37d553518030827f9905"
dependencies = [
 "bytes",
 "hyper 0.14.31",
 "native-tls",
 "tokio",
 "tokio-native-tls",
]

[[package]]
name = "hyper-tls"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70206fc6890eaca9fde8a0bf71caa2ddfc9fe045ac9e5c70df101a7dbde866e0"
dependencies = [
 "bytes",
 "http-body-util",
 "hyper 1.5.0",
 "hyper-util",
 "native-tls",
 "tokio",
 "tokio-native-tls",
 "tower-service",
]

[[package]]
name = "hyper-util"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41296eb09f183ac68eec06e03cdbea2e759633d4067b2f6552fc2e009bcad08b"
dependencies = [
 "bytes",
 "futures-channel",
 "futures-util",
 "http 1.1.0",
 "http-body 1.0.1",
 "hyper 1.5.0",
 "pin-project-lite",
 "socket2",
 "tokio",
 "tower-service",
 "tracing",
]

[[package]]
name = "idna"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "634d9b1461af396cad843f47fdba5597a4f9e6ddd4bfb6ff5d85028c25cb12f6"
dependencies = [
 "unicode-bidi",
 "unicode-normalization",
]

[[package]]
name = "impl-codec"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba6a270039626615617f3f36d15fc827041df3b78c439da2cadfa47455a77f2f"
dependencies = [
 "parity-scale-codec",
]

[[package]]
name = "impl-trait-for-tuples"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "11d7a9f6330b71fea57921c9b61c47ee6e84f72d394754eff6163ae67e7395eb"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "indexmap"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "707907fe3c25f5424cce2cb7e1cbcafee6bdbe735ca90ef77c29e84591e5b9da"
dependencies = [
 "equivalent",
 "hashbrown 0.15.0",
 "serde",
]

[[package]]
name = "inout"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a0c10553d664a4d0bcff9f4215d0aac67a639cc68ef660840afe309b807bc9f5"
dependencies = [
 "generic-array 0.14.7",
]

[[package]]
name = "instant"
version = "0.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0242819d153cba4b4b05a5a8f2a7e9bbf97b6055b2a002b395c96b5ff3c0222"
dependencies = [
 "cfg-if",
]

[[package]]
name = "interprocess"
version = "2.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "894148491d817cb36b6f778017b8ac46b17408d522dd90f539d677ea938362eb"
dependencies = [
 "doctest-file",
 "futures-core",
 "libc",
 "recvmsg",
 "tokio",
 "widestring",
 "windows-sys 0.52.0",
]

[[package]]
name = "ipnet"
version = "2.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ddc24109865250148c2e0f3d25d4f0f479571723792d3802153c60922a4fb708"

[[package]]
name = "itertools"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
dependencies = [
 "either",
]

[[package]]
name = "itertools"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba291022dbbd398a455acf126c1e341954079855bc60dfdda641363bd6922569"
dependencies = [
 "either",
]

[[package]]
name = "itertools"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "413ee7dfc52ee1a4949ceeb7dbc8a33f2d6c088194d9f922fb8318faf1f01186"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49f1f14873335454500d59611f1cf4a4b0f786f9ac11f4312a78e4cf2566695b"

[[package]]
name = "js-sys"
version = "0.3.72"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a88f1bda2bd75b0452a14784937d796722fdebfe50df998aeb3f0b7603019a9"
dependencies = [
 "wasm-bindgen",
]

[[package]]
name = "k256"
version = "0.13.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6e3919bbaa2945715f0bb6d3934a173d1e9a59ac23767fbaaef277265a7411b"
dependencies = [
 "cfg-if",
 "ecdsa",
 "elliptic-curve",
 "once_cell",
 "sha2 0.10.8",
 "signature",
]

[[package]]
name = "keccak"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ecc2af9a1119c51f12a14607e783cb977bde58bc069ff0c3da1095e635d70654"
dependencies = [
 "cpufeatures",
]

[[package]]
name = "keccak-asm"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "505d1856a39b200489082f90d897c3f07c455563880bc5952e38eabf731c83b6"
dependencies = [
 "digest 0.10.7",
 "sha3-asm",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.161"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9489c2807c139ffd9c1794f4af0ebe86a828db53ecdc7fea2111d0fed085d1"

[[package]]
name = "libm"
version = "0.2.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3bda4c6077b0b08da2c48b172195795498381a7c8988c9e6212a6c55c5b9bd70"

[[package]]
name = "libredox"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0ff37bd590ca25063e35af745c343cb7a0271906fb7b37e4813e8f79f00268d"
dependencies = [
 "bitflags 2.6.0",
 "libc",
]

[[package]]
name = "libsecp256k1"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fc1e2c808481a63dc6da2074752fdd4336a3c8fcc68b83db6f1fd5224ae7962"
dependencies = [
 "arrayref",
 "crunchy",
 "digest 0.8.1",
 "hmac-drbg",
 "rand 0.7.3",
 "sha2 0.8.2",
 "subtle 2.6.1",
 "typenum",
]

[[package]]
name = "linux-raw-sys"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78b3ae25bc7c8c38cec158d1f2757ee79e9b3740fbc7ccf0e59e4b08d793fa89"

[[package]]
name = "lock_api"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7a70ba024b9dc04c27ea2f0c0548feb474ec5c54bba33a7f72f873a39d07b24"

[[package]]
name = "lru"
version = "0.12.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "234cf4f4a04dc1f57e24b96cc0cd600cf2af460d4161ac5ecdd0af8e1f3b2a38"
dependencies = [
 "hashbrown 0.15.0",
]

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "memzero"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93c0d11ac30a033511ae414355d80f70d9f29a44a49140face477117a1ee90db"

[[package]]
name = "mime"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"

[[package]]
name = "miniz_oxide"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2d80299ef12ff69b16a84bb182e3b9df68b5a91574d3d4fa6e41b65deec4df1"
dependencies = [
 "adler2",
]

[[package]]
name = "mio"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80e04d1dcff3aae0704555fe5fee3bcfaf3d1fdf8a7e521d5b9d2b42acb52cec"
dependencies = [
 "hermit-abi",
 "libc",
 "wasi 0.11.0+wasi-snapshot-preview1",
 "windows-sys 0.52.0",
]

[[package]]
name = "mockito"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09b34bd91b9e5c5b06338d392463e1318d683cf82ec3d3af4014609be6e2108d"
dependencies = [
 "assert-json-diff",
 "bytes",
 "colored",
 "futures-util",
 "http 1.1.0",
 "http-body 1.0.1",
 "http-body-util",
 "hyper 1.5.0",
 "hyper-util",
 "log",
 "rand 0.8.5",
 "regex",
 "serde_json",
 "serde_urlencoded",
 "similar",
 "tokio",
]

[[package]]
name = "multimap"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "defc4c55412d89136f966bbb339008b474350e5e6e78d2714439c386b3137a03"

[[package]]
name = "native-tls"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8614eb2c83d59d1c8cc974dd3f920198647674a0a035e1af1fa58707e317466"
dependencies = [
 "libc",
 "log",
 "openssl",
 "openssl-probe",
 "openssl-sys",
 "schannel",
 "security-framework",
 "security-framework-sys",
 "tempfile",
]

[[package]]
name = "network"
version = "0.1.0"
dependencies = [
 "alloy",
 "config",
 "hex",
 "mockito",
 "proto",
 "serde",
 "serde_json",
 "tokio",
 "wallet",
 "zil_errors",
 "zilliqa",
]

[[package]]
name = "ntrulp"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74131f852a50b9cbc0b5cae02165fddc39dc5236d18d08b258438cfdc1467706"
dependencies = [
 "num_cpus",
 "rand 0.8.5",
 "rand_chacha 0.3.1",
]

[[package]]
name = "num-bigint"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a5e44f723f1133c9deac646763579fdb3ac745e418f2a7af9cd0c431da1f20b9"
dependencies = [
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-integer"
version = "0.1.46"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
dependencies = [
 "num-traits",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
 "libm",
]

[[package]]
name = "num_cpus"
version = "1.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4161fcb6d602d4d2081af7c3a45852d875a03dd337a6bfdd6e06407b61342a43"
dependencies = [
 "hermit-abi",
 "libc",
]

[[package]]
name = "num_enum"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e613fc340b2220f734a8595782c551f1250e969d87d3be1ae0579e8d4065179"
dependencies = [
 "num_enum_derive",
]

[[package]]
name = "num_enum_derive"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af1844ef2428cc3e1cb900be36181049ef3d3193c63e43026cfe202983b27a56"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "object"
version = "0.36.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aedf0a2d09c573ed1d8d85b30c119153926a2b36dce0ab28322c09a117a4683e"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.20.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1261fe7e33c73b354eab43b1273a57c8f967d0391e80353e51f764ac02cf6775"

[[package]]
name = "opaque-debug"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2839e79665f131bdb5782e51f2c6c9599c133c6098982a54c794358bf432529c"

[[package]]
name = "opaque-debug"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08d65885ee38876c4f86fa503fb49d7b507c2b62552df7c70b2fce627e06381"

[[package]]
name = "openssl"
version = "0.10.68"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6174bc48f102d208783c2c84bf931bb75927a617866870de8a4ea85597f871f5"
dependencies = [
 "bitflags 2.6.0",
 "cfg-if",
 "foreign-types",
 "libc",
 "once_cell",
 "openssl-macros",
 "openssl-sys",
]

[[package]]
name = "openssl-macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "openssl-probe"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf"

[[package]]
name = "openssl-sys"
version = "0.9.104"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "45abf306cbf99debc8195b66b7346498d7b10c210de50418b5ccd7ceba08c741"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "option-ext"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04744f49eae99ab78e0d5c0b603ab218f515ea8cfe5a456d7629ad883a3b6e7d"

[[package]]
name = "parity-scale-codec"
version = "3.6.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "306800abfa29c7f16596b5970a588435e3d5b3149683d00c12b699cc19f895ee"
dependencies = [
 "arrayvec",
 "bitvec",
 "byte-slice-cast",
 "impl-trait-for-tuples",
 "parity-scale-codec-derive",
 "serde",
]

[[package]]
name = "parity-scale-codec-derive"
version = "3.6.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d830939c76d294956402033aee57a6da7b438f2294eb94864c37b0569053a42c"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "parking_lot"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d17b78036a60663b797adeaee46f5c9dfebb86948d1255007a1d6be0271ff99"
dependencies = [
 "instant",
 "lock_api",
 "parking_lot_core 0.8.6",
]

[[package]]
name = "parking_lot"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1bf18183cf54e8d6059647fc3063646a1801cf30896933ec2311622cc4b9a27"
dependencies = [
 "lock_api",
 "parking_lot_core 0.9.10",
]

[[package]]
name = "parking_lot_core"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60a2cfe6f0ad2bfc16aefa463b497d5c7a5ecd44a23efa72aa342d90177356dc"
dependencies = [
 "cfg-if",
 "instant",
 "libc",
 "redox_syscall 0.2.16",
 "smallvec",
 "winapi",
]

[[package]]
name = "parking_lot_core"
version = "0.9.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall 0.5.7",
 "smallvec",
 "windows-targets 0.52.6",
]

[[package]]
name = "password-hash"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "346f04948ba92c43e8469c1ee6736c7563d71012b17d40745260fe106aac2166"
dependencies = [
 "base64ct",
 "rand_core 0.6.4",
 "subtle 2.6.1",
]

[[package]]
name = "paste"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"

[[package]]
name = "percent-encoding"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"

[[package]]
name = "pest"
version = "2.7.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "879952a81a83930934cbf1786752d6dedc3b1f29e8f8fb2ad1d0a36f377cf442"
dependencies = [
 "memchr",
 "thiserror",
 "ucd-trie",
]

[[package]]
name = "petgraph"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4c5cc86750666a3ed20bdaf5ca2a0344f9c67674cae0515bec2da16fbaa47db"
dependencies = [
 "fixedbitset",
 "indexmap",
]

[[package]]
name = "pharos"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e9567389417feee6ce15dd6527a8a1ecac205ef62c2932bcf3d9f6fc5b78b414"
dependencies = [
 "futures",
 "rustc_version 0.4.1",
]

[[package]]
name = "pin-project"
version = "1.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be57f64e946e500c8ee36ef6331845d40a93055567ec57e8fae13efd33759b95"
dependencies = [
 "pin-project-internal",
]

[[package]]
name = "pin-project-internal"
version = "1.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c0f5fad0874fc7abcd4d750e76917eaebbecaa2c20bde22e1dbeeba8beb758c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "pin-project-lite"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "915a1e146535de9163f3987b8944ed8cf49a18bb0056bcebcdcece385cece4ff"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkcs8"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f950b2377845cebe5cf8b5165cb3cc1a5e0fa5cfa3e1f7f55707d8fd82e0a7b7"
dependencies = [
 "der",
 "spki",
]

[[package]]
name = "pkg-config"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "953ec861398dccce10c670dfeaf3ec4911ca479e9c02154b3a215178c5f566f2"

[[package]]
name = "polyval"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d1fe60d06143b2430aa532c94cfe9e29783047f06c0d7fd359a9a51b729fa25"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "opaque-debug 0.3.1",
 "universal-hash",
]

[[package]]
name = "ppv-lite86"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77957b295656769bb8ad2b6a6b09d897d94f05c41b069aede1fcdaa675eaea04"
dependencies = [
 "zerocopy",
]

[[package]]
name = "prettyplease"
version = "0.2.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64d1ec885c64d0457d564db4ec299b2dae3f9c02808b8ad9c3a089c591b18033"
dependencies = [
 "proc-macro2",
 "syn 2.0.85",
]

[[package]]
name = "primitive-types"
version = "0.12.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b34d9fd68ae0b74a41b21c03c2f62847aa0ffea044eee893b4c140b37e244e2"
dependencies = [
 "fixed-hash",
 "impl-codec",
 "uint",
]

[[package]]
name = "proc-macro-crate"
version = "3.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ecf48c7ca261d60b74ab1a7b20da18bede46776b2e55535cb958eb595c5fa7b"
dependencies = [
 "toml_edit",
]

[[package]]
name = "proc-macro-error-attr2"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96de42df36bb9bba5542fe9f1a054b8cc87e172759a1868aa05c1f3acc89dfc5"
dependencies = [
 "proc-macro2",
 "quote",
]

[[package]]
name = "proc-macro-error2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "11ec05c52be0a07b08061f7dd003e7d7092e0472bc731b4af7bb1ef876109802"
dependencies = [
 "proc-macro-error-attr2",
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "proc-macro2"
version = "1.0.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f139b0662de085916d1fb67d2b4169d1addddda1919e696f3252b740b629986e"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "proptest"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4c2511913b88df1637da85cc8d96ec8e43a3f8bb8ccb71ee1ac240d6f3df58d"
dependencies = [
 "bit-set",
 "bit-vec",
 "bitflags 2.6.0",
 "lazy_static",
 "num-traits",
 "rand 0.8.5",
 "rand_chacha 0.3.1",
 "rand_xorshift",
 "regex-syntax",
 "rusty-fork",
 "tempfile",
 "unarray",
]

[[package]]
name = "prost"
version = "0.12.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "deb1435c188b76130da55f17a466d252ff7b1418b2ad3e037d127b94e3411f29"
dependencies = [
 "bytes",
 "prost-derive",
]

[[package]]
name = "prost-build"
version = "0.12.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22505a5c94da8e3b7c2996394d1c933236c4d743e81a410bcca4e6989fc066a4"
dependencies = [
 "bytes",
 "heck",
 "itertools 0.12.1",
 "log",
 "multimap",
 "once_cell",
 "petgraph",
 "prettyplease",
 "prost",
 "prost-types",
 "regex",
 "syn 2.0.85",
 "tempfile",
]

[[package]]
name = "prost-derive"
version = "0.12.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81bddcdb20abf9501610992b6759a4c888aef7d1a7247ef75e2404275ac24af1"
dependencies = [
 "anyhow",
 "itertools 0.12.1",
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "prost-types"
version = "0.12.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9091c90b0a32608e984ff2fa4091273cbdd755d54935c51d520887f4a1dbd5b0"
dependencies = [
 "prost",
]

[[package]]
name = "proto"
version = "0.1.0"
dependencies = [
 "alloy",
 "bech32",
 "bincode",
 "bip39",
 "config",
 "crypto",
 "hex",
 "k256",
 "prost",
 "prost-build",
 "rand 0.8.5",
 "rand_chacha 0.3.1",
 "ripemd",
 "serde",
 "serde_json",
 "sha2 0.10.8",
 "tiny-hderive",
 "zil_errors",
]

[[package]]
name = "quick-error"
version = "1.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1d01941d82fa2ab50be1e79e6714289dd7cde78eba4c074bc5a4374f650dfe0"

[[package]]
name = "quote"
version = "1.0.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5b9d34b8991d19d98081b46eacdd8eb58c6f2b201139f7c5f643cc155a633af"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "radium"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc33ff2d4973d518d823d61aa239014831e521c75da58e3df4840d3f47749d09"

[[package]]
name = "rand"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03"
dependencies = [
 "getrandom 0.1.16",
 "libc",
 "rand_chacha 0.2.2",
 "rand_core 0.5.1",
 "rand_hc",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha 0.3.1",
 "rand_core 0.6.4",
 "serde",
]

[[package]]
name = "rand_chacha"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402"
dependencies = [
 "ppv-lite86",
 "rand_core 0.5.1",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core 0.6.4",
]

[[package]]
name = "rand_core"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19"
dependencies = [
 "getrandom 0.1.16",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom 0.2.15",
]

[[package]]
name = "rand_hc"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c"
dependencies = [
 "rand_core 0.5.1",
]

[[package]]
name = "rand_xorshift"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d25bf25ec5ae4a3f1b92f929810509a2f53d7dca2f50b794ff57e3face536c8f"
dependencies = [
 "rand_core 0.6.4",
]

[[package]]
name = "recvmsg"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3edd4d5d42c92f0a659926464d4cce56b562761267ecf0f469d85b7de384175"

[[package]]
name = "redox_syscall"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_syscall"
version = "0.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b6dfecf2c74bce2466cabf93f6664d6998a69eb21e39f4207930065b27b771f"
dependencies = [
 "bitflags 2.6.0",
]

[[package]]
name = "redox_users"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba009ff324d1fc1b900bd1fdb31564febe58a8ccc8a6fdbb93b543d33b13ca43"
dependencies = [
 "getrandom 0.2.15",
 "libredox",
 "thiserror",
]

[[package]]
name = "regex"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "368758f23274712b504848e9d5a6f010445cc8b87a7cdb4d7cbee666c1288da3"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"

[[package]]
name = "reqwest"
version = "0.11.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd67538700a17451e7cba03ac727fb961abb7607553461627b97de0b89cf4a62"
dependencies = [
 "base64 0.21.7",
 "bytes",
 "encoding_rs",
 "futures-core",
 "futures-util",
 "h2 0.3.26",
 "http 0.2.12",
 "http-body 0.4.6",
 "hyper 0.14.31",
 "hyper-tls 0.5.0",
 "ipnet",
 "js-sys",
 "log",
 "mime",
 "native-tls",
 "once_cell",
 "percent-encoding",
 "pin-project-lite",
 "rustls-pemfile 1.0.4",
 "serde",
 "serde_json",
 "serde_urlencoded",
 "sync_wrapper 0.1.2",
 "system-configuration",
 "tokio",
 "tokio-native-tls",
 "tower-service",
 "url",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "winreg",
]

[[package]]
name = "reqwest"
version = "0.12.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f713147fbe92361e52392c73b8c9e48c04c6625bce969ef54dc901e58e042a7b"
dependencies = [
 "base64 0.22.1",
 "bytes",
 "futures-core",
 "futures-util",
 "http 1.1.0",
 "http-body 1.0.1",
 "http-body-util",
 "hyper 1.5.0",
 "hyper-tls 0.6.0",
 "hyper-util",
 "ipnet",
 "js-sys",
 "log",
 "mime",
 "native-tls",
 "once_cell",
 "percent-encoding",
 "pin-project-lite",
 "rustls-pemfile 2.2.0",
 "serde",
 "serde_json",
 "serde_urlencoded",
 "sync_wrapper 1.0.1",
 "tokio",
 "tokio-native-tls",
 "tower-service",
 "url",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "windows-registry",
]

[[package]]
name = "rfc6979"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8dd2a808d456c4a54e300a23e9f5a67e122c3024119acbfd73e3bf664491cb2"
dependencies = [
 "hmac 0.12.1",
 "subtle 2.6.1",
]

[[package]]
name = "ring"
version = "0.17.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c17fa4cb658e3583423e915b9f3acc01cceaee1860e33d59ebae66adc3a2dc0d"
dependencies = [
 "cc",
 "cfg-if",
 "getrandom 0.2.15",
 "libc",
 "spin",
 "untrusted",
 "windows-sys 0.52.0",
]

[[package]]
name = "ripemd"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd124222d17ad93a644ed9d011a40f4fb64aa54275c08cc216524a9ea82fb09f"
dependencies = [
 "digest 0.10.7",
]

[[package]]
name = "rlp"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb919243f34364b6bd2fc10ef797edbfa75f33c252e7998527479c6d6b47e1ec"
dependencies = [
 "bytes",
 "rustc-hex",
]

[[package]]
name = "ruint"
version = "1.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c3cc4c2511671f327125da14133d0c5c5d137f006a1017a16f557bc85b16286"
dependencies = [
 "alloy-rlp",
 "ark-ff 0.3.0",
 "ark-ff 0.4.2",
 "bytes",
 "fastrlp",
 "num-bigint",
 "num-traits",
 "parity-scale-codec",
 "primitive-types",
 "proptest",
 "rand 0.8.5",
 "rlp",
 "ruint-macro",
 "serde",
 "valuable",
 "zeroize",
]

[[package]]
name = "ruint-macro"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48fd7bd8a6377e15ad9d42a8ec25371b94ddc67abe7c8b9127bec79bebaaae18"

[[package]]
name = "rustc-demangle"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"

[[package]]
name = "rustc-hash"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "583034fd73374156e66797ed8e5b0d5690409c9226b22d87cb7f19821c05d152"

[[package]]
name = "rustc-hex"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3e75f6a532d0fd9f7f13144f392b6ad56a32696bfcd9c78f797f16bbb6f072d6"

[[package]]
name = "rustc_version"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0dfe2087c51c460008730de8b57e6a320782fbfb312e1f4d520e6c6fae155ee"
dependencies = [
 "semver 0.11.0",
]

[[package]]
name = "rustc_version"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
dependencies = [
 "semver 1.0.23",
]

[[package]]
name = "rustix"
version = "0.38.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8acb788b847c24f28525660c4d7758620a7210875711f79e7f663cc152726811"
dependencies = [
 "bitflags 2.6.0",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.52.0",
]

[[package]]
name = "rustls"
version = "0.23.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eee87ff5d9b36712a58574e12e9f0ea80f915a5b0ac518d322b24a465617925e"
dependencies = [
 "once_cell",
 "ring",
 "rustls-pki-types",
 "rustls-webpki",
 "subtle 2.6.1",
 "zeroize",
]

[[package]]
name = "rustls-pemfile"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1c74cae0a4cf6ccbbf5f359f08efdf8ee7e1dc532573bf0db71968cb56b1448c"
dependencies = [
 "base64 0.21.7",
]

[[package]]
name = "rustls-pemfile"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dce314e5fee3f39953d46bb63bb8a46d40c2f8fb7cc5a3b6cab2bde9721d6e50"
dependencies = [
 "rustls-pki-types",
]

[[package]]
name = "rustls-pki-types"
version = "1.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "16f1201b3c9a7ee8039bcadc17b7e605e2945b27eee7631788c1bd2b0643674b"

[[package]]
name = "rustls-webpki"
version = "0.102.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64ca1bc8749bd4cf37b5ce386cc146580777b4e8572c7b97baf22c83f444bee9"
dependencies = [
 "ring",
 "rustls-pki-types",
 "untrusted",
]

[[package]]
name = "rustversion"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e819f2bc632f285be6d7cd36e25940d45b2391dd6d9b939e79de557f7014248"

[[package]]
name = "rusty-fork"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb3dcc6e454c328bb824492db107ab7c0ae8fcffe4ad210136ef014458c1bc4f"
dependencies = [
 "fnv",
 "quick-error",
 "tempfile",
 "wait-timeout",
]

[[package]]
name = "ryu"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3cb5ba0dc43242ce17de99c180e96db90b235b8a9fdc9543c96d2209116bd9f"

[[package]]
name = "schannel"
version = "0.1.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "01227be5826fa0690321a2ba6c5cd57a19cf3f6a09e76973b58e61de6ab9d1c1"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "sec1"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3e97a565f76233a6003f9f5c54be1d9c5bdfa3eccfb189469f11ec4901c47dc"
dependencies = [
 "base16ct",
 "der",
 "generic-array 0.14.7",
 "pkcs8",
 "subtle 2.6.1",
 "zeroize",
]

[[package]]
name = "security-framework"
version = "2.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "897b2245f0b511c87893af39b033e5ca9cce68824c4d7e7630b5a1d339658d02"
dependencies = [
 "bitflags 2.6.0",
 "core-foundation",
 "core-foundation-sys",
 "libc",
 "security-framework-sys",
]

[[package]]
name = "security-framework-sys"
version = "2.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea4a292869320c0272d7bc55a5a6aafaff59b4f63404a003887b679a2e05b4b6"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "semver"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f301af10236f6df4160f7c3f04eec6dbc70ace82d23326abad5edee88801c6b6"
dependencies = [
 "semver-parser",
]

[[package]]
name = "semver"
version = "1.0.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61697e0a1c7e512e84a621326239844a24d8207b4669b41bc18b32ea5cbf988b"

[[package]]
name = "semver-parser"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0bef5b7f9e0df16536d3961cfb6e84331c065b4066afb39768d0e319411f7"
dependencies = [
 "pest",
]

[[package]]
name = "send_wrapper"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd0b0ec5f1c1ca621c432a25813d8d60c88abe6d3e08a3eb9cf37d97a0fe3d73"

[[package]]
name = "serde"
version = "1.0.213"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ea7893ff5e2466df8d720bb615088341b295f849602c6956047f8f80f0e9bc1"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.213"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e85ad2009c50b58e87caa8cd6dac16bdf511bbfb7af6c33df902396aa480fa5"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "serde_json"
version = "1.0.132"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d726bfaff4b320266d395898905d0eba0345aae23b54aee3a737e260fd46db03"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "serde_urlencoded"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
dependencies = [
 "form_urlencoded",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "session"
version = "0.1.0"
dependencies = [
 "cipher 0.1.0",
 "config",
 "rand 0.8.5",
 "rand_chacha 0.3.1",
 "zil_errors",
]

[[package]]
name = "settings"
version = "0.1.0"
dependencies = [
 "cipher 0.1.0",
 "config",
 "serde",
 "serde_json",
 "zil_errors",
]

[[package]]
name = "sha1"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3bf829a2d51ab4a5ddf1352d8470c140cadc8301b2ae1789db023f01cedd6ba"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest 0.10.7",
]

[[package]]
name = "sha2"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a256f46ea78a0c0d9ff00077504903ac881a1dafdc20da66545699e7776b3e69"
dependencies = [
 "block-buffer 0.7.3",
 "digest 0.8.1",
 "fake-simd",
 "opaque-debug 0.2.3",
]

[[package]]
name = "sha2"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest 0.10.7",
]

[[package]]
name = "sha3"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75872d278a8f37ef87fa0ddbda7802605cb18344497949862c0d4dcb291eba60"
dependencies = [
 "digest 0.10.7",
 "keccak",
]

[[package]]
name = "sha3-asm"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c28efc5e327c837aa837c59eae585fc250715ef939ac32881bcc11677cd02d46"
dependencies = [
 "cc",
 "cfg-if",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook-registry"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9e9e0b4211b72e7b8b6e85c807d36c212bdb33ea8587f7569562a84df5465b1"
dependencies = [
 "libc",
]

[[package]]
name = "signature"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77549399552de45a898a580c1b41d445bf730df867cc44e6c0233bbc4b8329de"
dependencies = [
 "digest 0.10.7",
 "rand_core 0.6.4",
]

[[package]]
name = "similar"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1de1d4f81173b03af4c0cbed3c898f6bff5b870e4a7f5d6f4057d62a7a4b686e"

[[package]]
name = "slab"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f92a496fb766b417c996b9c5e57daf2f7ad3b0bebe1ccfca4856390e3d3bb67"
dependencies = [
 "autocfg",
]

[[package]]
name = "sled"
version = "0.34.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f96b4737c2ce5987354855aed3797279def4ebf734436c6aa4552cf8e169935"
dependencies = [
 "crc32fast",
 "crossbeam-epoch",
 "crossbeam-utils",
 "fs2",
 "fxhash",
 "libc",
 "log",
 "parking_lot 0.11.2",
]

[[package]]
name = "smallvec"
version = "1.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67"

[[package]]
name = "socket2"
version = "0.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce305eb0b4296696835b71df73eb912e0f1ffd2556a501fcede6e0c50349191c"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "spin"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67"

[[package]]
name = "spki"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d91ed6c858b01f942cd56b37a94b3e0a1798290327d1236e4d9cf4eaca44d29d"
dependencies = [
 "base64ct",
 "der",
]

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "storage"
version = "0.1.0"
dependencies = [
 "bincode",
 "config",
 "directories",
 "hex",
 "sled",
 "zil_errors",
]

[[package]]
name = "strum"
version = "0.26.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fec0f0aef304996cf250b31b5a10dee7980c85da9d759361292b8bca5a18f06"
dependencies = [
 "strum_macros",
]

[[package]]
name = "strum_macros"
version = "0.26.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c6bee85a5a24955dc440386795aa378cd9cf82acd5f764469152d2270e581be"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "rustversion",
 "syn 2.0.85",
]

[[package]]
name = "subtle"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2d67a5a62ba6e01cb2192ff309324cb4875d0c451d55fe2319433abe7a05a8ee"

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.85"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5023162dfcd14ef8f32034d8bcd4cc5ddc61ef7a247c024a33e24e1f24d21b56"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn-solidity"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d5e0c2ea8db64b2898b62ea2fbd60204ca95e0b2c6bdf53ff768bbe916fbe4d"
dependencies = [
 "paste",
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "sync_wrapper"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2047c6ded9c721764247e62cd3b03c09ffc529b2ba5b10ec482ae507a4a70160"

[[package]]
name = "sync_wrapper"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7065abeca94b6a8a577f9bd45aa0867a2238b74e8eb67cf10d492bc39351394"
dependencies = [
 "futures-core",
]

[[package]]
name = "system-configuration"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba3a3adc5c275d719af8cb4272ea1c4a6d668a777f37e115f6d11ddbc1c8e0e7"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation",
 "system-configuration-sys",
]

[[package]]
name = "system-configuration-sys"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75fb188eb626b924683e3b95e3a48e63551fcfb51949de2f06a9d91dbee93c9"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "tap"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369"

[[package]]
name = "tempfile"
version = "3.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0f2c9fc62d0beef6951ccffd757e241266a2c833136efbe35af6cd2567dca5b"
dependencies = [
 "cfg-if",
 "fastrand",
 "once_cell",
 "rustix",
 "windows-sys 0.59.0",
]

[[package]]
name = "thiserror"
version = "1.0.65"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d11abd9594d9b38965ef50805c5e469ca9cc6f197f883f717e0269a3057b3d5"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.65"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae71770322cbd277e69d762a16c444af02aa0575ac0d174f0b9562d3b37f8602"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "threadpool"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d050e60b33d41c19108b32cea32164033a9013fe3b46cbd4457559bfbf77afaa"
dependencies = [
 "num_cpus",
]

[[package]]
name = "tiny-hderive"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "01b874a4992538d4b2f4fbbac11b9419d685f4b39bdc3fed95b04e07bfd76040"
dependencies = [
 "base58",
 "hmac 0.7.1",
 "libsecp256k1",
 "memzero",
 "sha2 0.8.2",
]

[[package]]
name = "tiny-keccak"
version = "2.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c9d3793400a45f954c52e73d068316d76b6f4e36977e3fcebb13a2721e80237"
dependencies = [
 "crunchy",
]

[[package]]
name = "tinyvec"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "445e881f4f6d382d5f27c034e25eb92edd7c784ceab92a0937db7f2e9471b938"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "tokio"
version = "1.41.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "145f3413504347a2be84393cc8a7d2fb4d863b375909ea59f2158261aa258bbb"
dependencies = [
 "backtrace",
 "bytes",
 "libc",
 "mio",
 "parking_lot 0.12.3",
 "pin-project-lite",
 "signal-hook-registry",
 "socket2",
 "tokio-macros",
 "windows-sys 0.52.0",
]

[[package]]
name = "tokio-macros"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "693d596312e88961bc67d7f1f97af8a70227d9f90c31bba5806eec004978d752"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "tokio-native-tls"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
dependencies = [
 "native-tls",
 "tokio",
]

[[package]]
name = "tokio-rustls"
version = "0.26.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c7bc40d0e5a97695bb96e27995cd3a08538541b0a846f65bba7a359f36700d4"
dependencies = [
 "rustls",
 "rustls-pki-types",
 "tokio",
]

[[package]]
name = "tokio-stream"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4f4e6ce100d0eb49a2734f8c0812bcd324cf357d21810932c5df6b96ef2b86f1"
dependencies = [
 "futures-core",
 "pin-project-lite",
 "tokio",
 "tokio-util",
]

[[package]]
name = "tokio-tungstenite"
version = "0.24.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "edc5f74e248dc973e0dbb7b74c7e0d6fcc301c694ff50049504004ef4d0cdcd9"
dependencies = [
 "futures-util",
 "log",
 "rustls",
 "rustls-pki-types",
 "tokio",
 "tokio-rustls",
 "tungstenite",
 "webpki-roots",
]

[[package]]
name = "tokio-util"
version = "0.7.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61e7c3654c13bcd040d4a03abee2c75b1d14a37b423cf5a813ceae1cc903ec6a"
dependencies = [
 "bytes",
 "futures-core",
 "futures-sink",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "toml_datetime"
version = "0.6.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0dd7358ecb8fc2f8d014bf86f6f638ce72ba252a2c3a2572f2a795f1d23efb41"

[[package]]
name = "toml_edit"
version = "0.22.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ae48d6208a266e853d946088ed816055e556cc6028c5e8e2b84d9fa5dd7c7f5"
dependencies = [
 "indexmap",
 "toml_datetime",
 "winnow",
]

[[package]]
name = "tower"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2873938d487c3cfb9aed7546dc9f2711d867c9f90c46b889989a2cb84eba6b4f"
dependencies = [
 "futures-core",
 "futures-util",
 "pin-project-lite",
 "sync_wrapper 0.1.2",
 "tower-layer",
 "tower-service",
]

[[package]]
name = "tower-layer"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "121c2a6cda46980bb0fcd1647ffaf6cd3fc79a013de288782836f6df9c48780e"

[[package]]
name = "tower-service"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8df9b6e13f2d32c91b9bd719c00d1958837bc7dec474d94952798cc8e69eeec3"

[[package]]
name = "tracing"
version = "0.1.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3523ab5a71916ccf420eebdf5521fcef02141234bbc0b8a49f2fdc4544364ef"
dependencies = [
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34704c8d6ebcbc939824180af020566b01a7c01f80641264eba0999f6c2b6be7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "tracing-core"
version = "0.1.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c06d3da6113f116aaee68e4d601191614c9053067f9ab7f6edbcb161237daa54"
dependencies = [
 "once_cell",
]

[[package]]
name = "try-lock"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"

[[package]]
name = "tungstenite"
version = "0.24.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "18e5b8366ee7a95b16d32197d0b2604b43a0be89dc5fac9f8e96ccafbaedda8a"
dependencies = [
 "byteorder",
 "bytes",
 "data-encoding",
 "http 1.1.0",
 "httparse",
 "log",
 "rand 0.8.5",
 "rustls",
 "rustls-pki-types",
 "sha1",
 "thiserror",
 "utf-8",
]

[[package]]
name = "typenum"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"

[[package]]
name = "ucd-trie"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2896d95c02a80c6d6a5d6e953d479f5ddf2dfdb6a244441010e373ac0fb88971"

[[package]]
name = "uint"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76f64bba2c53b04fcab63c01a7d7427eadc821e3bc48c34dc9ba29c501164b52"
dependencies = [
 "byteorder",
 "crunchy",
 "hex",
 "static_assertions",
]

[[package]]
name = "unarray"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eaea85b334db583fe3274d12b4cd1880032beab409c0d774be044d4480ab9a94"

[[package]]
name = "unicode-bidi"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ab17db44d7388991a428b2ee655ce0c212e862eff1768a455c58f9aad6e7893"

[[package]]
name = "unicode-ident"
version = "1.0.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e91b56cd4cadaeb79bbf1a5645f6b4f8dc5bde8834ad5894a8db35fda9efa1fe"

[[package]]
name = "unicode-normalization"
version = "0.1.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921"
dependencies = [
 "tinyvec",
]

[[package]]
name = "unicode-xid"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebc1c04c71510c7f702b52b7c350734c9ff1295c464a03335b00bb84fc54f853"

[[package]]
name = "universal-hash"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc1de2c688dc15305988b563c3854064043356019f97a4b46276fe734c4f07ea"
dependencies = [
 "crypto-common",
 "subtle 2.6.1",
]

[[package]]
name = "untrusted"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ecb6da28b8a351d773b68d5825ac39017e680750f980f3a1a85cd8dd28a47c1"

[[package]]
name = "url"
version = "2.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22784dbdf76fdde8af1aeda5622b546b422b6fc585325248a2bf9f5e41e94d6c"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
]

[[package]]
name = "utf-8"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09cc8ee72d2a9becf2f2febe0205bbed8fc6615b7cb429ad062dc7b7ddd036a9"

[[package]]
name = "valuable"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830b7e5d4d90034032940e4ace0d9a9a057e7a45cd94e6c007832e39edb82f6d"

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "wait-timeout"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9f200f5b12eb75f8c1ed65abd4b2db8a6e1b138a20de009dacee265a2498f3f6"
dependencies = [
 "libc",
]

[[package]]
name = "wallet"
version = "0.1.0"
dependencies = [
 "alloy",
 "bincode",
 "bip39",
 "cipher 0.1.0",
 "config",
 "crypto",
 "hex",
 "proto",
 "rand 0.8.5",
 "rand_chacha 0.3.1",
 "serde",
 "serde_json",
 "session",
 "settings",
 "sha2 0.10.8",
 "storage",
 "zil_errors",
]

[[package]]
name = "want"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa7760aed19e106de2c7c0b581b509f2f25d3dacaf737cb82ac61bc6d760b0e"
dependencies = [
 "try-lock",
]

[[package]]
name = "wasi"
version = "0.9.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "128d1e363af62632b8eb57219c8fd7877144af57558fb2ef0368d0087bddeb2e"
dependencies = [
 "cfg-if",
 "once_cell",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb6dd4d3ca0ddffd1dd1c9c04f94b868c37ff5fac97c30b97cff2d74fce3a358"
dependencies = [
 "bumpalo",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "syn 2.0.85",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc7ec4f8827a71586374db3e87abdb5a2bb3a15afed140221307c3ec06b1f63b"
dependencies = [
 "cfg-if",
 "js-sys",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e79384be7f8f5a9dd5d7167216f022090cf1f9ec128e6e6a482a2cb5c5422c56"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26c6ab57572f7a24a4985830b120de1594465e5d500f24afe89e16b4e833ef68"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65fc09f10666a9f147042251e0dda9c18f166ff7de300607007e96bdebc1068d"

[[package]]
name = "web-sys"
version = "0.3.72"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6488b90108c040df0fe62fa815cbdee25124641df01814dd7282749234c6112"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "webpki-roots"
version = "0.26.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "841c67bff177718f1d4dfefde8d8f0e78f9b6589319ba88312f567fc5841a958"
dependencies = [
 "rustls-pki-types",
]

[[package]]
name = "widestring"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7219d36b6eac893fa81e84ebe06485e7dcbb616177469b142df14f1f4deb1311"

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-registry"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e400001bb720a623c1c69032f8e3e4cf09984deec740f007dd2b03ec864804b0"
dependencies = [
 "windows-result",
 "windows-strings",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-result"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d1043d8214f791817bab27572aaa8af63732e11bf84aa21a45a78d6c317ae0e"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-strings"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4cd9b125c486025df0eabcb585e62173c6c9eddcec5d117d3b6e8c30e2ee4d10"
dependencies = [
 "windows-result",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm 0.48.5",
 "windows_aarch64_msvc 0.48.5",
 "windows_i686_gnu 0.48.5",
 "windows_i686_msvc 0.48.5",
 "windows_x86_64_gnu 0.48.5",
 "windows_x86_64_gnullvm 0.48.5",
 "windows_x86_64_msvc 0.48.5",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "winnow"
version = "0.6.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36c1fec1a2bb5866f07c25f68c26e565c4c200aebb96d7e55710c19d3e8ac49b"
dependencies = [
 "memchr",
]

[[package]]
name = "winreg"
version = "0.50.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "524e57b2c537c0f9b1e69f1965311ec12182b4122e45035b1508cd24d2adadb1"
dependencies = [
 "cfg-if",
 "windows-sys 0.48.0",
]

[[package]]
name = "ws_stream_wasm"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7999f5f4217fe3818726b66257a4475f71e74ffd190776ad053fa159e50737f5"
dependencies = [
 "async_io_stream",
 "futures",
 "js-sys",
 "log",
 "pharos",
 "rustc_version 0.4.1",
 "send_wrapper",
 "thiserror",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
]

[[package]]
name = "wyz"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f360fc0b24296329c78fda852a1e9ae82de9cf7b27dae4b7f62f118f77b9ed"
dependencies = [
 "tap",
]

[[package]]
name = "zerocopy"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0"
dependencies = [
 "byteorder",
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "zeroize"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ced3678a2879b30306d323f4542626697a464a97c0a07c9aebf7ebca65cd4dde"
dependencies = [
 "zeroize_derive",
]

[[package]]
name = "zeroize_derive"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce36e65b0d2999d2aafac989fb249189a141aee1f53c612c1f37d72631959f69"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.85",
]

[[package]]
name = "zil_errors"
version = "0.1.0"
dependencies = [
 "ntrulp",
 "thiserror",
]

[[package]]
name = "zilliqa"
version = "0.1.0"
dependencies = [
 "config",
 "crypto",
 "hex",
 "mockito",
 "proto",
 "reqwest 0.11.27",
 "serde",
 "serde_json",
 "tokio",
 "zil_errors",
]

[[package]]
name = "zilpay"
version = "0.1.0"
dependencies = [
 "background",
 "config",
 "crypto",
 "proto",
 "settings",
 "wallet",
 "zil_errors",
]

[[package]]
name = "zilpay_core"
version = "0.1.0"
dependencies = [
 "alloy",
 "background",
 "bip39",
 "config",
 "crypto",
 "hex",
 "mockito",
 "ntrulp",
 "num_cpus",
 "proto",
 "rand 0.8.5",
 "rand_chacha 0.3.1",
 "reqwest 0.11.27",
 "ripemd",
 "serde",
 "serde_json",
 "settings",
 "sha2 0.10.8",
 "thiserror",
 "tokio",
 "wallet",
 "zil_errors",
 "zilpay",
]

================
File: Cargo.toml
================
[package]
name = "zilpay_core"
version = "0.1.0"
edition = "2021"
readme = "README.md"
repository = "https://github.com/zilpay/zilpay-core"
license = "GPL-3"
authors = ["Rinat.H <hicc0rus@gmail.com>"]
resolver = "2"

[lib]
name = "zilpay"
path = "zilpay/src/lib.rs"
crate-type = ["cdylib", "rlib"]

[workspace]
members = [
  "background",
  "bincode",
  "cipher",
  "config",
  "crypto",
  "network",
  "proto",
  "session",
  "settings",
  "storage",
  "wallet",
  "zil_errors",
  "zilliqa",
  "zilpay",
]

[dependencies]
zilpay = { path = "./zilpay" }
zil_errors = { path = "./zil_errors" }
background = { path = "./background" }
crypto = { path = "./crypto" }
wallet = { path = "./wallet" }
settings = { path = "./settings" }
config = { path = "./config" }
proto = { path = "./proto" }
hex = "0.4.3"
rand = "0.8.5"
rand_chacha = "0.3.1"
reqwest = "0.11"
serde = { version = "1.0.204", features = ["derive", "rc"] }
serde_json = "1.0.124"
sha2 = "0.10.8"
tokio = { version = "1.39.2", features = ["full", "test-util"] }
ntrulp = { version = "0.2.3", features = ["ntrup761", "std"] }
num_cpus = "1.16.0"
bip39 = "2.0.0"
ripemd = "0.1.3"
thiserror = "1.0.63"
alloy = { version = "0.4.2", features = ["full"] }


[dev-dependencies]
mockito = "1.5.0"
